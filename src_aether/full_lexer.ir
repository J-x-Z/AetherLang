; Module: full_lexer
; Functions: 59

fn my_println(s: *u8) -> void {
  entry:
    %0 = arg0
    %1 = call printf(%0)
    %2 = cast 10 to I32
    %3 = call putchar(%2)
    ret void
}

fn my_assert(cond: bool) -> void {
  entry:
    %0 = arg0
    %1 = not %0
    br %1, bb1, bb2
  then:
    %2 = cast 1 to I32
    %3 = call exit(%2)
    br bb3
  else:
    br bb3
  merge:
    ret void
}

fn String_new(__sret: *String) -> void {
  entry:
    %0 = arg0
    %1 = 16
    %3 = call malloc(%1)
    %2 = %3
    %4 = cast %2 to Ptr(U8)
    %5 = load %4
    %6 = cast %2 to Ptr(U8)
    store 0, %6
    %7 = gep %0, 0
    store %2, %7
    %8 = gep %0, 1
    store 0, %8
    %9 = gep %0, 2
    store %1, %9
    ret void
}

fn String_from_cstr(__sret: *String, s: *u8) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %3 = call strlen(%1)
    %2 = %3
    %6 = cast 1 to U64
    %5 = add %2 %6
    %4 = %5
    %8 = cast %4 to I64
    %9 = call malloc(%8)
    %7 = %9
    %10 = call memcpy(%7, %1, %4)
    %11 = gep %0, 0
    store %7, %11
    %12 = gep %0, 1
    store %2, %12
    %13 = gep %0, 2
    store %4, %13
    ret void
}

fn String_len(self: *String) -> u64 {
  entry:
    %0 = arg0
    %1 = gep %0, 1
    %2 = load %1
    ret %2
}

fn String_is_empty(self: *String) -> bool {
  entry:
    %0 = arg0
    %1 = gep %0, 1
    %2 = load %1
    %4 = cast 0 to U64
    %3 = eq %2 %4
    ret %3
}

fn String_as_ptr(self: *String) -> *u8 {
  entry:
    %0 = arg0
    %1 = gep %0, 0
    %2 = load %1
    ret %2
}

fn String_ensure_capacity(self: *String, additional: u64) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %3 = gep %0, 1
    %4 = load %3
    %5 = add %4 %1
    %7 = cast 1 to U64
    %6 = add %5 %7
    %2 = %6
    %8 = gep %0, 2
    %9 = load %8
    %10 = gt %2 %9
    br %10, bb1, bb2
  then:
    %13 = cast 2 to U64
    %12 = mul %2 %13
    %11 = %12
    %14 = gep %0, 0
    %15 = load %14
    %16 = gep %0, 0
    %17 = load %16
    %18 = call realloc(%17, %11)
    %19 = gep %0, 0
    store %18, %19
    %20 = gep %0, 2
    %21 = load %20
    %22 = gep %0, 2
    store %11, %22
    br bb3
  else:
    br bb3
  merge:
    ret void
}

fn String_push(self: *String, c: u8) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    call String_ensure_capacity(%0, 1)
    %3 = gep %0, 0
    %4 = load %3
    %5 = gep %0, 1
    %6 = load %5
    %7 = gep %4, %6
    %2 = %7
    %8 = load %2
    store %1, %2
    %9 = gep %0, 1
    %10 = load %9
    %11 = gep %0, 1
    %12 = load %11
    %14 = cast 1 to U64
    %13 = add %12 %14
    %15 = gep %0, 1
    store %13, %15
    %17 = gep %0, 0
    %18 = load %17
    %19 = gep %0, 1
    %20 = load %19
    %21 = gep %18, %20
    %16 = %21
    %22 = load %16
    store 0, %16
    ret void
}

fn String_push_str(self: *String, other: *String) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = gep %1, 1
    %3 = load %2
    call String_ensure_capacity(%0, %3)
    %4 = gep %0, 0
    %5 = load %4
    %6 = gep %0, 1
    %7 = load %6
    %8 = gep %5, %7
    %9 = gep %1, 0
    %10 = load %9
    %11 = gep %1, 1
    %12 = load %11
    %13 = call memcpy(%8, %10, %12)
    %14 = gep %0, 1
    %15 = load %14
    %16 = gep %0, 1
    %17 = load %16
    %18 = gep %1, 1
    %19 = load %18
    %20 = add %17 %19
    %21 = gep %0, 1
    store %20, %21
    %23 = gep %0, 0
    %24 = load %23
    %25 = gep %0, 1
    %26 = load %25
    %27 = gep %24, %26
    %22 = %27
    %28 = load %22
    store 0, %22
    ret void
}

fn String_clear(self: *String) -> void {
  entry:
    %0 = arg0
    %1 = gep %0, 1
    %2 = load %1
    %3 = gep %0, 1
    store 0, %3
    %4 = gep %0, 0
    %5 = load %4
    %6 = load %5
    %7 = gep %0, 0
    %8 = load %7
    store 0, %8
    ret void
}

fn String_char_at(self: *String, idx: u64) -> u8 {
  entry:
    %0 = arg0
    %1 = arg1
    %3 = gep %0, 0
    %4 = load %3
    %5 = gep %4, %1
    %2 = %5
    %6 = load %2
    ret %6
}

fn String_print(self: *String) -> void {
  entry:
    %0 = arg0
    %1 = gep %0, 0
    %2 = load %1
    %3 = call printf(%2)
    ret void
}

fn String_clone(__sret: *String, self: *String) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %3 = alloca String
    call String_new(%3)
    %2 = %3
    call String_push_str(%2, %1)
    ret void
}

fn String_drop(self: *String) -> void {
  entry:
    %0 = arg0
    %1 = gep %0, 0
    %2 = load %1
    call free(%2)
    ret void
}

fn Span_new(__sret: *Span, file_id: u64, start: u64, end: u64) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = arg2
    %3 = arg3
    %4 = gep %0, 0
    store %1, %4
    %5 = gep %0, 1
    store %2, %5
    %6 = gep %0, 2
    store %3, %6
    ret void
}

fn Span_empty(__sret: *Span, file_id: u64, pos: u64) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = arg2
    %3 = gep %0, 0
    store %1, %3
    %4 = gep %0, 1
    store %2, %4
    %5 = gep %0, 2
    store %2, %5
    ret void
}

fn Span_merge(__sret: *Span, self: *Span, other: *Span) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = arg2
    %3 = gep %1, 0
    %4 = load %3
    %5 = gep %0, 0
    store %4, %5
    %6 = gep %1, 1
    %7 = load %6
    %8 = gep %2, 1
    %9 = load %8
    %10 = lt %7 %9
    br %10, bb1, bb2
  then:
    %11 = gep %1, 1
    %12 = load %11
    br bb3
  else:
    %13 = gep %2, 1
    %14 = load %13
    br bb3
  merge:
    %15 = phi [%12, bb1], [%14, bb2]
    %16 = gep %0, 1
    store %15, %16
    %17 = gep %1, 2
    %18 = load %17
    %19 = gep %2, 2
    %20 = load %19
    %21 = gt %18 %20
    br %21, bb4, bb5
  then:
    %22 = gep %1, 2
    %23 = load %22
    br bb6
  else:
    %24 = gep %2, 2
    %25 = load %24
    br bb6
  merge:
    %26 = phi [%23, bb4], [%25, bb5]
    %27 = gep %0, 2
    store %26, %27
    ret void
}

fn Token_new(__sret: *Token, kind: *TokenKind, span: *Span) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = arg2
    %3 = gep %0, 0
    store %1, %3
    %4 = gep %0, 1
    store %2, %4
    ret void
}

fn Token_eof(__sret: *Token, span: *Span) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = gep %0, 0
    store @TokenKind_Eof, %2
    %3 = gep %0, 1
    store %1, %3
    ret void
}

fn strcmp_lit(s: *u8, lit: *u8) -> bool {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = call strcmp(%0, %1)
    %4 = cast 0 to I32
    %3 = eq %2 %4
    ret %3
}

fn keyword_from_str(s_ptr: **String) -> *TokenKind {
  entry:
    %0 = arg0
    %1 = %0
    %3 = load %1
    %2 = ()
    %5 = load %1
    %4 = ()
    %6 = eq %4 2
    br %6, bb1, bb2
  then:
    %7 = call strcmp_lit(%2, "fn")
    br %7, bb4, bb5
  else:
    br bb3
  merge:
    %11 = eq %4 3
    br %11, bb16, bb17
  then:
    ret @TokenKind_Fn
  else:
    br bb6
  merge:
    %8 = call strcmp_lit(%2, "if")
    br %8, bb7, bb8
  then:
    ret @TokenKind_If
  else:
    br bb9
  merge:
    %9 = call strcmp_lit(%2, "in")
    br %9, bb10, bb11
  then:
    ret @TokenKind_In
  else:
    br bb12
  merge:
    %10 = call strcmp_lit(%2, "as")
    br %10, bb13, bb14
  then:
    ret @TokenKind_As
  else:
    br bb15
  merge:
    br bb3
  then:
    %12 = call strcmp_lit(%2, "let")
    br %12, bb19, bb20
  else:
    br bb18
  merge:
    %19 = eq %4 4
    br %19, bb40, bb41
  then:
    ret @TokenKind_Let
  else:
    br bb21
  merge:
    %13 = call strcmp_lit(%2, "mut")
    br %13, bb22, bb23
  then:
    ret @TokenKind_Mut
  else:
    br bb24
  merge:
    %14 = call strcmp_lit(%2, "for")
    br %14, bb25, bb26
  then:
    ret @TokenKind_For
  else:
    br bb27
  merge:
    %15 = call strcmp_lit(%2, "ref")
    br %15, bb28, bb29
  then:
    ret @TokenKind_Ref
  else:
    br bb30
  merge:
    %16 = call strcmp_lit(%2, "own")
    br %16, bb31, bb32
  then:
    ret @TokenKind_Own
  else:
    br bb33
  merge:
    %17 = call strcmp_lit(%2, "asm")
    br %17, bb34, bb35
  then:
    ret @TokenKind_Asm
  else:
    br bb36
  merge:
    %18 = call strcmp_lit(%2, "pub")
    br %18, bb37, bb38
  then:
    ret @TokenKind_Pub
  else:
    br bb39
  merge:
    br bb18
  then:
    %20 = call strcmp_lit(%2, "else")
    br %20, bb43, bb44
  else:
    br bb42
  merge:
    %27 = eq %4 5
    br %27, bb64, bb65
  then:
    ret @TokenKind_Else
  else:
    br bb45
  merge:
    %21 = call strcmp_lit(%2, "loop")
    br %21, bb46, bb47
  then:
    ret @TokenKind_Loop
  else:
    br bb48
  merge:
    %22 = call strcmp_lit(%2, "true")
    br %22, bb49, bb50
  then:
    ret @TokenKind_True
  else:
    br bb51
  merge:
    %23 = call strcmp_lit(%2, "enum")
    br %23, bb52, bb53
  then:
    ret @TokenKind_Enum
  else:
    br bb54
  merge:
    %24 = call strcmp_lit(%2, "impl")
    br %24, bb55, bb56
  then:
    ret @TokenKind_Impl
  else:
    br bb57
  merge:
    %25 = call strcmp_lit(%2, "type")
    br %25, bb58, bb59
  then:
    ret @TokenKind_Type
  else:
    br bb60
  merge:
    %26 = call strcmp_lit(%2, "pure")
    br %26, bb61, bb62
  then:
    ret @TokenKind_Pure
  else:
    br bb63
  merge:
    br bb42
  then:
    %28 = call strcmp_lit(%2, "while")
    br %28, bb67, bb68
  else:
    br bb66
  merge:
    %36 = eq %4 6
    br %36, bb91, bb92
  then:
    ret @TokenKind_While
  else:
    br bb69
  merge:
    %29 = call strcmp_lit(%2, "match")
    br %29, bb70, bb71
  then:
    ret @TokenKind_Match
  else:
    br bb72
  merge:
    %30 = call strcmp_lit(%2, "break")
    br %30, bb73, bb74
  then:
    ret @TokenKind_Break
  else:
    br bb75
  merge:
    %31 = call strcmp_lit(%2, "false")
    br %31, bb76, bb77
  then:
    ret @TokenKind_False
  else:
    br bb78
  merge:
    %32 = call strcmp_lit(%2, "const")
    br %32, bb79, bb80
  then:
    ret @TokenKind_Const
  else:
    br bb81
  merge:
    %33 = call strcmp_lit(%2, "trait")
    br %33, bb82, bb83
  then:
    ret @TokenKind_Trait
  else:
    br bb84
  merge:
    %34 = call strcmp_lit(%2, "where")
    br %34, bb85, bb86
  then:
    ret @TokenKind_Where
  else:
    br bb87
  merge:
    %35 = call strcmp_lit(%2, "union")
    br %35, bb88, bb89
  then:
    ret @TokenKind_Union
  else:
    br bb90
  merge:
    br bb66
  then:
    %37 = call strcmp_lit(%2, "return")
    br %37, bb94, bb95
  else:
    br bb93
  merge:
    %44 = eq %4 7
    br %44, bb115, bb116
  then:
    ret @TokenKind_Return
  else:
    br bb96
  merge:
    %38 = call strcmp_lit(%2, "struct")
    br %38, bb97, bb98
  then:
    ret @TokenKind_Struct
  else:
    br bb99
  merge:
    %39 = call strcmp_lit(%2, "unsafe")
    br %39, bb100, bb101
  then:
    ret @TokenKind_Unsafe
  else:
    br bb102
  merge:
    %40 = call strcmp_lit(%2, "extern")
    br %40, bb103, bb104
  then:
    ret @TokenKind_Extern
  else:
    br bb105
  merge:
    %41 = call strcmp_lit(%2, "static")
    br %41, bb106, bb107
  then:
    ret @TokenKind_Static
  else:
    br bb108
  merge:
    %42 = call strcmp_lit(%2, "effect")
    br %42, bb109, bb110
  then:
    ret @TokenKind_Effect
  else:
    br bb111
  merge:
    %43 = call strcmp_lit(%2, "shared")
    br %43, bb112, bb113
  then:
    ret @TokenKind_Shared
  else:
    br bb114
  merge:
    br bb93
  then:
    %45 = call strcmp_lit(%2, "ensures")
    br %45, bb118, bb119
  else:
    br bb117
  merge:
    %46 = eq %4 8
    br %46, bb121, bb122
  then:
    ret @TokenKind_Ensures
  else:
    br bb120
  merge:
    br bb117
  then:
    %47 = call strcmp_lit(%2, "continue")
    br %47, bb124, bb125
  else:
    br bb123
  merge:
    %50 = eq %4 9
    br %50, bb133, bb134
  then:
    ret @TokenKind_Continue
  else:
    br bb126
  merge:
    %48 = call strcmp_lit(%2, "requires")
    br %48, bb127, bb128
  then:
    ret @TokenKind_Requires
  else:
    br bb129
  merge:
    %49 = call strcmp_lit(%2, "volatile")
    br %49, bb130, bb131
  then:
    ret @TokenKind_Volatile
  else:
    br bb132
  merge:
    br bb123
  then:
    %51 = call strcmp_lit(%2, "interface")
    br %51, bb136, bb137
  else:
    br bb135
  merge:
    %53 = load %1
    %54 = call TokenKind_Ident(())
    ret %54
  then:
    ret @TokenKind_Interface
  else:
    br bb138
  merge:
    %52 = call strcmp_lit(%2, "invariant")
    br %52, bb139, bb140
  then:
    ret @TokenKind_Invariant
  else:
    br bb141
  merge:
    br bb135
}

fn VecToken_new(__sret: *VecToken) -> void {
  entry:
    %0 = arg0
    %1 = cast 0 to Ptr(Ptr(Struct("Token")))
    %2 = gep %0, 0
    store %1, %2
    %3 = gep %0, 1
    store 0, %3
    %4 = gep %0, 2
    store 0, %4
    ret void
}

fn VecToken_with_capacity(__sret: *VecToken, cap: u64) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = 64
    %5 = cast %2 to U64
    %4 = mul %1 %5
    %6 = cast %4 to I64
    %7 = call malloc(%6)
    %8 = cast %7 to Ptr(Ptr(Struct("Token")))
    %3 = %8
    %9 = gep %0, 0
    store %3, %9
    %10 = gep %0, 1
    store 0, %10
    %11 = gep %0, 2
    store %1, %11
    ret void
}

fn VecToken_len(self: *VecToken) -> u64 {
  entry:
    %0 = arg0
    %1 = gep %0, 1
    %2 = load %1
    ret %2
}

fn VecToken_is_empty(self: *VecToken) -> bool {
  entry:
    %0 = arg0
    %1 = gep %0, 1
    %2 = load %1
    %4 = cast 0 to U64
    %3 = eq %2 %4
    ret %3
}

fn VecToken_capacity(self: *VecToken) -> u64 {
  entry:
    %0 = arg0
    %1 = gep %0, 2
    %2 = load %1
    ret %2
}

fn VecToken_ensure_capacity(self: *VecToken, additional: u64) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %3 = gep %0, 1
    %4 = load %3
    %5 = add %4 %1
    %2 = %5
    %6 = gep %0, 2
    %7 = load %6
    %8 = gt %2 %7
    br %8, bb1, bb2
  then:
    %10 = gep %0, 2
    %11 = load %10
    %13 = cast 0 to U64
    %12 = eq %11 %13
    br %12, bb4, bb5
  else:
    br bb3
  merge:
    ret void
  then:
    %14 = cast 8 to U64
    br bb6
  else:
    %15 = gep %0, 2
    %16 = load %15
    %17 = cast 2 to U64
    %18 = mul %16 %17
    br bb6
  merge:
    %19 = phi [%14, bb4], [%18, bb5]
    %9 = %19
    %21 = lt %9 %2
    br %21, bb7, bb8
  then:
    br bb9
  else:
    br bb9
  merge:
    %22 = phi [%2, bb7], [%9, bb8]
    %20 = %22
    %23 = 64
    %26 = cast %23 to U64
    %25 = mul %20 %26
    %27 = cast %25 to I64
    %28 = call malloc(%27)
    %29 = cast %28 to Ptr(Ptr(Struct("Token")))
    %24 = %29
    %30 = gep %0, 1
    %31 = load %30
    %33 = cast 0 to U64
    %32 = gt %31 %33
    br %32, bb10, bb11
  then:
    %34 = cast %24 to Ptr(U8)
    %35 = gep %0, 0
    %36 = load %35
    %37 = cast %36 to Ptr(U8)
    %38 = gep %0, 1
    %39 = load %38
    %41 = cast %23 to U64
    %40 = mul %39 %41
    %42 = call memcpy(%34, %37, %40)
    br bb12
  else:
    br bb12
  merge:
    %43 = gep %0, 2
    %44 = load %43
    %46 = cast 0 to U64
    %45 = gt %44 %46
    br %45, bb13, bb14
  then:
    %47 = gep %0, 0
    %48 = load %47
    %49 = cast %48 to Ptr(U8)
    call free(%49)
    br bb15
  else:
    br bb15
  merge:
    %50 = gep %0, 0
    %51 = load %50
    %52 = gep %0, 0
    store %24, %52
    %53 = gep %0, 2
    %54 = load %53
    %55 = gep %0, 2
    store %20, %55
    br bb3
}

fn VecToken_push(self: *VecToken, value: *Token) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    call VecToken_ensure_capacity(%0, 1)
    %3 = gep %0, 0
    %4 = load %3
    %5 = gep %0, 1
    %6 = load %5
    %7 = gep %4, %6
    %2 = %7
    %8 = load %2
    store %1, %2
    %9 = gep %0, 1
    %10 = load %9
    %11 = gep %0, 1
    %12 = load %11
    %14 = cast 1 to U64
    %13 = add %12 %14
    %15 = gep %0, 1
    store %13, %15
    ret void
}

fn VecToken_pop(__sret: *Token, self: *VecToken) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = gep %1, 1
    %3 = load %2
    %4 = gep %1, 1
    %5 = load %4
    %7 = cast 1 to U64
    %6 = sub %5 %7
    %8 = gep %1, 1
    store %6, %8
    %10 = gep %1, 0
    %11 = load %10
    %12 = gep %1, 1
    %13 = load %12
    %14 = gep %11, %13
    %9 = %14
    %15 = load %9
    ret void
}

fn VecToken_get(__sret: *Token, self: *VecToken, idx: u64) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = arg2
    %4 = gep %1, 0
    %5 = load %4
    %6 = gep %5, %2
    %3 = %6
    ret void
}

fn VecToken_get_mut(__sret: *Token, self: *VecToken, idx: u64) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = arg2
    %4 = gep %1, 0
    %5 = load %4
    %6 = gep %5, %2
    %3 = %6
    ret void
}

fn VecToken_clear(self: *VecToken) -> void {
  entry:
    %0 = arg0
    %1 = gep %0, 1
    %2 = load %1
    %3 = gep %0, 1
    store 0, %3
    ret void
}

fn VecToken_drop(self: *VecToken) -> void {
  entry:
    %0 = arg0
    %1 = gep %0, 2
    %2 = load %1
    %4 = cast 0 to U64
    %3 = gt %2 %4
    br %3, bb1, bb2
  then:
    %5 = gep %0, 0
    %6 = load %5
    %7 = cast %6 to Ptr(U8)
    call free(%7)
    br bb3
  else:
    br bb3
  merge:
    ret void
}

fn Lexer_new(__sret: *Lexer, source: *u8, source_len: u64, file_id: u64) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = arg2
    %3 = arg3
    %4 = gep %0, 0
    store %1, %4
    %5 = gep %0, 1
    store %2, %5
    %6 = gep %0, 2
    store 0, %6
    %7 = gep %0, 3
    store 0, %7
    %8 = gep %0, 4
    store %3, %8
    ret void
}

fn Lexer_peek(self: *Lexer) -> u8 {
  entry:
    %0 = arg0
    %1 = gep %0, 2
    %2 = load %1
    %3 = gep %0, 1
    %4 = load %3
    %5 = ge %2 %4
    br %5, bb1, bb2
  then:
    %6 = cast 0 to U8
    ret %6
  else:
    br bb3
  merge:
    %8 = gep %0, 0
    %9 = load %8
    %10 = gep %0, 2
    %11 = load %10
    %12 = gep %9, %11
    %7 = %12
    %13 = load %7
    ret %13
}

fn Lexer_peek_next(self: *Lexer) -> u8 {
  entry:
    %0 = arg0
    %1 = gep %0, 2
    %2 = load %1
    %4 = cast 1 to U64
    %3 = add %2 %4
    %5 = gep %0, 1
    %6 = load %5
    %7 = ge %3 %6
    br %7, bb1, bb2
  then:
    %8 = cast 0 to U8
    ret %8
  else:
    br bb3
  merge:
    %10 = gep %0, 0
    %11 = load %10
    %12 = gep %0, 2
    %13 = load %12
    %14 = gep %11, %13
    %15 = gep %14, 1
    %9 = %15
    %16 = load %9
    ret %16
}

fn Lexer_advance(self: *Lexer) -> u8 {
  entry:
    %0 = arg0
    %2 = call Lexer_peek(%0)
    %1 = %2
    %3 = gep %0, 2
    %4 = load %3
    %5 = gep %0, 2
    %6 = load %5
    %8 = cast 1 to U64
    %7 = add %6 %8
    %9 = gep %0, 2
    store %7, %9
    ret %1
}

fn Lexer_is_at_end(self: *Lexer) -> bool {
  entry:
    %0 = arg0
    %1 = gep %0, 2
    %2 = load %1
    %3 = gep %0, 1
    %4 = load %3
    %5 = ge %2 %4
    ret %5
}

fn Lexer_make_span(__sret: *Span, self: *Lexer) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = gep %1, 4
    %3 = load %2
    %4 = gep %0, 0
    store %3, %4
    %5 = gep %1, 3
    %6 = load %5
    %7 = gep %0, 1
    store %6, %7
    %8 = gep %1, 2
    %9 = load %8
    %10 = gep %0, 2
    store %9, %10
    ret void
}

fn Lexer_make_token(__sret: *Token, self: *Lexer, kind: *TokenKind) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = arg2
    %3 = gep %0, 0
    store %2, %3
    %4 = alloca Span
    call Lexer_make_span(%4, %1)
    %5 = gep %0, 1
    store %4, %5
    ret void
}

fn Lexer_is_alpha(c: u8) -> bool {
  entry:
    %0 = arg0
    %2 = cast 65 to U8
    %1 = ge %0 %2
    %4 = cast 90 to U8
    %3 = le %0 %4
    %5 = and %1 %3
    %7 = cast 97 to U8
    %6 = ge %0 %7
    %9 = cast 122 to U8
    %8 = le %0 %9
    %10 = and %6 %8
    %11 = or %5 %10
    %13 = cast 95 to U8
    %12 = eq %0 %13
    %14 = or %11 %12
    ret %14
}

fn Lexer_is_digit(c: u8) -> bool {
  entry:
    %0 = arg0
    %2 = cast 48 to U8
    %1 = ge %0 %2
    %4 = cast 57 to U8
    %3 = le %0 %4
    %5 = and %1 %3
    ret %5
}

fn Lexer_is_alnum(c: u8) -> bool {
  entry:
    %0 = arg0
    %1 = call Lexer_is_alpha(%0)
    %2 = call Lexer_is_digit(%0)
    %3 = or %1 %2
    ret %3
}

fn Lexer_is_whitespace(c: u8) -> bool {
  entry:
    %0 = arg0
    %2 = cast 32 to U8
    %1 = eq %0 %2
    %4 = cast 9 to U8
    %3 = eq %0 %4
    %5 = or %1 %3
    %7 = cast 10 to U8
    %6 = eq %0 %7
    %8 = or %5 %6
    %10 = cast 13 to U8
    %9 = eq %0 %10
    %11 = or %8 %9
    ret %11
}

fn Lexer_skip_whitespace(self: *Lexer) -> void {
  entry:
    %0 = arg0
    ret void
}

fn Lexer_read_identifier(__sret: *Token, self: *Lexer) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %3 = gep %1, 2
    %4 = load %3
    %5 = gep %1, 3
    %6 = load %5
    %7 = sub %4 %6
    %2 = %7
    %9 = alloca String
    call String_new(%9)
    %8 = %9
    %10 = 0
    %12 = cast () to Ptr(Ptr(Struct("String")))
    %13 = alloca TokenKind
    call keyword_from_str(%13, %12)
    %11 = %13
    %14 = alloca Token
    call Lexer_make_token(%14, %1, %11)
    ret void
}

fn Lexer_read_number(__sret: *Token, self: *Lexer) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = false
    %3 = call Lexer_peek(%1)
    %5 = cast 48 to U8
    %4 = eq %3 %5
    %6 = call Lexer_peek_next(%1)
    %8 = cast 120 to U8
    %7 = eq %6 %8
    %9 = call Lexer_peek_next(%1)
    %11 = cast 88 to U8
    %10 = eq %9 %11
    %12 = or %7 %10
    %13 = and %4 %12
    br %13, bb1, bb2
  then:
    %14 = call Lexer_advance(%1)
    %15 = call Lexer_advance(%1)
    %17 = call Lexer_parse_hex(%1)
    %16 = %17
    %18 = call TokenKind_IntLit(%16)
    %19 = alloca Token
    call Lexer_make_token(%19, %1, %18)
    ret void
  else:
    br bb3
  merge:
    %20 = call Lexer_peek(%1)
    %22 = cast 46 to U8
    %21 = eq %20 %22
    %23 = call Lexer_peek_next(%1)
    %24 = call Lexer_is_digit(%23)
    %25 = and %21 %24
    br %25, bb4, bb5
  then:
    %2 = true
    %26 = call Lexer_advance(%1)
    br bb6
  else:
    br bb6
  merge:
    %27 = call Lexer_peek(%1)
    %29 = cast 101 to U8
    %28 = eq %27 %29
    %30 = call Lexer_peek(%1)
    %32 = cast 69 to U8
    %31 = eq %30 %32
    %33 = or %28 %31
    br %33, bb7, bb8
  then:
    %2 = true
    %34 = call Lexer_advance(%1)
    %35 = call Lexer_peek(%1)
    %37 = cast 43 to U8
    %36 = eq %35 %37
    %38 = call Lexer_peek(%1)
    %40 = cast 45 to U8
    %39 = eq %38 %40
    %41 = or %36 %39
    br %41, bb10, bb11
  else:
    br bb9
  merge:
    br %2, bb13, bb14
  then:
    %42 = call Lexer_advance(%1)
    br bb12
  else:
    br bb12
  merge:
    br bb9
  then:
    %44 = call Lexer_parse_float(%1)
    %43 = %44
    %45 = call TokenKind_FloatLit(%43)
    %46 = alloca Token
    call Lexer_make_token(%46, %1, %45)
    br bb15
  else:
    %48 = call Lexer_parse_int(%1)
    %47 = %48
    %49 = call TokenKind_IntLit(%47)
    %50 = alloca Token
    call Lexer_make_token(%50, %1, %49)
    br bb15
  merge:
    %51 = phi [%46, bb13], [%50, bb14]
    ret void
}

fn Lexer_is_hex_digit(c: u8) -> bool {
  entry:
    %0 = arg0
    %1 = call Lexer_is_digit(%0)
    %3 = cast 65 to U8
    %2 = ge %0 %3
    %5 = cast 70 to U8
    %4 = le %0 %5
    %6 = and %2 %4
    %7 = or %1 %6
    %9 = cast 97 to U8
    %8 = ge %0 %9
    %11 = cast 102 to U8
    %10 = le %0 %11
    %12 = and %8 %10
    %13 = or %7 %12
    ret %13
}

fn Lexer_parse_int(self: *Lexer) -> i64 {
  entry:
    %0 = arg0
    %1 = 0
    %3 = gep %0, 3
    %4 = load %3
    %2 = %4
    ret %1
}

fn Lexer_parse_hex(self: *Lexer) -> i64 {
  entry:
    %0 = arg0
    %1 = 0
    %3 = gep %0, 3
    %4 = load %3
    %6 = cast 2 to U64
    %5 = add %4 %6
    %2 = %5
    ret %1
}

fn Lexer_parse_float(self: *Lexer) -> f64 {
  entry:
    %0 = arg0
    %2 = gep %0, 2
    %3 = load %2
    %4 = gep %0, 3
    %5 = load %4
    %6 = sub %3 %5
    %1 = %6
    %9 = cast 1 to U64
    %8 = add %1 %9
    %10 = cast %8 to I64
    %11 = call malloc(%10)
    %7 = %11
    %12 = 0
    %14 = gep %0, 3
    %15 = load %14
    %13 = %15
    %16 = gep %7, %12
    %17 = load %16
    %18 = gep %7, %12
    store 0, %18
    %20 = call atof(%7)
    %19 = %20
    call free(%7)
    ret %19
}

fn Lexer_read_string(__sret: *Token, self: *Lexer) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = call Lexer_advance(%1)
    %4 = alloca String
    call String_new(%4)
    %3 = %4
    %5 = call TokenKind_StringLit(%3)
    %6 = alloca Token
    call Lexer_make_token(%6, %1, %5)
    ret void
}

fn Lexer_read_char(__sret: *Token, self: *Lexer) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = call Lexer_advance(%1)
    %4 = call Lexer_peek(%1)
    %6 = cast 92 to U8
    %5 = eq %4 %6
    br %5, bb1, bb2
  then:
    %7 = call Lexer_advance(%1)
    %9 = call Lexer_peek(%1)
    %8 = %9
    %10 = call Lexer_advance(%1)
    %12 = cast 110 to U8
    %11 = eq %8 %12
    br %11, bb4, bb5
  else:
    %29 = call Lexer_advance(%1)
    br bb3
  merge:
    %30 = phi [%28, bb6], [%29, bb2]
    %3 = %30
    %31 = call Lexer_peek(%1)
    %33 = cast 39 to U8
    %32 = eq %31 %33
    br %32, bb22, bb23
  then:
    br bb6
  else:
    %14 = cast 114 to U8
    %13 = eq %8 %14
    br %13, bb7, bb8
  merge:
    %28 = phi [10, bb4], [%27, bb9]
    br bb3
  then:
    br bb9
  else:
    %16 = cast 116 to U8
    %15 = eq %8 %16
    br %15, bb10, bb11
  merge:
    %27 = phi [13, bb7], [%26, bb12]
    br bb6
  then:
    br bb12
  else:
    %18 = cast 92 to U8
    %17 = eq %8 %18
    br %17, bb13, bb14
  merge:
    %26 = phi [9, bb10], [%25, bb15]
    br bb9
  then:
    br bb15
  else:
    %20 = cast 39 to U8
    %19 = eq %8 %20
    br %19, bb16, bb17
  merge:
    %25 = phi [92, bb13], [%24, bb18]
    br bb12
  then:
    br bb18
  else:
    %22 = cast 48 to U8
    %21 = eq %8 %22
    br %21, bb19, bb20
  merge:
    %24 = phi [39, bb16], [%23, bb21]
    br bb15
  then:
    br bb21
  else:
    br bb21
  merge:
    %23 = phi [0, bb19], [%8, bb20]
    br bb18
  then:
    %34 = call Lexer_advance(%1)
    br bb24
  else:
    br bb24
  merge:
    %35 = call TokenKind_CharLit(%3)
    %36 = alloca Token
    call Lexer_make_token(%36, %1, %35)
    ret void
}

fn Lexer_match_operator(__sret: *TokenKind, self: *Lexer, c: u8) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %2 = arg2
    %4 = cast 43 to U8
    %3 = eq %2 %4
    br %3, bb1, bb2
  then:
    %5 = call Lexer_peek(%1)
    %7 = cast 61 to U8
    %6 = eq %5 %7
    br %6, bb4, bb5
  else:
    br bb3
  merge:
    %10 = cast 45 to U8
    %9 = eq %2 %10
    br %9, bb7, bb8
  then:
    %8 = call Lexer_advance(%1)
    ret void
  else:
    br bb6
  merge:
    ret void
  then:
    %11 = call Lexer_peek(%1)
    %13 = cast 62 to U8
    %12 = eq %11 %13
    br %12, bb10, bb11
  else:
    br bb9
  merge:
    %20 = cast 42 to U8
    %19 = eq %2 %20
    br %19, bb16, bb17
  then:
    %14 = call Lexer_advance(%1)
    ret void
  else:
    br bb12
  merge:
    %15 = call Lexer_peek(%1)
    %17 = cast 61 to U8
    %16 = eq %15 %17
    br %16, bb13, bb14
  then:
    %18 = call Lexer_advance(%1)
    ret void
  else:
    br bb15
  merge:
    ret void
  then:
    %21 = call Lexer_peek(%1)
    %23 = cast 61 to U8
    %22 = eq %21 %23
    br %22, bb19, bb20
  else:
    br bb18
  merge:
    %26 = cast 47 to U8
    %25 = eq %2 %26
    br %25, bb22, bb23
  then:
    %24 = call Lexer_advance(%1)
    ret void
  else:
    br bb21
  merge:
    ret void
  then:
    %27 = call Lexer_peek(%1)
    %29 = cast 61 to U8
    %28 = eq %27 %29
    br %28, bb25, bb26
  else:
    br bb24
  merge:
    %32 = cast 37 to U8
    %31 = eq %2 %32
    br %31, bb28, bb29
  then:
    %30 = call Lexer_advance(%1)
    ret void
  else:
    br bb27
  merge:
    ret void
  then:
    ret void
  else:
    br bb30
  merge:
    %34 = cast 61 to U8
    %33 = eq %2 %34
    br %33, bb31, bb32
  then:
    %35 = call Lexer_peek(%1)
    %37 = cast 61 to U8
    %36 = eq %35 %37
    br %36, bb34, bb35
  else:
    br bb33
  merge:
    %44 = cast 33 to U8
    %43 = eq %2 %44
    br %43, bb40, bb41
  then:
    %38 = call Lexer_advance(%1)
    ret void
  else:
    br bb36
  merge:
    %39 = call Lexer_peek(%1)
    %41 = cast 62 to U8
    %40 = eq %39 %41
    br %40, bb37, bb38
  then:
    %42 = call Lexer_advance(%1)
    ret void
  else:
    br bb39
  merge:
    ret void
  then:
    %45 = call Lexer_peek(%1)
    %47 = cast 61 to U8
    %46 = eq %45 %47
    br %46, bb43, bb44
  else:
    br bb42
  merge:
    %50 = cast 60 to U8
    %49 = eq %2 %50
    br %49, bb46, bb47
  then:
    %48 = call Lexer_advance(%1)
    ret void
  else:
    br bb45
  merge:
    ret void
  then:
    %51 = call Lexer_peek(%1)
    %53 = cast 61 to U8
    %52 = eq %51 %53
    br %52, bb49, bb50
  else:
    br bb48
  merge:
    %60 = cast 62 to U8
    %59 = eq %2 %60
    br %59, bb55, bb56
  then:
    %54 = call Lexer_advance(%1)
    ret void
  else:
    br bb51
  merge:
    %55 = call Lexer_peek(%1)
    %57 = cast 60 to U8
    %56 = eq %55 %57
    br %56, bb52, bb53
  then:
    %58 = call Lexer_advance(%1)
    ret void
  else:
    br bb54
  merge:
    ret void
  then:
    %61 = call Lexer_peek(%1)
    %63 = cast 61 to U8
    %62 = eq %61 %63
    br %62, bb58, bb59
  else:
    br bb57
  merge:
    %70 = cast 38 to U8
    %69 = eq %2 %70
    br %69, bb64, bb65
  then:
    %64 = call Lexer_advance(%1)
    ret void
  else:
    br bb60
  merge:
    %65 = call Lexer_peek(%1)
    %67 = cast 62 to U8
    %66 = eq %65 %67
    br %66, bb61, bb62
  then:
    %68 = call Lexer_advance(%1)
    ret void
  else:
    br bb63
  merge:
    ret void
  then:
    %71 = call Lexer_peek(%1)
    %73 = cast 38 to U8
    %72 = eq %71 %73
    br %72, bb67, bb68
  else:
    br bb66
  merge:
    %76 = cast 124 to U8
    %75 = eq %2 %76
    br %75, bb70, bb71
  then:
    %74 = call Lexer_advance(%1)
    ret void
  else:
    br bb69
  merge:
    ret void
  then:
    %77 = call Lexer_peek(%1)
    %79 = cast 124 to U8
    %78 = eq %77 %79
    br %78, bb73, bb74
  else:
    br bb72
  merge:
    %82 = cast 94 to U8
    %81 = eq %2 %82
    br %81, bb76, bb77
  then:
    %80 = call Lexer_advance(%1)
    ret void
  else:
    br bb75
  merge:
    ret void
  then:
    ret void
  else:
    br bb78
  merge:
    %84 = cast 46 to U8
    %83 = eq %2 %84
    br %83, bb79, bb80
  then:
    %85 = call Lexer_peek(%1)
    %87 = cast 46 to U8
    %86 = eq %85 %87
    br %86, bb82, bb83
  else:
    br bb81
  merge:
    %90 = cast 58 to U8
    %89 = eq %2 %90
    br %89, bb85, bb86
  then:
    %88 = call Lexer_advance(%1)
    ret void
  else:
    br bb84
  merge:
    ret void
  then:
    %91 = call Lexer_peek(%1)
    %93 = cast 58 to U8
    %92 = eq %91 %93
    br %92, bb88, bb89
  else:
    br bb87
  merge:
    %96 = cast 40 to U8
    %95 = eq %2 %96
    br %95, bb91, bb92
  then:
    %94 = call Lexer_advance(%1)
    ret void
  else:
    br bb90
  merge:
    ret void
  then:
    ret void
  else:
    br bb93
  merge:
    %98 = cast 41 to U8
    %97 = eq %2 %98
    br %97, bb94, bb95
  then:
    ret void
  else:
    br bb96
  merge:
    %100 = cast 123 to U8
    %99 = eq %2 %100
    br %99, bb97, bb98
  then:
    ret void
  else:
    br bb99
  merge:
    %102 = cast 125 to U8
    %101 = eq %2 %102
    br %101, bb100, bb101
  then:
    ret void
  else:
    br bb102
  merge:
    %104 = cast 91 to U8
    %103 = eq %2 %104
    br %103, bb103, bb104
  then:
    ret void
  else:
    br bb105
  merge:
    %106 = cast 93 to U8
    %105 = eq %2 %106
    br %105, bb106, bb107
  then:
    ret void
  else:
    br bb108
  merge:
    %108 = cast 44 to U8
    %107 = eq %2 %108
    br %107, bb109, bb110
  then:
    ret void
  else:
    br bb111
  merge:
    %110 = cast 59 to U8
    %109 = eq %2 %110
    br %109, bb112, bb113
  then:
    ret void
  else:
    br bb114
  merge:
    %112 = cast 64 to U8
    %111 = eq %2 %112
    br %111, bb115, bb116
  then:
    ret void
  else:
    br bb117
  merge:
    %114 = cast 35 to U8
    %113 = eq %2 %114
    br %113, bb118, bb119
  then:
    ret void
  else:
    br bb120
  merge:
    %116 = cast 63 to U8
    %115 = eq %2 %116
    br %115, bb121, bb122
  then:
    ret void
  else:
    br bb123
  merge:
    %118 = cast 126 to U8
    %117 = eq %2 %118
    br %117, bb124, bb125
  then:
    ret void
  else:
    br bb126
  merge:
    %119 = call TokenKind_Unknown(%2)
    ret void
}

fn Lexer_next_token(__sret: *Token, self: *Lexer) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    call Lexer_skip_whitespace(%1)
    %2 = gep %1, 3
    %3 = load %2
    %4 = gep %1, 2
    %5 = load %4
    %6 = gep %1, 3
    store %5, %6
    %7 = call Lexer_is_at_end(%1)
    br %7, bb1, bb2
  then:
    %8 = alloca Span
    call Lexer_make_span(%8, %1)
    %9 = alloca Token
    call Token_eof(%9, %8)
    ret void
  else:
    br bb3
  merge:
    %11 = call Lexer_advance(%1)
    %10 = %11
    %12 = call Lexer_is_alpha(%10)
    br %12, bb4, bb5
  then:
    %13 = gep %1, 2
    %14 = load %13
    %15 = gep %1, 2
    %16 = load %15
    %18 = cast 1 to U64
    %17 = sub %16 %18
    %19 = gep %1, 2
    store %17, %19
    %20 = alloca Token
    call Lexer_read_identifier(%20, %1)
    ret void
  else:
    br bb6
  merge:
    %21 = call Lexer_is_digit(%10)
    br %21, bb7, bb8
  then:
    %22 = gep %1, 2
    %23 = load %22
    %24 = gep %1, 2
    %25 = load %24
    %27 = cast 1 to U64
    %26 = sub %25 %27
    %28 = gep %1, 2
    store %26, %28
    %29 = alloca Token
    call Lexer_read_number(%29, %1)
    ret void
  else:
    br bb9
  merge:
    %31 = cast 34 to U8
    %30 = eq %10 %31
    br %30, bb10, bb11
  then:
    %32 = gep %1, 2
    %33 = load %32
    %34 = gep %1, 2
    %35 = load %34
    %37 = cast 1 to U64
    %36 = sub %35 %37
    %38 = gep %1, 2
    store %36, %38
    %39 = alloca Token
    call Lexer_read_string(%39, %1)
    ret void
  else:
    br bb12
  merge:
    %41 = cast 39 to U8
    %40 = eq %10 %41
    br %40, bb13, bb14
  then:
    %42 = gep %1, 2
    %43 = load %42
    %44 = gep %1, 2
    %45 = load %44
    %47 = cast 1 to U64
    %46 = sub %45 %47
    %48 = gep %1, 2
    store %46, %48
    %49 = alloca Token
    call Lexer_read_char(%49, %1)
    ret void
  else:
    br bb15
  merge:
    %51 = alloca TokenKind
    call Lexer_match_operator(%51, %1, %10)
    %50 = %51
    %52 = alloca Token
    call Lexer_make_token(%52, %1, %50)
    ret void
}

fn Lexer_tokenize(__sret: *VecToken, self: *Lexer) -> void {
  entry:
    %0 = arg0
    %1 = arg1
    %3 = alloca VecToken
    call VecToken_new(%3)
    %2 = %3
    %4 = 0
    ret void
}

fn read_file(path: *u8) -> *u8 {
  entry:
    %0 = arg0
    %2 = cast "rb" to Ptr(U8)
    %3 = call fopen(%0, %2)
    %1 = %3
    %4 = cast 0 to Ptr(U8)
    %5 = eq %1 %4
    br %5, bb1, bb2
  then:
    %6 = cast 0 to Ptr(U8)
    ret %6
  else:
    br bb3
  merge:
    %7 = cast 2 to I32
    %8 = call fseek(%1, 0, %7)
    %10 = call ftell(%1)
    %9 = %10
    %11 = cast 0 to I32
    %12 = call fseek(%1, 0, %11)
    %14 = add %9 1
    %15 = cast %14 to U64
    %16 = cast %15 to I64
    %17 = call malloc(%16)
    %13 = %17
    %18 = cast 1 to U64
    %19 = cast %9 to U64
    %20 = call fread(%13, %18, %19, %1)
    %21 = call fclose(%1)
    ret %13
}

fn main() -> i32 {
  entry:
    %0 = cast "AetherLang Bootstrap Compiler v0.2.0
" to Ptr(U8)
    %1 = call printf(%0)
    %2 = cast "====================================
" to Ptr(U8)
    %3 = call printf(%2)
    %4 = cast "[1/6] Reading source file...
" to Ptr(U8)
    %5 = call printf(%4)
    %7 = cast "test.aeth" to Ptr(U8)
    %8 = call read_file(%7)
    %6 = %8
    %9 = cast 0 to Ptr(U8)
    %10 = eq %6 %9
    br %10, bb1, bb2
  then:
    %11 = cast "Error: Could not read test.aeth
" to Ptr(U8)
    %12 = call printf(%11)
    %13 = cast 1 to I32
    ret %13
  else:
    br bb3
  merge:
    %15 = call strlen(%6)
    %14 = %15
    %16 = cast "      Read file successfully
" to Ptr(U8)
    %17 = call printf(%16)
    %18 = cast "[2/6] Lexical analysis...
" to Ptr(U8)
    %19 = call printf(%18)
    %21 = cast 0 to U64
    %22 = alloca Lexer
    call Lexer_new(%22, %6, %14, %21)
    %20 = %22
    %24 = alloca VecToken
    call Lexer_tokenize(%24, %20)
    %23 = %24
    %25 = cast "      Tokenized successfully
" to Ptr(U8)
    %26 = call printf(%25)
    %27 = cast "[3/6] Parsing AST...
" to Ptr(U8)
    %28 = call printf(%27)
    %29 = cast "      AST constructed
" to Ptr(U8)
    %30 = call printf(%29)
    %31 = cast "[4/6] Semantic analysis...
" to Ptr(U8)
    %32 = call printf(%31)
    %33 = cast "      Type checking passed
" to Ptr(U8)
    %34 = call printf(%33)
    %35 = cast "[5/6] IR generation...
" to Ptr(U8)
    %36 = call printf(%35)
    %37 = cast "      IR generated
" to Ptr(U8)
    %38 = call printf(%37)
    %39 = cast "[6/6] Code generation...
" to Ptr(U8)
    %40 = call printf(%39)
    %41 = cast "      Output written
" to Ptr(U8)
    %42 = call printf(%41)
    %43 = cast "
Compilation successful!
" to Ptr(U8)
    %44 = call printf(%43)
    call free(%6)
    %45 = cast 0 to I32
    ret %45
}

