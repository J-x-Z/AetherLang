/* Generated by AetherLang C Backend */
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <immintrin.h>  /* SSE/AVX */

/* AetherLang Runtime */
static void aether_print(const char* s) { printf("%s", s); }
static void aether_println(const char* s) { printf("%s\n", s); }
static void aether_print_i64(int64_t n) { printf("%lld", (long long)n); }
static void aether_println_i64(int64_t n) { printf("%lld\n", (long long)n); }
static void aether_assert(bool c) { if(!c) { fprintf(stderr, "Assertion failed\n"); exit(1); } }

/* Struct Definitions */
struct Span {
    int64_t file_id;
    int64_t start;
    int64_t end;
};

struct String {
    int8_t* data;
    int64_t len;
    int64_t cap;
};

struct Token {
    struct TokenKind* kind;
    struct Span* span;
};

void Token_new(struct Token*, struct TokenKind*, struct Span*);
void Token_eof(struct Token*, struct Span*);
bool strcmp_lit(uint8_t*, uint8_t*);
struct TokenKind* keyword_from_str(struct String*);

void Token_new(struct Token* _arg0, struct TokenKind* _arg1, struct Span* _arg2) {
    struct Span* _t2;
    struct Span** _t4;
    struct Token* _t0;
    struct TokenKind* _t1;
    struct TokenKind** _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t0->kind;
    *_t3 = _t1;
    _t4 = &_t0->span;
    *_t4 = _t2;
    return;
}

void Token_eof(struct Token* _arg0, struct Span* _arg1) {
    struct Span* _t1;
    struct Span** _t3;
    struct Token* _t0;
    struct TokenKind** _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->kind;
    *_t2 = TokenKind_Eof;
    _t3 = &_t0->span;
    *_t3 = _t1;
    return;
}

bool strcmp_lit(uint8_t* _arg0, uint8_t* _arg1) {
    int32_t _t3;
    int64_t _t2;
    int64_t _t4;
    uint8_t* _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    strcmp(_t0, _t1);
    _t3 = (int32_t)0LL;
    _t4 = _t2 == _t3;
    return _t4;
}

struct TokenKind* keyword_from_str(struct String* _arg0) {
    bool _t11;
    bool _t12;
    bool _t13;
    bool _t14;
    bool _t15;
    bool _t16;
    bool _t17;
    bool _t19;
    bool _t20;
    bool _t21;
    bool _t22;
    bool _t23;
    bool _t24;
    bool _t25;
    bool _t27;
    bool _t28;
    bool _t29;
    bool _t30;
    bool _t31;
    bool _t32;
    bool _t33;
    bool _t34;
    bool _t36;
    bool _t37;
    bool _t38;
    bool _t39;
    bool _t40;
    bool _t41;
    bool _t42;
    bool _t44;
    bool _t46;
    bool _t47;
    bool _t48;
    bool _t4;
    bool _t50;
    bool _t6;
    bool _t7;
    bool _t8;
    bool _t9;
    int64_t _t10;
    int64_t _t18;
    int64_t _t1;
    int64_t _t26;
    int64_t _t2;
    int64_t _t35;
    int64_t _t3;
    int64_t _t43;
    int64_t _t45;
    int64_t _t49;
    int64_t _t5;
    struct String* _t0;
    
    _t0 = _arg0;
    String_as_ptr(_t0);
    _t1 = ((void)0);
    String_len(_t0);
    _t2 = ((void)0);
    _t3 = _t2 == 2LL;
    if (_t3) goto L_then; else goto L_else;
L_then:
    _t4 = strcmp_lit(_t1, "fn");
    if (_t4) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t5 = _t2 == 3LL;
    if (_t5) goto L_then; else goto L_else;
L_then:
    return TokenKind_Fn;
L_else:
    goto L_merge;
L_merge:
    _t6 = strcmp_lit(_t1, "if");
    if (_t6) goto L_then; else goto L_else;
L_then:
    return TokenKind_If;
L_else:
    goto L_merge;
L_merge:
    _t7 = strcmp_lit(_t1, "in");
    if (_t7) goto L_then; else goto L_else;
L_then:
    return TokenKind_In;
L_else:
    goto L_merge;
L_merge:
    _t8 = strcmp_lit(_t1, "as");
    if (_t8) goto L_then; else goto L_else;
L_then:
    return TokenKind_As;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t9 = strcmp_lit(_t1, "let");
    if (_t9) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t10 = _t2 == 4LL;
    if (_t10) goto L_then; else goto L_else;
L_then:
    return TokenKind_Let;
L_else:
    goto L_merge;
L_merge:
    _t11 = strcmp_lit(_t1, "mut");
    if (_t11) goto L_then; else goto L_else;
L_then:
    return TokenKind_Mut;
L_else:
    goto L_merge;
L_merge:
    _t12 = strcmp_lit(_t1, "for");
    if (_t12) goto L_then; else goto L_else;
L_then:
    return TokenKind_For;
L_else:
    goto L_merge;
L_merge:
    _t13 = strcmp_lit(_t1, "ref");
    if (_t13) goto L_then; else goto L_else;
L_then:
    return TokenKind_Ref;
L_else:
    goto L_merge;
L_merge:
    _t14 = strcmp_lit(_t1, "own");
    if (_t14) goto L_then; else goto L_else;
L_then:
    return TokenKind_Own;
L_else:
    goto L_merge;
L_merge:
    _t15 = strcmp_lit(_t1, "asm");
    if (_t15) goto L_then; else goto L_else;
L_then:
    return TokenKind_Asm;
L_else:
    goto L_merge;
L_merge:
    _t16 = strcmp_lit(_t1, "pub");
    if (_t16) goto L_then; else goto L_else;
L_then:
    return TokenKind_Pub;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t17 = strcmp_lit(_t1, "else");
    if (_t17) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t18 = _t2 == 5LL;
    if (_t18) goto L_then; else goto L_else;
L_then:
    return TokenKind_Else;
L_else:
    goto L_merge;
L_merge:
    _t19 = strcmp_lit(_t1, "loop");
    if (_t19) goto L_then; else goto L_else;
L_then:
    return TokenKind_Loop;
L_else:
    goto L_merge;
L_merge:
    _t20 = strcmp_lit(_t1, "true");
    if (_t20) goto L_then; else goto L_else;
L_then:
    return TokenKind_True;
L_else:
    goto L_merge;
L_merge:
    _t21 = strcmp_lit(_t1, "enum");
    if (_t21) goto L_then; else goto L_else;
L_then:
    return TokenKind_Enum;
L_else:
    goto L_merge;
L_merge:
    _t22 = strcmp_lit(_t1, "impl");
    if (_t22) goto L_then; else goto L_else;
L_then:
    return TokenKind_Impl;
L_else:
    goto L_merge;
L_merge:
    _t23 = strcmp_lit(_t1, "type");
    if (_t23) goto L_then; else goto L_else;
L_then:
    return TokenKind_Type;
L_else:
    goto L_merge;
L_merge:
    _t24 = strcmp_lit(_t1, "pure");
    if (_t24) goto L_then; else goto L_else;
L_then:
    return TokenKind_Pure;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t25 = strcmp_lit(_t1, "while");
    if (_t25) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t26 = _t2 == 6LL;
    if (_t26) goto L_then; else goto L_else;
L_then:
    return TokenKind_While;
L_else:
    goto L_merge;
L_merge:
    _t27 = strcmp_lit(_t1, "match");
    if (_t27) goto L_then; else goto L_else;
L_then:
    return TokenKind_Match;
L_else:
    goto L_merge;
L_merge:
    _t28 = strcmp_lit(_t1, "break");
    if (_t28) goto L_then; else goto L_else;
L_then:
    return TokenKind_Break;
L_else:
    goto L_merge;
L_merge:
    _t29 = strcmp_lit(_t1, "false");
    if (_t29) goto L_then; else goto L_else;
L_then:
    return TokenKind_False;
L_else:
    goto L_merge;
L_merge:
    _t30 = strcmp_lit(_t1, "const");
    if (_t30) goto L_then; else goto L_else;
L_then:
    return TokenKind_Const;
L_else:
    goto L_merge;
L_merge:
    _t31 = strcmp_lit(_t1, "trait");
    if (_t31) goto L_then; else goto L_else;
L_then:
    return TokenKind_Trait;
L_else:
    goto L_merge;
L_merge:
    _t32 = strcmp_lit(_t1, "where");
    if (_t32) goto L_then; else goto L_else;
L_then:
    return TokenKind_Where;
L_else:
    goto L_merge;
L_merge:
    _t33 = strcmp_lit(_t1, "union");
    if (_t33) goto L_then; else goto L_else;
L_then:
    return TokenKind_Union;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t34 = strcmp_lit(_t1, "return");
    if (_t34) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t35 = _t2 == 7LL;
    if (_t35) goto L_then; else goto L_else;
L_then:
    return TokenKind_Return;
L_else:
    goto L_merge;
L_merge:
    _t36 = strcmp_lit(_t1, "struct");
    if (_t36) goto L_then; else goto L_else;
L_then:
    return TokenKind_Struct;
L_else:
    goto L_merge;
L_merge:
    _t37 = strcmp_lit(_t1, "unsafe");
    if (_t37) goto L_then; else goto L_else;
L_then:
    return TokenKind_Unsafe;
L_else:
    goto L_merge;
L_merge:
    _t38 = strcmp_lit(_t1, "extern");
    if (_t38) goto L_then; else goto L_else;
L_then:
    return TokenKind_Extern;
L_else:
    goto L_merge;
L_merge:
    _t39 = strcmp_lit(_t1, "static");
    if (_t39) goto L_then; else goto L_else;
L_then:
    return TokenKind_Static;
L_else:
    goto L_merge;
L_merge:
    _t40 = strcmp_lit(_t1, "effect");
    if (_t40) goto L_then; else goto L_else;
L_then:
    return TokenKind_Effect;
L_else:
    goto L_merge;
L_merge:
    _t41 = strcmp_lit(_t1, "shared");
    if (_t41) goto L_then; else goto L_else;
L_then:
    return TokenKind_Shared;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t42 = strcmp_lit(_t1, "ensures");
    if (_t42) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t43 = _t2 == 8LL;
    if (_t43) goto L_then; else goto L_else;
L_then:
    return TokenKind_Ensures;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t44 = strcmp_lit(_t1, "continue");
    if (_t44) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t45 = _t2 == 9LL;
    if (_t45) goto L_then; else goto L_else;
L_then:
    return TokenKind_Continue;
L_else:
    goto L_merge;
L_merge:
    _t46 = strcmp_lit(_t1, "requires");
    if (_t46) goto L_then; else goto L_else;
L_then:
    return TokenKind_Requires;
L_else:
    goto L_merge;
L_merge:
    _t47 = strcmp_lit(_t1, "volatile");
    if (_t47) goto L_then; else goto L_else;
L_then:
    return TokenKind_Volatile;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t48 = strcmp_lit(_t1, "interface");
    if (_t48) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    String_clone(_t0);
    TokenKind_Ident(((void)0));
    return _t49;
L_then:
    return TokenKind_Interface;
L_else:
    goto L_merge;
L_merge:
    _t50 = strcmp_lit(_t1, "invariant");
    if (_t50) goto L_then; else goto L_else;
L_then:
    return TokenKind_Invariant;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
}

