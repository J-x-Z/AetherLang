// AetherLang Bootstrap Compiler
// Self-hosted compiler - compiles AetherLang source to native code

extern "C" {
    fn puts(s: *u8) -> i32;
    fn printf(fmt: *u8, ...) -> i32;
    fn malloc(size: u64) -> *u8;
    fn free(ptr: *void);
    fn fopen(path: *u8, mode: *u8) -> *void;
    fn fclose(f: *void) -> i32;
    fn fread(buf: *u8, size: u64, count: u64, f: *void) -> u64;
    fn fseek(f: *void, offset: i64, whence: i32) -> i32;
    fn ftell(f: *void) -> i64;
    fn strlen(s: *u8) -> u64;
    fn strcmp(s1: *u8, s2: *u8) -> i32;
}

// Import compiler modules
use lexer::Lexer;
use parser::Parser;
use ir_gen::{IRGenerator, IRModule, IRType};
use ir_to_llvm::IRToLLVM;

// ==================== File I/O ====================

fn read_file(path: *u8) -> *u8 {
    let f: *void = fopen(path, "rb\0" as *u8);
    if f == (0 as *void) {
        puts("Error: Cannot open file\0" as *u8);
        return 0 as *u8;
    }

    // Get file size
    fseek(f, 0, 2);  // SEEK_END
    let size: i64 = ftell(f);
    fseek(f, 0, 0);  // SEEK_SET

    // Allocate buffer
    let buf: *u8 = malloc((size + 1) as u64);
    if buf == (0 as *u8) {
        fclose(f);
        puts("Error: Out of memory\0" as *u8);
        return 0 as *u8;
    }

    // Read file
    fread(buf, 1, size as u64, f);
    *(buf + (size as u64)) = 0;  // Null terminate
    fclose(f);

    return buf;
}

// ==================== Compiler Pipeline ====================

pub struct Compiler {
    pub input_path: *u8,
    pub output_path: *u8,
    pub emit_ir: bool,
    pub verbose: bool,
}

impl Compiler {
    pub fn new(input: *u8, output: *u8) -> Compiler {
        return Compiler {
            input_path: input,
            output_path: output,
            emit_ir: false,
            verbose: false,
        };
    }

    /// Run the full compilation pipeline
    pub fn compile(self: *Compiler) -> i32 {
        if (*self).verbose {
            puts("AetherLang Bootstrap Compiler v0.3.0\0" as *u8);
            puts("====================================\0" as *u8);
        }

        // Step 1: Read source file
        if (*self).verbose {
            puts("[1/5] Reading source file...\0" as *u8);
        }
        let source: *u8 = read_file((*self).input_path);
        if source == (0 as *u8) {
            return 1;
        }
        let src_len: u64 = strlen(source);

        // Step 2: Lexical analysis
        if (*self).verbose {
            puts("[2/5] Lexical analysis...\0" as *u8);
        }
        let mut lexer: Lexer = Lexer::new(source, src_len);
        // Tokenize (tokens are consumed by parser)

        // Step 3: Parsing
        if (*self).verbose {
            puts("[3/5] Parsing AST...\0" as *u8);
        }
        let mut parser: Parser = Parser::new(&lexer);
        let parse_ok: bool = parser.parse();
        if !parse_ok {
            puts("Error: Parse failed\0" as *u8);
            free(source as *void);
            return 1;
        }

        // Step 4: IR Generation
        if (*self).verbose {
            puts("[4/5] Generating IR...\0" as *u8);
        }
        let mut ir_gen: IRGenerator = IRGenerator::new((*self).input_path);

        // Generate IR from AST
        // For bootstrap, we generate a simple main function that returns 0
        let func_id: u64 = ir_gen.begin_function("main\0" as *u8, IRType::I32);

        // Generate code from parsed AST
        let ast_ptr: *void = parser.get_ast();
        if ast_ptr != (0 as *void) {
            // Would call: ir_gen.generate_from_ast(ast_ptr);
            // For now, just generate return 0
        }

        ir_gen.end_function();

        // Get IR module
        let ir_module: *IRModule = ir_gen.get_module();

        // Step 5: LLVM Code Generation
        if (*self).verbose {
            puts("[5/5] Generating native code...\0" as *u8);
        }

        // Get target triple
        let target: *u8 = get_default_target();

        // Create LLVM converter
        let mut llvm: IRToLLVM = IRToLLVM::new((*self).input_path, target);

        // Convert IR to LLVM
        llvm.convert_module(ir_module);

        // Print IR if requested
        if (*self).emit_ir {
            puts("\n--- Generated LLVM IR ---\0" as *u8);
            llvm.print_ir();
        }

        // Emit object file
        let emit_ok: bool = llvm.emit_object_file((*self).output_path);

        // Cleanup
        llvm.dispose(&llvm);
        free(source as *void);

        if (*self).verbose {
            if emit_ok {
                puts("\nCompilation successful!\0" as *u8);
            } else {
                puts("\nCompilation failed!\0" as *u8);
            }
        }

        if emit_ok {
            return 0;
        } else {
            return 1;
        }
    }
}

// ==================== Target Detection ====================

fn get_default_target() -> *u8 {
    // Default to Linux x86_64
    // TODO: Call LLVMGetDefaultTargetTriple() for actual detection
    return "x86_64-unknown-linux-gnu\0" as *u8;
}

// ==================== Command Line Parsing ====================

fn print_help() {
    puts("AetherLang Bootstrap Compiler\0" as *u8);
    puts("\0" as *u8);
    puts("Usage: aethc-bootstrap [OPTIONS] <input.aeth>\0" as *u8);
    puts("\0" as *u8);
    puts("Options:\0" as *u8);
    puts("  -o <file>     Output file name\0" as *u8);
    puts("  --emit-ir     Print LLVM IR\0" as *u8);
    puts("  -v, --verbose Verbose output\0" as *u8);
    puts("  -h, --help    Show this help\0" as *u8);
    puts("  --version     Show version\0" as *u8);
}

fn print_version() {
    puts("AetherLang Bootstrap Compiler v0.3.0\0" as *u8);
    puts("Written in AetherLang (self-hosting)\0" as *u8);
}

// ==================== Main Entry Point ====================

fn main() -> i32 {
    // For testing without command line args, compile a test file
    puts("AetherLang Bootstrap Compiler v0.3.0\0" as *u8);
    puts("====================================\0" as *u8);

    // Default paths for testing
    let input: *u8 = "tests/hello.aeth\0" as *u8;
    let output: *u8 = "tests/hello.o\0" as *u8;

    // Create compiler
    let mut compiler: Compiler = Compiler::new(input, output);
    compiler.verbose = true;
    compiler.emit_ir = true;

    // Run compilation
    let result: i32 = compiler.compile(&compiler);

    if result == 0 {
        puts("\nTo create executable:\0" as *u8);
        puts("  cc -o tests/hello tests/hello.o\0" as *u8);
        puts("  ./tests/hello\0" as *u8);
    }

    return result;
}
