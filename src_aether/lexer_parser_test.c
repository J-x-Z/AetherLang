/* Generated by AetherLang C Backend */
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <immintrin.h>  /* SSE/AVX */

/* AetherLang Runtime */
static void aether_print(const char* s) { printf("%s", s); }
static void aether_println(const char* s) { printf("%s\n", s); }
static void aether_print_i64(int64_t n) { printf("%lld", (long long)n); }
static void aether_println_i64(int64_t n) { printf("%lld\n", (long long)n); }
static void aether_assert(bool c) { if(!c) { fprintf(stderr, "Assertion failed\n"); exit(1); } }

/* Struct Definitions */
struct Token {
    struct TokenKind* kind;
    uint64_t start;
    uint64_t len;
    int64_t int_value;
};

struct Lexer {
    uint8_t* source;
    uint64_t len;
    uint64_t pos;
};

void Token_new(struct Token*, struct TokenKind*, uint64_t, uint64_t);
void Token_int(struct Token*, uint64_t, uint64_t, int64_t);
void Lexer_new(struct Lexer*, uint8_t*, uint64_t);
uint8_t Lexer_peek(struct Lexer*);
uint8_t Lexer_advance(struct Lexer*);
void Lexer_skip_whitespace(struct Lexer*);
bool Lexer_is_digit(uint8_t);
bool Lexer_is_alpha(uint8_t);
void Lexer_next_token(struct Token*, struct Lexer*);
int32_t main(void);

void Token_new(struct Token* _arg0, struct TokenKind* _arg1, uint64_t _arg2, uint64_t _arg3) {
    int64_t* _t7;
    struct Token* _t0;
    struct TokenKind* _t1;
    struct TokenKind** _t4;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t* _t5;
    uint64_t* _t6;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = &_t0->kind;
    *_t4 = _t1;
    _t5 = &_t0->start;
    *_t5 = _t2;
    _t6 = &_t0->len;
    *_t6 = _t3;
    _t7 = &_t0->int_value;
    *_t7 = 0LL;
    return;
}

void Token_int(struct Token* _arg0, uint64_t _arg1, uint64_t _arg2, int64_t _arg3) {
    int64_t _t3;
    int64_t* _t7;
    struct Token* _t0;
    struct TokenKind** _t4;
    uint64_t _t1;
    uint64_t _t2;
    uint64_t* _t5;
    uint64_t* _t6;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = &_t0->kind;
    *_t4 = TokenKind_IntLit;
    _t5 = &_t0->start;
    *_t5 = _t1;
    _t6 = &_t0->len;
    *_t6 = _t2;
    _t7 = &_t0->int_value;
    *_t7 = _t3;
    return;
}

void Lexer_new(struct Lexer* _arg0, uint8_t* _arg1, uint64_t _arg2) {
    struct Lexer* _t0;
    uint64_t _t2;
    uint64_t* _t4;
    uint64_t* _t5;
    uint8_t* _t1;
    uint8_t** _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t0->source;
    *_t3 = _t1;
    _t4 = &_t0->len;
    *_t4 = _t2;
    _t5 = &_t0->pos;
    *_t5 = 0LL;
    return;
}

uint8_t Lexer_peek(struct Lexer* _arg0) {
    int64_t _t12;
    int64_t _t5;
    struct Lexer* _t0;
    uint64_t _t11;
    uint64_t _t2;
    uint64_t _t4;
    uint64_t _t9;
    uint64_t* _t10;
    uint64_t* _t1;
    uint64_t* _t3;
    uint8_t _t15;
    uint8_t _t6;
    uint8_t* _t13;
    uint8_t* _t14;
    uint8_t* _t8;
    uint8_t** _t7;
    
    _t0 = _arg0;
    _t1 = &_t0->pos;
    _t2 = *_t1;
    _t3 = &_t0->len;
    _t4 = *_t3;
    _t5 = _t2 >= _t4;
    if (_t5) goto L_then; else goto L_else;
L_then:
    _t6 = (uint8_t)0LL;
    return _t6;
L_else:
    goto L_merge;
L_merge:
    _t7 = &_t0->source;
    _t8 = *_t7;
    _t9 = (uint64_t)_t8;
    _t10 = &_t0->pos;
    _t11 = *_t10;
    _t12 = _t9 + _t11;
    _t13 = (uint8_t*)_t12;
    _t14 = _t13;
    _t15 = *_t14;
    return _t15;
}

uint8_t Lexer_advance(struct Lexer* _arg0) {
    int64_t _t8;
    struct Lexer* _t0;
    uint64_t _t4;
    uint64_t _t6;
    uint64_t _t7;
    uint64_t* _t3;
    uint64_t* _t5;
    uint64_t* _t9;
    uint8_t _t1;
    uint8_t _t2;
    
    _t0 = _arg0;
    _t1 = Lexer_peek(_t0);
    _t2 = _t1;
    _t3 = &_t0->pos;
    _t4 = *_t3;
    _t5 = &_t0->pos;
    _t6 = *_t5;
    _t7 = (uint64_t)1LL;
    _t8 = _t6 + _t7;
    _t9 = &_t0->pos;
    *_t9 = _t8;
    return _t2;
}

void Lexer_skip_whitespace(struct Lexer* _arg0) {
    struct Lexer* _t0;
    
    _t0 = _arg0;
    return;
}

bool Lexer_is_digit(uint8_t _arg0) {
    int64_t _t2;
    int64_t _t4;
    int64_t _t5;
    uint8_t _t0;
    uint8_t _t1;
    uint8_t _t3;
    
    _t0 = _arg0;
    _t1 = (uint8_t)48LL;
    _t2 = _t0 >= _t1;
    _t3 = (uint8_t)57LL;
    _t4 = _t0 <= _t3;
    _t5 = _t2 && _t4;
    return _t5;
}

bool Lexer_is_alpha(uint8_t _arg0) {
    int64_t _t10;
    int64_t _t11;
    int64_t _t13;
    int64_t _t14;
    int64_t _t2;
    int64_t _t4;
    int64_t _t5;
    int64_t _t7;
    int64_t _t9;
    uint8_t _t0;
    uint8_t _t12;
    uint8_t _t1;
    uint8_t _t3;
    uint8_t _t6;
    uint8_t _t8;
    
    _t0 = _arg0;
    _t1 = (uint8_t)65LL;
    _t2 = _t0 >= _t1;
    _t3 = (uint8_t)90LL;
    _t4 = _t0 <= _t3;
    _t5 = _t2 && _t4;
    _t6 = (uint8_t)97LL;
    _t7 = _t0 >= _t6;
    _t8 = (uint8_t)122LL;
    _t9 = _t0 <= _t8;
    _t10 = _t7 && _t9;
    _t11 = _t5 || _t10;
    _t12 = (uint8_t)95LL;
    _t13 = _t0 == _t12;
    _t14 = _t11 || _t13;
    return _t14;
}

void Lexer_next_token(struct Token* _arg0, struct Lexer* _arg1) {
    bool _t49;
    bool _t62;
    int64_t _t103;
    int64_t _t109;
    int64_t _t114;
    int64_t _t116;
    int64_t _t117;
    int64_t _t119;
    int64_t _t120;
    int64_t _t122;
    int64_t _t127;
    int64_t _t133;
    int64_t _t17;
    int64_t _t21;
    int64_t _t25;
    int64_t _t29;
    int64_t _t33;
    int64_t _t37;
    int64_t _t41;
    int64_t _t45;
    int64_t _t48;
    int64_t _t54;
    int64_t _t55;
    int64_t _t56;
    int64_t _t59;
    int64_t _t65;
    int64_t _t66;
    int64_t _t68;
    int64_t _t6;
    int64_t _t74;
    int64_t _t81;
    int64_t _t86;
    int64_t _t88;
    int64_t _t89;
    int64_t _t91;
    int64_t _t96;
    struct Lexer* _t1;
    struct Token* _t0;
    struct Token* _t10;
    struct Token* _t123;
    struct Token* _t134;
    struct Token* _t135;
    struct Token* _t19;
    struct Token* _t23;
    struct Token* _t27;
    struct Token* _t31;
    struct Token* _t35;
    struct Token* _t39;
    struct Token* _t43;
    struct Token* _t52;
    struct Token* _t61;
    struct Token* _t70;
    struct Token* _t92;
    uint64_t _t101;
    uint64_t _t102;
    uint64_t _t107;
    uint64_t _t108;
    uint64_t _t121;
    uint64_t _t126;
    uint64_t _t12;
    uint64_t _t13;
    uint64_t _t18;
    uint64_t _t22;
    uint64_t _t26;
    uint64_t _t30;
    uint64_t _t34;
    uint64_t _t38;
    uint64_t _t3;
    uint64_t _t42;
    uint64_t _t51;
    uint64_t _t58;
    uint64_t _t5;
    uint64_t _t60;
    uint64_t _t64;
    uint64_t _t67;
    uint64_t _t69;
    uint64_t _t73;
    uint64_t _t79;
    uint64_t _t80;
    uint64_t _t8;
    uint64_t _t90;
    uint64_t _t95;
    uint64_t _t9;
    uint64_t* _t11;
    uint64_t* _t2;
    uint64_t* _t4;
    uint64_t* _t57;
    uint64_t* _t63;
    uint64_t* _t7;
    uint8_t _t100;
    uint8_t _t105;
    uint8_t _t106;
    uint8_t _t111;
    uint8_t _t112;
    uint8_t _t113;
    uint8_t _t115;
    uint8_t _t118;
    uint8_t _t130;
    uint8_t _t131;
    uint8_t _t132;
    uint8_t _t14;
    uint8_t _t15;
    uint8_t _t16;
    uint8_t _t20;
    uint8_t _t24;
    uint8_t _t28;
    uint8_t _t32;
    uint8_t _t36;
    uint8_t _t40;
    uint8_t _t44;
    uint8_t _t46;
    uint8_t _t47;
    uint8_t _t50;
    uint8_t _t53;
    uint8_t _t77;
    uint8_t _t78;
    uint8_t _t83;
    uint8_t _t84;
    uint8_t _t85;
    uint8_t _t87;
    uint8_t _t99;
    uint8_t* _t104;
    uint8_t* _t110;
    uint8_t* _t125;
    uint8_t* _t128;
    uint8_t* _t129;
    uint8_t* _t72;
    uint8_t* _t75;
    uint8_t* _t76;
    uint8_t* _t82;
    uint8_t* _t94;
    uint8_t* _t97;
    uint8_t* _t98;
    uint8_t** _t124;
    uint8_t** _t71;
    uint8_t** _t93;
    
    _t0 = _arg0;
    _t1 = _arg1;
    Lexer_skip_whitespace(_t1);
    _t2 = &_t1->pos;
    _t3 = *_t2;
    _t4 = &_t1->len;
    _t5 = *_t4;
    _t6 = _t3 >= _t5;
    if (_t6) goto L_then; else goto L_else;
L_then:
    _t7 = &_t1->pos;
    _t8 = *_t7;
    _t9 = (uint64_t)0LL;
    struct Token _alloca__t10;
    _t10 = &_alloca__t10;
    Token_new(_t10, TokenKind_Eof, _t8, _t9);
    return;
L_else:
    goto L_merge;
L_merge:
    _t11 = &_t1->pos;
    _t12 = *_t11;
    _t13 = _t12;
    _t14 = Lexer_advance(_t1);
    _t15 = _t14;
    _t16 = (uint8_t)40LL;
    _t17 = _t15 == _t16;
    if (_t17) goto L_then; else goto L_else;
L_then:
    _t18 = (uint64_t)1LL;
    struct Token _alloca__t19;
    _t19 = &_alloca__t19;
    Token_new(_t19, TokenKind_LParen, _t13, _t18);
    return;
L_else:
    goto L_merge;
L_merge:
    _t20 = (uint8_t)41LL;
    _t21 = _t15 == _t20;
    if (_t21) goto L_then; else goto L_else;
L_then:
    _t22 = (uint64_t)1LL;
    struct Token _alloca__t23;
    _t23 = &_alloca__t23;
    Token_new(_t23, TokenKind_RParen, _t13, _t22);
    return;
L_else:
    goto L_merge;
L_merge:
    _t24 = (uint8_t)123LL;
    _t25 = _t15 == _t24;
    if (_t25) goto L_then; else goto L_else;
L_then:
    _t26 = (uint64_t)1LL;
    struct Token _alloca__t27;
    _t27 = &_alloca__t27;
    Token_new(_t27, TokenKind_LBrace, _t13, _t26);
    return;
L_else:
    goto L_merge;
L_merge:
    _t28 = (uint8_t)125LL;
    _t29 = _t15 == _t28;
    if (_t29) goto L_then; else goto L_else;
L_then:
    _t30 = (uint64_t)1LL;
    struct Token _alloca__t31;
    _t31 = &_alloca__t31;
    Token_new(_t31, TokenKind_RBrace, _t13, _t30);
    return;
L_else:
    goto L_merge;
L_merge:
    _t32 = (uint8_t)58LL;
    _t33 = _t15 == _t32;
    if (_t33) goto L_then; else goto L_else;
L_then:
    _t34 = (uint64_t)1LL;
    struct Token _alloca__t35;
    _t35 = &_alloca__t35;
    Token_new(_t35, TokenKind_Colon, _t13, _t34);
    return;
L_else:
    goto L_merge;
L_merge:
    _t36 = (uint8_t)59LL;
    _t37 = _t15 == _t36;
    if (_t37) goto L_then; else goto L_else;
L_then:
    _t38 = (uint64_t)1LL;
    struct Token _alloca__t39;
    _t39 = &_alloca__t39;
    Token_new(_t39, TokenKind_Semicolon, _t13, _t38);
    return;
L_else:
    goto L_merge;
L_merge:
    _t40 = (uint8_t)43LL;
    _t41 = _t15 == _t40;
    if (_t41) goto L_then; else goto L_else;
L_then:
    _t42 = (uint64_t)1LL;
    struct Token _alloca__t43;
    _t43 = &_alloca__t43;
    Token_new(_t43, TokenKind_Plus, _t13, _t42);
    return;
L_else:
    goto L_merge;
L_merge:
    _t44 = (uint8_t)45LL;
    _t45 = _t15 == _t44;
    if (_t45) goto L_then; else goto L_else;
L_then:
    _t46 = Lexer_peek(_t1);
    _t47 = (uint8_t)62LL;
    _t48 = _t46 == _t47;
    if (_t48) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t49 = Lexer_is_digit(_t15);
    if (_t49) goto L_then; else goto L_else;
L_then:
    _t50 = Lexer_advance(_t1);
    _t51 = (uint64_t)2LL;
    struct Token _alloca__t52;
    _t52 = &_alloca__t52;
    Token_new(_t52, TokenKind_Arrow, _t13, _t51);
    return;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t53 = (uint8_t)48LL;
    _t54 = _t15 - _t53;
    _t55 = (int64_t)_t54;
    _t56 = _t55;
    _t57 = &_t1->pos;
    _t58 = *_t57;
    _t59 = _t58 - _t13;
    _t60 = (uint64_t)_t56;
    struct Token _alloca__t61;
    _t61 = &_alloca__t61;
    Token_int(_t61, _t13, _t59, _t60);
    return;
L_else:
    goto L_merge;
L_merge:
    _t62 = Lexer_is_alpha(_t15);
    if (_t62) goto L_then; else goto L_else;
L_then:
    _t63 = &_t1->pos;
    _t64 = *_t63;
    _t65 = _t64 - _t13;
    _t66 = _t65;
    _t67 = (uint64_t)2LL;
    _t68 = _t66 == _t67;
    if (_t68) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t69 = (uint64_t)0LL;
    struct Token _alloca__t70;
    _t70 = &_alloca__t70;
    Token_new(_t70, TokenKind_Eof, _t13, _t69);
    return;
L_then:
    _t71 = &_t1->source;
    _t72 = *_t71;
    _t73 = (uint64_t)_t72;
    _t74 = _t73 + _t13;
    _t75 = (uint8_t*)_t74;
    _t76 = _t75;
    _t77 = *_t76;
    _t78 = _t77;
    _t79 = (uint64_t)_t76;
    _t80 = (uint64_t)1LL;
    _t81 = _t79 + _t80;
    _t82 = (uint8_t*)_t81;
    _t83 = *_t82;
    _t84 = _t83;
    _t85 = (uint8_t)102LL;
    _t86 = _t78 == _t85;
    _t87 = (uint8_t)110LL;
    _t88 = _t84 == _t87;
    _t89 = _t86 && _t88;
    if (_t89) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t90 = (uint64_t)3LL;
    _t91 = _t66 == _t90;
    if (_t91) goto L_then; else goto L_else;
L_then:
    struct Token _alloca__t92;
    _t92 = &_alloca__t92;
    Token_new(_t92, TokenKind_Fn, _t13, _t66);
    return;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t93 = &_t1->source;
    _t94 = *_t93;
    _t95 = (uint64_t)_t94;
    _t96 = _t95 + _t13;
    _t97 = (uint8_t*)_t96;
    _t98 = _t97;
    _t99 = *_t98;
    _t100 = _t99;
    _t101 = (uint64_t)_t98;
    _t102 = (uint64_t)1LL;
    _t103 = _t101 + _t102;
    _t104 = (uint8_t*)_t103;
    _t105 = *_t104;
    _t106 = _t105;
    _t107 = (uint64_t)_t98;
    _t108 = (uint64_t)2LL;
    _t109 = _t107 + _t108;
    _t110 = (uint8_t*)_t109;
    _t111 = *_t110;
    _t112 = _t111;
    _t113 = (uint8_t)108LL;
    _t114 = _t100 == _t113;
    _t115 = (uint8_t)101LL;
    _t116 = _t106 == _t115;
    _t117 = _t114 && _t116;
    _t118 = (uint8_t)116LL;
    _t119 = _t112 == _t118;
    _t120 = _t117 && _t119;
    if (_t120) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t121 = (uint64_t)6LL;
    _t122 = _t66 == _t121;
    if (_t122) goto L_then; else goto L_else;
L_then:
    struct Token _alloca__t123;
    _t123 = &_alloca__t123;
    Token_new(_t123, TokenKind_Let, _t13, _t66);
    return;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t124 = &_t1->source;
    _t125 = *_t124;
    _t126 = (uint64_t)_t125;
    _t127 = _t126 + _t13;
    _t128 = (uint8_t*)_t127;
    _t129 = _t128;
    _t130 = *_t129;
    _t131 = _t130;
    _t132 = (uint8_t)114LL;
    _t133 = _t131 == _t132;
    if (_t133) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    struct Token _alloca__t134;
    _t134 = &_alloca__t134;
    Token_new(_t134, TokenKind_Ident, _t13, _t66);
    return;
L_then:
    struct Token _alloca__t135;
    _t135 = &_alloca__t135;
    Token_new(_t135, TokenKind_Return, _t13, _t66);
    return;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
}

int32_t main(void) {
    int32_t _t10;
    int32_t _t13;
    int32_t _t20;
    int32_t _t23;
    int32_t _t47;
    int32_t _t50;
    int32_t _t55;
    int32_t _t58;
    int32_t _t63;
    int32_t _t66;
    int32_t _t7;
    int32_t _t98;
    int64_t _t0;
    int64_t _t11;
    int64_t _t12;
    int64_t _t14;
    int64_t _t15;
    int64_t _t1;
    int64_t _t21;
    int64_t _t22;
    int64_t _t24;
    int64_t _t25;
    int64_t _t44;
    int64_t _t48;
    int64_t _t49;
    int64_t _t4;
    int64_t _t51;
    int64_t _t52;
    int64_t _t56;
    int64_t _t57;
    int64_t _t59;
    int64_t _t60;
    int64_t _t64;
    int64_t _t65;
    int64_t _t67;
    int64_t _t68;
    int64_t _t71;
    int64_t _t72;
    int64_t _t75;
    int64_t _t76;
    int64_t _t79;
    int64_t _t80;
    int64_t _t83;
    int64_t _t84;
    int64_t _t87;
    int64_t _t88;
    int64_t _t8;
    int64_t _t91;
    int64_t _t92;
    int64_t _t95;
    int64_t _t96;
    int64_t _t97;
    int64_t _t9;
    struct Lexer* _t16;
    struct Lexer* _t17;
    struct Token* _t26;
    struct Token* _t27;
    struct Token* _t28;
    struct Token* _t29;
    struct Token* _t30;
    struct Token* _t31;
    struct Token* _t32;
    struct Token* _t33;
    struct Token* _t34;
    struct Token* _t35;
    struct Token* _t36;
    struct Token* _t37;
    struct Token* _t38;
    struct Token* _t39;
    struct Token* _t40;
    struct Token* _t41;
    struct Token* _t42;
    struct Token* _t43;
    struct TokenKind* _t70;
    struct TokenKind* _t74;
    struct TokenKind* _t78;
    struct TokenKind* _t82;
    struct TokenKind* _t86;
    struct TokenKind* _t90;
    struct TokenKind* _t94;
    struct TokenKind** _t69;
    struct TokenKind** _t73;
    struct TokenKind** _t77;
    struct TokenKind** _t81;
    struct TokenKind** _t85;
    struct TokenKind** _t89;
    struct TokenKind** _t93;
    uint64_t _t19;
    uint64_t _t46;
    uint64_t _t54;
    uint64_t _t62;
    uint64_t* _t18;
    uint64_t* _t45;
    uint64_t* _t53;
    uint64_t* _t61;
    uint8_t _t5;
    uint8_t _t6;
    uint8_t* _t2;
    uint8_t* _t3;
    
    puts("=== Lexer Integration Test ===");
    puts("Source: fn main() { return 42; }");
    _t2 = (uint8_t*)"fn main() { return 42; }";
    _t3 = _t2;
    _t4 = 24LL;
    _t5 = *_t3;
    _t6 = _t5;
    _t7 = (int32_t)_t6;
    putchar(_t7);
    puts(" = first char of source (should be \'f\')");
    _t10 = (int32_t)_t4;
    _t11 = (int64_t)_t10;
    _t12 = 48LL + _t11;
    _t13 = (int32_t)_t12;
    putchar(_t13);
    puts(" = len");
    struct Lexer _alloca__t16;
    _t16 = &_alloca__t16;
    Lexer_new(_t16, _t3, _t4);
    _t17 = _t16;
    _t18 = &_t17->len;
    _t19 = *_t18;
    _t20 = (int32_t)_t19;
    _t21 = (int64_t)_t20;
    _t22 = 48LL + _t21;
    _t23 = (int32_t)_t22;
    putchar(_t23);
    puts(" = lexer.len");
    struct Token _alloca__t26;
    _t26 = &_alloca__t26;
    Lexer_next_token(_t26, _t17);
    _t27 = _t26;
    struct Token _alloca__t28;
    _t28 = &_alloca__t28;
    Lexer_next_token(_t28, _t17);
    _t29 = _t28;
    struct Token _alloca__t30;
    _t30 = &_alloca__t30;
    Lexer_next_token(_t30, _t17);
    _t31 = _t30;
    struct Token _alloca__t32;
    _t32 = &_alloca__t32;
    Lexer_next_token(_t32, _t17);
    _t33 = _t32;
    struct Token _alloca__t34;
    _t34 = &_alloca__t34;
    Lexer_next_token(_t34, _t17);
    _t35 = _t34;
    struct Token _alloca__t36;
    _t36 = &_alloca__t36;
    Lexer_next_token(_t36, _t17);
    _t37 = _t36;
    struct Token _alloca__t38;
    _t38 = &_alloca__t38;
    Lexer_next_token(_t38, _t17);
    _t39 = _t38;
    struct Token _alloca__t40;
    _t40 = &_alloca__t40;
    Lexer_next_token(_t40, _t17);
    _t41 = _t40;
    struct Token _alloca__t42;
    _t42 = &_alloca__t42;
    Lexer_next_token(_t42, _t17);
    _t43 = _t42;
    puts("Tokens parsed:");
    _t45 = &_t17->pos;
    _t46 = *_t45;
    _t47 = (int32_t)_t46;
    _t48 = (int64_t)_t47;
    _t49 = 48LL + _t48;
    _t50 = (int32_t)_t49;
    putchar(_t50);
    puts(" = final lexer.pos");
    _t53 = &_t27->start;
    _t54 = *_t53;
    _t55 = (int32_t)_t54;
    _t56 = (int64_t)_t55;
    _t57 = 48LL + _t56;
    _t58 = (int32_t)_t57;
    putchar(_t58);
    puts(" = tok0.start");
    _t61 = &_t29->start;
    _t62 = *_t61;
    _t63 = (int32_t)_t62;
    _t64 = (int64_t)_t63;
    _t65 = 48LL + _t64;
    _t66 = (int32_t)_t65;
    putchar(_t66);
    puts(" = tok1.start");
    _t69 = &_t31->kind;
    _t70 = *_t69;
    _t71 = _t70 == TokenKind_LParen;
    if (_t71) goto L_then; else goto L_else;
L_then:
    puts("  2: LParen");
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    _t73 = &_t33->kind;
    _t74 = *_t73;
    _t75 = _t74 == TokenKind_RParen;
    if (_t75) goto L_then; else goto L_else;
L_then:
    puts("  3: RParen");
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    _t77 = &_t35->kind;
    _t78 = *_t77;
    _t79 = _t78 == TokenKind_LBrace;
    if (_t79) goto L_then; else goto L_else;
L_then:
    puts("  4: LBrace");
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    _t81 = &_t37->kind;
    _t82 = *_t81;
    _t83 = _t82 == TokenKind_Return;
    if (_t83) goto L_then; else goto L_else;
L_then:
    puts("  5: Return");
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    _t85 = &_t39->kind;
    _t86 = *_t85;
    _t87 = _t86 == TokenKind_IntLit;
    if (_t87) goto L_then; else goto L_else;
L_then:
    puts("  6: IntLit (42)");
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    _t89 = &_t41->kind;
    _t90 = *_t89;
    _t91 = _t90 == TokenKind_Semicolon;
    if (_t91) goto L_then; else goto L_else;
L_then:
    puts("  7: Semicolon");
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    _t93 = &_t43->kind;
    _t94 = *_t93;
    _t95 = _t94 == TokenKind_RBrace;
    if (_t95) goto L_then; else goto L_else;
L_then:
    puts("  8: RBrace");
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    puts("=== Token Flow SUCCESS! ===");
    _t98 = (int32_t)0LL;
    return _t98;
}

