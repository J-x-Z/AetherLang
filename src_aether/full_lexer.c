/* Generated by AetherLang C Backend */
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <immintrin.h>  /* SSE/AVX */

/* AetherLang Runtime */
static void aether_print(const char* s) { printf("%s", s); }
static void aether_println(const char* s) { printf("%s\n", s); }
static void aether_print_i64(int64_t n) { printf("%lld", (long long)n); }
static void aether_println_i64(int64_t n) { printf("%lld\n", (long long)n); }
static void aether_assert(bool c) { if(!c) { fprintf(stderr, "Assertion failed\n"); exit(1); } }

/* Struct Definitions */
struct String {
    uint8_t* data;
    uint64_t len;
    uint64_t capacity;
};

struct Span {
    uint64_t file_id;
    uint64_t start;
    uint64_t end;
};

struct Token {
    struct TokenKind* kind;
    struct Span* span;
};

struct VecToken {
    struct Token** data;
    uint64_t len;
    uint64_t capacity;
};

struct Lexer {
    uint8_t* source;
    uint64_t source_len;
    uint64_t pos;
    uint64_t start;
    uint64_t file_id;
};

void my_println(uint8_t*);
void my_assert(bool);
void String_new(struct String*);
void String_from_cstr(struct String*, uint8_t*);
uint64_t String_len(struct String*);
bool String_is_empty(struct String*);
uint8_t* String_as_ptr(struct String*);
void String_ensure_capacity(struct String*, uint64_t);
void String_push(struct String*, uint8_t);
void String_push_str(struct String*, struct String*);
void String_clear(struct String*);
uint8_t String_char_at(struct String*, uint64_t);
void String_print(struct String*);
void String_clone(struct String*, struct String*);
void String_drop(struct String*);
void Span_new(struct Span*, uint64_t, uint64_t, uint64_t);
void Span_empty(struct Span*, uint64_t, uint64_t);
void Span_merge(struct Span*, struct Span*, struct Span*);
void Token_new(struct Token*, struct TokenKind*, struct Span*);
void Token_eof(struct Token*, struct Span*);
bool strcmp_lit(uint8_t*, uint8_t*);
struct TokenKind* keyword_from_str(struct String*);
void VecToken_new(struct VecToken*);
void VecToken_with_capacity(struct VecToken*, uint64_t);
uint64_t VecToken_len(struct VecToken*);
bool VecToken_is_empty(struct VecToken*);
uint64_t VecToken_capacity(struct VecToken*);
void VecToken_ensure_capacity(struct VecToken*, uint64_t);
void VecToken_push(struct VecToken*, struct Token*);
void VecToken_pop(struct Token*, struct VecToken*);
void VecToken_get(struct Token*, struct VecToken*, uint64_t);
void VecToken_get_mut(struct Token*, struct VecToken*, uint64_t);
void VecToken_clear(struct VecToken*);
void VecToken_drop(struct VecToken*);
void Lexer_new(struct Lexer*, uint8_t*, uint64_t, uint64_t);
uint8_t Lexer_peek(struct Lexer*);
uint8_t Lexer_peek_next(struct Lexer*);
uint8_t Lexer_advance(struct Lexer*);
bool Lexer_is_at_end(struct Lexer*);
void Lexer_make_span(struct Span*, struct Lexer*);
void Lexer_make_token(struct Token*, struct Lexer*, struct TokenKind*);
bool Lexer_is_alpha(uint8_t);
bool Lexer_is_digit(uint8_t);
bool Lexer_is_alnum(uint8_t);
bool Lexer_is_whitespace(uint8_t);
void Lexer_skip_whitespace(struct Lexer*);
void Lexer_read_identifier(struct Token*, struct Lexer*);
void Lexer_read_number(struct Token*, struct Lexer*);
bool Lexer_is_hex_digit(uint8_t);
int64_t Lexer_parse_int(struct Lexer*);
int64_t Lexer_parse_hex(struct Lexer*);
double Lexer_parse_float(struct Lexer*);
void Lexer_read_string(struct Token*, struct Lexer*);
void Lexer_read_char(struct Token*, struct Lexer*);
void Lexer_match_operator(struct TokenKind*, struct Lexer*, uint8_t);
void Lexer_next_token(struct Token*, struct Lexer*);
void Lexer_tokenize(struct VecToken*, struct Lexer*);
void main(void);

void my_println(uint8_t* _arg0) {
    int32_t _t2;
    int64_t _t1;
    int64_t _t3;
    uint8_t* _t0;
    
    _t0 = _arg0;
    printf(_t0);
    _t2 = (int32_t)10LL;
    putchar(_t2);
    return;
}

void my_assert(bool _arg0) {
    bool _t0;
    bool _t1;
    int32_t _t2;
    int64_t _t3;
    
    _t0 = _arg0;
    _t1 = !_t0;
    if (_t1) goto L_then; else goto L_else;
L_then:
    _t2 = (int32_t)1LL;
    exit(_t2);
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    return;
}

void String_new(struct String* _arg0) {
    int64_t _t1;
    int64_t _t2;
    int64_t _t3;
    struct String* _t0;
    uint64_t* _t8;
    uint64_t* _t9;
    uint8_t _t5;
    uint8_t* _t4;
    uint8_t* _t6;
    uint8_t** _t7;
    
    _t0 = _arg0;
    _t1 = 16LL;
    malloc(_t1);
    _t3 = _t2;
    _t4 = (uint8_t*)_t3;
    _t5 = *_t4;
    _t6 = (uint8_t*)_t3;
    *_t6 = 0LL;
    _t7 = &_t0->data;
    *_t7 = _t3;
    _t8 = &_t0->len;
    *_t8 = 0LL;
    _t9 = &_t0->capacity;
    *_t9 = _t1;
    return;
}

void String_from_cstr(struct String* _arg0, uint8_t* _arg1) {
    int64_t _t10;
    int64_t _t2;
    int64_t _t3;
    int64_t _t5;
    int64_t _t6;
    int64_t _t7;
    int64_t _t8;
    int64_t _t9;
    struct String* _t0;
    uint64_t _t4;
    uint64_t* _t12;
    uint64_t* _t13;
    uint8_t* _t1;
    uint8_t** _t11;
    
    _t0 = _arg0;
    _t1 = _arg1;
    strlen(_t1);
    _t3 = _t2;
    _t4 = (uint64_t)1LL;
    _t5 = _t3 + _t4;
    _t6 = _t5;
    _t7 = (int64_t)_t6;
    malloc(_t7);
    _t9 = _t8;
    memcpy(_t9, _t1, _t6);
    _t11 = &_t0->data;
    *_t11 = _t9;
    _t12 = &_t0->len;
    *_t12 = _t3;
    _t13 = &_t0->capacity;
    *_t13 = _t6;
    return;
}

uint64_t String_len(struct String* _arg0) {
    struct String* _t0;
    uint64_t _t2;
    uint64_t* _t1;
    
    _t0 = _arg0;
    _t1 = &_t0->len;
    _t2 = *_t1;
    return _t2;
}

bool String_is_empty(struct String* _arg0) {
    int64_t _t4;
    struct String* _t0;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t* _t1;
    
    _t0 = _arg0;
    _t1 = &_t0->len;
    _t2 = *_t1;
    _t3 = (uint64_t)0LL;
    _t4 = _t2 == _t3;
    return _t4;
}

uint8_t* String_as_ptr(struct String* _arg0) {
    struct String* _t0;
    uint8_t* _t2;
    uint8_t** _t1;
    
    _t0 = _arg0;
    _t1 = &_t0->data;
    _t2 = *_t1;
    return _t2;
}

void String_ensure_capacity(struct String* _arg0, uint64_t _arg1) {
    int64_t _t10;
    int64_t _t12;
    int64_t _t13;
    int64_t _t18;
    int64_t _t4;
    int64_t _t6;
    int64_t _t7;
    struct String* _t0;
    uint64_t _t11;
    uint64_t _t1;
    uint64_t _t21;
    uint64_t _t3;
    uint64_t _t5;
    uint64_t _t9;
    uint64_t* _t20;
    uint64_t* _t22;
    uint64_t* _t2;
    uint64_t* _t8;
    uint8_t* _t15;
    uint8_t* _t17;
    uint8_t** _t14;
    uint8_t** _t16;
    uint8_t** _t19;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->len;
    _t3 = *_t2;
    _t4 = _t3 + _t1;
    _t5 = (uint64_t)1LL;
    _t6 = _t4 + _t5;
    _t7 = _t6;
    _t8 = &_t0->capacity;
    _t9 = *_t8;
    _t10 = _t7 > _t9;
    if (_t10) goto L_then; else goto L_else;
L_then:
    _t11 = (uint64_t)2LL;
    _t12 = _t7 * _t11;
    _t13 = _t12;
    _t14 = &_t0->data;
    _t15 = *_t14;
    _t16 = &_t0->data;
    _t17 = *_t16;
    realloc(_t17, _t13);
    _t19 = &_t0->data;
    *_t19 = _t18;
    _t20 = &_t0->capacity;
    _t21 = *_t20;
    _t22 = &_t0->capacity;
    *_t22 = _t13;
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    return;
}

void String_push(struct String* _arg0, uint8_t _arg1) {
    int64_t _t14;
    struct String* _t0;
    uint64_t _t10;
    uint64_t _t12;
    uint64_t _t13;
    uint64_t _t19;
    uint64_t _t5;
    uint64_t* _t11;
    uint64_t* _t15;
    uint64_t* _t18;
    uint64_t* _t4;
    uint64_t* _t9;
    uint8_t _t1;
    uint8_t _t22;
    uint8_t _t8;
    uint8_t* _t17;
    uint8_t* _t20;
    uint8_t* _t21;
    uint8_t* _t3;
    uint8_t* _t6;
    uint8_t* _t7;
    uint8_t** _t16;
    uint8_t** _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    String_ensure_capacity(_t0, 1LL);
    _t2 = &_t0->data;
    _t3 = *_t2;
    _t4 = &_t0->len;
    _t5 = *_t4;
    _t6 = &_t3[_t5];
    _t7 = _t6;
    _t8 = *_t7;
    *_t7 = _t1;
    _t9 = &_t0->len;
    _t10 = *_t9;
    _t11 = &_t0->len;
    _t12 = *_t11;
    _t13 = (uint64_t)1LL;
    _t14 = _t12 + _t13;
    _t15 = &_t0->len;
    *_t15 = _t14;
    _t16 = &_t0->data;
    _t17 = *_t16;
    _t18 = &_t0->len;
    _t19 = *_t18;
    _t20 = &_t17[_t19];
    _t21 = _t20;
    _t22 = *_t21;
    *_t21 = 0LL;
    return;
}

void String_push_str(struct String* _arg0, struct String* _arg1) {
    int64_t _t13;
    int64_t _t20;
    struct String* _t0;
    struct String* _t1;
    uint64_t _t12;
    uint64_t _t15;
    uint64_t _t17;
    uint64_t _t19;
    uint64_t _t25;
    uint64_t _t3;
    uint64_t _t7;
    uint64_t* _t11;
    uint64_t* _t14;
    uint64_t* _t16;
    uint64_t* _t18;
    uint64_t* _t21;
    uint64_t* _t24;
    uint64_t* _t2;
    uint64_t* _t6;
    uint8_t _t28;
    uint8_t* _t10;
    uint8_t* _t23;
    uint8_t* _t26;
    uint8_t* _t27;
    uint8_t* _t5;
    uint8_t* _t8;
    uint8_t** _t22;
    uint8_t** _t4;
    uint8_t** _t9;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t1->len;
    _t3 = *_t2;
    String_ensure_capacity(_t0, _t3);
    _t4 = &_t0->data;
    _t5 = *_t4;
    _t6 = &_t0->len;
    _t7 = *_t6;
    _t8 = &_t5[_t7];
    _t9 = &_t1->data;
    _t10 = *_t9;
    _t11 = &_t1->len;
    _t12 = *_t11;
    memcpy(_t8, _t10, _t12);
    _t14 = &_t0->len;
    _t15 = *_t14;
    _t16 = &_t0->len;
    _t17 = *_t16;
    _t18 = &_t1->len;
    _t19 = *_t18;
    _t20 = _t17 + _t19;
    _t21 = &_t0->len;
    *_t21 = _t20;
    _t22 = &_t0->data;
    _t23 = *_t22;
    _t24 = &_t0->len;
    _t25 = *_t24;
    _t26 = &_t23[_t25];
    _t27 = _t26;
    _t28 = *_t27;
    *_t27 = 0LL;
    return;
}

void String_clear(struct String* _arg0) {
    struct String* _t0;
    uint64_t _t2;
    uint64_t* _t1;
    uint64_t* _t3;
    uint8_t _t6;
    uint8_t* _t5;
    uint8_t* _t8;
    uint8_t** _t4;
    uint8_t** _t7;
    
    _t0 = _arg0;
    _t1 = &_t0->len;
    _t2 = *_t1;
    _t3 = &_t0->len;
    *_t3 = 0LL;
    _t4 = &_t0->data;
    _t5 = *_t4;
    _t6 = *_t5;
    _t7 = &_t0->data;
    _t8 = *_t7;
    *_t8 = 0LL;
    return;
}

uint8_t String_char_at(struct String* _arg0, uint64_t _arg1) {
    struct String* _t0;
    uint64_t _t1;
    uint8_t _t6;
    uint8_t* _t3;
    uint8_t* _t4;
    uint8_t* _t5;
    uint8_t** _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->data;
    _t3 = *_t2;
    _t4 = &_t3[_t1];
    _t5 = _t4;
    _t6 = *_t5;
    return _t6;
}

void String_print(struct String* _arg0) {
    int64_t _t3;
    struct String* _t0;
    uint8_t* _t2;
    uint8_t** _t1;
    
    _t0 = _arg0;
    _t1 = &_t0->data;
    _t2 = *_t1;
    printf(_t2);
    return;
}

void String_clone(struct String* _arg0, struct String* _arg1) {
    struct String* _t0;
    struct String* _t1;
    struct String* _t2;
    struct String* _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct String _alloca__t2;
    _t2 = &_alloca__t2;
    String_new(_t2);
    _t3 = _t2;
    String_push_str(_t3, _t1);
    return;
}

void String_drop(struct String* _arg0) {
    struct String* _t0;
    uint8_t* _t2;
    uint8_t** _t1;
    
    _t0 = _arg0;
    _t1 = &_t0->data;
    _t2 = *_t1;
    free(_t2);
    return;
}

void Span_new(struct Span* _arg0, uint64_t _arg1, uint64_t _arg2, uint64_t _arg3) {
    struct Span* _t0;
    uint64_t _t1;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t* _t4;
    uint64_t* _t5;
    uint64_t* _t6;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = &_t0->file_id;
    *_t4 = _t1;
    _t5 = &_t0->start;
    *_t5 = _t2;
    _t6 = &_t0->end;
    *_t6 = _t3;
    return;
}

void Span_empty(struct Span* _arg0, uint64_t _arg1, uint64_t _arg2) {
    struct Span* _t0;
    uint64_t _t1;
    uint64_t _t2;
    uint64_t* _t3;
    uint64_t* _t4;
    uint64_t* _t5;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t0->file_id;
    *_t3 = _t1;
    _t4 = &_t0->start;
    *_t4 = _t2;
    _t5 = &_t0->end;
    *_t5 = _t2;
    return;
}

void Span_merge(struct Span* _arg0, struct Span* _arg1, struct Span* _arg2) {
    int64_t _t10;
    int64_t _t21;
    struct Span* _t0;
    struct Span* _t1;
    struct Span* _t2;
    uint64_t _t12;
    uint64_t _t14;
    uint64_t _t15;
    uint64_t _t18;
    uint64_t _t20;
    uint64_t _t23;
    uint64_t _t25;
    uint64_t _t26;
    uint64_t _t4;
    uint64_t _t7;
    uint64_t _t9;
    uint64_t* _t11;
    uint64_t* _t13;
    uint64_t* _t16;
    uint64_t* _t17;
    uint64_t* _t19;
    uint64_t* _t22;
    uint64_t* _t24;
    uint64_t* _t27;
    uint64_t* _t3;
    uint64_t* _t5;
    uint64_t* _t6;
    uint64_t* _t8;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t1->file_id;
    _t4 = *_t3;
    _t5 = &_t0->file_id;
    *_t5 = _t4;
    _t6 = &_t1->start;
    _t7 = *_t6;
    _t8 = &_t2->start;
    _t9 = *_t8;
    _t10 = _t7 < _t9;
    if (_t10) goto L_then; else goto L_else;
L_then:
    _t11 = &_t1->start;
    _t12 = *_t11;
    goto L_merge;
L_else:
    _t13 = &_t2->start;
    _t14 = *_t13;
    goto L_merge;
L_merge:
    _t15 = _t12;
    _t16 = &_t0->start;
    *_t16 = _t15;
    _t17 = &_t1->end;
    _t18 = *_t17;
    _t19 = &_t2->end;
    _t20 = *_t19;
    _t21 = _t18 > _t20;
    if (_t21) goto L_then; else goto L_else;
L_then:
    _t22 = &_t1->end;
    _t23 = *_t22;
    goto L_merge;
L_else:
    _t24 = &_t2->end;
    _t25 = *_t24;
    goto L_merge;
L_merge:
    _t26 = _t23;
    _t27 = &_t0->end;
    *_t27 = _t26;
    return;
}

void Token_new(struct Token* _arg0, struct TokenKind* _arg1, struct Span* _arg2) {
    struct Span* _t2;
    struct Span** _t4;
    struct Token* _t0;
    struct TokenKind* _t1;
    struct TokenKind** _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t0->kind;
    *_t3 = _t1;
    _t4 = &_t0->span;
    *_t4 = _t2;
    return;
}

void Token_eof(struct Token* _arg0, struct Span* _arg1) {
    struct Span* _t1;
    struct Span** _t3;
    struct Token* _t0;
    struct TokenKind** _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->kind;
    *_t2 = TokenKind_Eof;
    _t3 = &_t0->span;
    *_t3 = _t1;
    return;
}

bool strcmp_lit(uint8_t* _arg0, uint8_t* _arg1) {
    int32_t _t3;
    int64_t _t2;
    int64_t _t4;
    uint8_t* _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    strcmp(_t0, _t1);
    _t3 = (int32_t)0LL;
    _t4 = _t2 == _t3;
    return _t4;
}

struct TokenKind* keyword_from_str(struct String* _arg0) {
    bool _t10;
    bool _t11;
    bool _t12;
    bool _t13;
    bool _t16;
    bool _t17;
    bool _t18;
    bool _t19;
    bool _t20;
    bool _t21;
    bool _t22;
    bool _t25;
    bool _t26;
    bool _t27;
    bool _t28;
    bool _t29;
    bool _t30;
    bool _t31;
    bool _t34;
    bool _t35;
    bool _t36;
    bool _t37;
    bool _t38;
    bool _t39;
    bool _t40;
    bool _t41;
    bool _t44;
    bool _t45;
    bool _t46;
    bool _t47;
    bool _t48;
    bool _t49;
    bool _t50;
    bool _t53;
    bool _t56;
    bool _t57;
    bool _t58;
    bool _t61;
    bool _t7;
    int64_t _t15;
    int64_t _t24;
    int64_t _t33;
    int64_t _t43;
    int64_t _t52;
    int64_t _t55;
    int64_t _t60;
    int64_t _t6;
    int64_t _t9;
    struct String* _t0;
    struct String* _t59;
    uint64_t _t14;
    uint64_t _t23;
    uint64_t _t32;
    uint64_t _t3;
    uint64_t _t42;
    uint64_t _t4;
    uint64_t _t51;
    uint64_t _t54;
    uint64_t _t5;
    uint64_t _t8;
    uint8_t* _t1;
    uint8_t* _t2;
    
    _t0 = _arg0;
    _t1 = String_as_ptr(_t0);
    _t2 = _t1;
    _t3 = String_len(_t0);
    _t4 = _t3;
    _t5 = (uint64_t)2LL;
    _t6 = _t4 == _t5;
    if (_t6) goto L_then; else goto L_else;
L_then:
    _t7 = strcmp_lit(_t2, "fn");
    if (_t7) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t8 = (uint64_t)3LL;
    _t9 = _t4 == _t8;
    if (_t9) goto L_then; else goto L_else;
L_then:
    return TokenKind_Fn;
L_else:
    goto L_merge;
L_merge:
    _t10 = strcmp_lit(_t2, "if");
    if (_t10) goto L_then; else goto L_else;
L_then:
    return TokenKind_If;
L_else:
    goto L_merge;
L_merge:
    _t11 = strcmp_lit(_t2, "in");
    if (_t11) goto L_then; else goto L_else;
L_then:
    return TokenKind_In;
L_else:
    goto L_merge;
L_merge:
    _t12 = strcmp_lit(_t2, "as");
    if (_t12) goto L_then; else goto L_else;
L_then:
    return TokenKind_As;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t13 = strcmp_lit(_t2, "let");
    if (_t13) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t14 = (uint64_t)4LL;
    _t15 = _t4 == _t14;
    if (_t15) goto L_then; else goto L_else;
L_then:
    return TokenKind_Let;
L_else:
    goto L_merge;
L_merge:
    _t16 = strcmp_lit(_t2, "mut");
    if (_t16) goto L_then; else goto L_else;
L_then:
    return TokenKind_Mut;
L_else:
    goto L_merge;
L_merge:
    _t17 = strcmp_lit(_t2, "for");
    if (_t17) goto L_then; else goto L_else;
L_then:
    return TokenKind_For;
L_else:
    goto L_merge;
L_merge:
    _t18 = strcmp_lit(_t2, "ref");
    if (_t18) goto L_then; else goto L_else;
L_then:
    return TokenKind_Ref;
L_else:
    goto L_merge;
L_merge:
    _t19 = strcmp_lit(_t2, "own");
    if (_t19) goto L_then; else goto L_else;
L_then:
    return TokenKind_Own;
L_else:
    goto L_merge;
L_merge:
    _t20 = strcmp_lit(_t2, "asm");
    if (_t20) goto L_then; else goto L_else;
L_then:
    return TokenKind_Asm;
L_else:
    goto L_merge;
L_merge:
    _t21 = strcmp_lit(_t2, "pub");
    if (_t21) goto L_then; else goto L_else;
L_then:
    return TokenKind_Pub;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t22 = strcmp_lit(_t2, "else");
    if (_t22) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t23 = (uint64_t)5LL;
    _t24 = _t4 == _t23;
    if (_t24) goto L_then; else goto L_else;
L_then:
    return TokenKind_Else;
L_else:
    goto L_merge;
L_merge:
    _t25 = strcmp_lit(_t2, "loop");
    if (_t25) goto L_then; else goto L_else;
L_then:
    return TokenKind_Loop;
L_else:
    goto L_merge;
L_merge:
    _t26 = strcmp_lit(_t2, "true");
    if (_t26) goto L_then; else goto L_else;
L_then:
    return TokenKind_True;
L_else:
    goto L_merge;
L_merge:
    _t27 = strcmp_lit(_t2, "enum");
    if (_t27) goto L_then; else goto L_else;
L_then:
    return TokenKind_Enum;
L_else:
    goto L_merge;
L_merge:
    _t28 = strcmp_lit(_t2, "impl");
    if (_t28) goto L_then; else goto L_else;
L_then:
    return TokenKind_Impl;
L_else:
    goto L_merge;
L_merge:
    _t29 = strcmp_lit(_t2, "type");
    if (_t29) goto L_then; else goto L_else;
L_then:
    return TokenKind_Type;
L_else:
    goto L_merge;
L_merge:
    _t30 = strcmp_lit(_t2, "pure");
    if (_t30) goto L_then; else goto L_else;
L_then:
    return TokenKind_Pure;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t31 = strcmp_lit(_t2, "while");
    if (_t31) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t32 = (uint64_t)6LL;
    _t33 = _t4 == _t32;
    if (_t33) goto L_then; else goto L_else;
L_then:
    return TokenKind_While;
L_else:
    goto L_merge;
L_merge:
    _t34 = strcmp_lit(_t2, "match");
    if (_t34) goto L_then; else goto L_else;
L_then:
    return TokenKind_Match;
L_else:
    goto L_merge;
L_merge:
    _t35 = strcmp_lit(_t2, "break");
    if (_t35) goto L_then; else goto L_else;
L_then:
    return TokenKind_Break;
L_else:
    goto L_merge;
L_merge:
    _t36 = strcmp_lit(_t2, "false");
    if (_t36) goto L_then; else goto L_else;
L_then:
    return TokenKind_False;
L_else:
    goto L_merge;
L_merge:
    _t37 = strcmp_lit(_t2, "const");
    if (_t37) goto L_then; else goto L_else;
L_then:
    return TokenKind_Const;
L_else:
    goto L_merge;
L_merge:
    _t38 = strcmp_lit(_t2, "trait");
    if (_t38) goto L_then; else goto L_else;
L_then:
    return TokenKind_Trait;
L_else:
    goto L_merge;
L_merge:
    _t39 = strcmp_lit(_t2, "where");
    if (_t39) goto L_then; else goto L_else;
L_then:
    return TokenKind_Where;
L_else:
    goto L_merge;
L_merge:
    _t40 = strcmp_lit(_t2, "union");
    if (_t40) goto L_then; else goto L_else;
L_then:
    return TokenKind_Union;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t41 = strcmp_lit(_t2, "return");
    if (_t41) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t42 = (uint64_t)7LL;
    _t43 = _t4 == _t42;
    if (_t43) goto L_then; else goto L_else;
L_then:
    return TokenKind_Return;
L_else:
    goto L_merge;
L_merge:
    _t44 = strcmp_lit(_t2, "struct");
    if (_t44) goto L_then; else goto L_else;
L_then:
    return TokenKind_Struct;
L_else:
    goto L_merge;
L_merge:
    _t45 = strcmp_lit(_t2, "unsafe");
    if (_t45) goto L_then; else goto L_else;
L_then:
    return TokenKind_Unsafe;
L_else:
    goto L_merge;
L_merge:
    _t46 = strcmp_lit(_t2, "extern");
    if (_t46) goto L_then; else goto L_else;
L_then:
    return TokenKind_Extern;
L_else:
    goto L_merge;
L_merge:
    _t47 = strcmp_lit(_t2, "static");
    if (_t47) goto L_then; else goto L_else;
L_then:
    return TokenKind_Static;
L_else:
    goto L_merge;
L_merge:
    _t48 = strcmp_lit(_t2, "effect");
    if (_t48) goto L_then; else goto L_else;
L_then:
    return TokenKind_Effect;
L_else:
    goto L_merge;
L_merge:
    _t49 = strcmp_lit(_t2, "shared");
    if (_t49) goto L_then; else goto L_else;
L_then:
    return TokenKind_Shared;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t50 = strcmp_lit(_t2, "ensures");
    if (_t50) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t51 = (uint64_t)8LL;
    _t52 = _t4 == _t51;
    if (_t52) goto L_then; else goto L_else;
L_then:
    return TokenKind_Ensures;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t53 = strcmp_lit(_t2, "continue");
    if (_t53) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t54 = (uint64_t)9LL;
    _t55 = _t4 == _t54;
    if (_t55) goto L_then; else goto L_else;
L_then:
    return TokenKind_Continue;
L_else:
    goto L_merge;
L_merge:
    _t56 = strcmp_lit(_t2, "requires");
    if (_t56) goto L_then; else goto L_else;
L_then:
    return TokenKind_Requires;
L_else:
    goto L_merge;
L_merge:
    _t57 = strcmp_lit(_t2, "volatile");
    if (_t57) goto L_then; else goto L_else;
L_then:
    return TokenKind_Volatile;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t58 = strcmp_lit(_t2, "interface");
    if (_t58) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    struct String _alloca__t59;
    _t59 = &_alloca__t59;
    String_clone(_t59, _t0);
    TokenKind_Ident(_t59);
    return _t60;
L_then:
    return TokenKind_Interface;
L_else:
    goto L_merge;
L_merge:
    _t61 = strcmp_lit(_t2, "invariant");
    if (_t61) goto L_then; else goto L_else;
L_then:
    return TokenKind_Invariant;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
}

void VecToken_new(struct VecToken* _arg0) {
    struct Token** _t1;
    struct Token*** _t2;
    struct VecToken* _t0;
    uint64_t* _t3;
    uint64_t* _t4;
    
    _t0 = _arg0;
    _t1 = (struct Token**)0LL;
    _t2 = &_t0->data;
    *_t2 = _t1;
    _t3 = &_t0->len;
    *_t3 = 0LL;
    _t4 = &_t0->capacity;
    *_t4 = 0LL;
    return;
}

void VecToken_with_capacity(struct VecToken* _arg0, uint64_t _arg1) {
    int64_t _t2;
    int64_t _t4;
    int64_t _t5;
    int64_t _t6;
    struct Token** _t7;
    struct Token** _t8;
    struct Token*** _t9;
    struct VecToken* _t0;
    uint64_t _t1;
    uint64_t _t3;
    uint64_t* _t10;
    uint64_t* _t11;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = 64LL;
    _t3 = (uint64_t)_t2;
    _t4 = _t1 * _t3;
    _t5 = (int64_t)_t4;
    malloc(_t5);
    _t7 = (struct Token**)_t6;
    _t8 = _t7;
    _t9 = &_t0->data;
    *_t9 = _t8;
    _t10 = &_t0->len;
    *_t10 = 0LL;
    _t11 = &_t0->capacity;
    *_t11 = _t1;
    return;
}

uint64_t VecToken_len(struct VecToken* _arg0) {
    struct VecToken* _t0;
    uint64_t _t2;
    uint64_t* _t1;
    
    _t0 = _arg0;
    _t1 = &_t0->len;
    _t2 = *_t1;
    return _t2;
}

bool VecToken_is_empty(struct VecToken* _arg0) {
    int64_t _t4;
    struct VecToken* _t0;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t* _t1;
    
    _t0 = _arg0;
    _t1 = &_t0->len;
    _t2 = *_t1;
    _t3 = (uint64_t)0LL;
    _t4 = _t2 == _t3;
    return _t4;
}

uint64_t VecToken_capacity(struct VecToken* _arg0) {
    struct VecToken* _t0;
    uint64_t _t2;
    uint64_t* _t1;
    
    _t0 = _arg0;
    _t1 = &_t0->capacity;
    _t2 = *_t1;
    return _t2;
}

void VecToken_ensure_capacity(struct VecToken* _arg0, uint64_t _arg1) {
    int64_t _t12;
    int64_t _t17;
    int64_t _t20;
    int64_t _t21;
    int64_t _t22;
    int64_t _t23;
    int64_t _t25;
    int64_t _t26;
    int64_t _t27;
    int64_t _t33;
    int64_t _t41;
    int64_t _t42;
    int64_t _t46;
    int64_t _t4;
    int64_t _t5;
    int64_t _t8;
    struct Token** _t28;
    struct Token** _t29;
    struct Token** _t36;
    struct Token** _t48;
    struct Token** _t51;
    struct Token*** _t35;
    struct Token*** _t47;
    struct Token*** _t50;
    struct Token*** _t52;
    struct VecToken* _t0;
    uint64_t _t10;
    uint64_t _t11;
    uint64_t _t13;
    uint64_t _t15;
    uint64_t _t16;
    uint64_t _t18;
    uint64_t _t19;
    uint64_t _t1;
    uint64_t _t24;
    uint64_t _t31;
    uint64_t _t32;
    uint64_t _t39;
    uint64_t _t3;
    uint64_t _t40;
    uint64_t _t44;
    uint64_t _t45;
    uint64_t _t54;
    uint64_t _t7;
    uint64_t* _t14;
    uint64_t* _t2;
    uint64_t* _t30;
    uint64_t* _t38;
    uint64_t* _t43;
    uint64_t* _t53;
    uint64_t* _t55;
    uint64_t* _t6;
    uint64_t* _t9;
    uint8_t* _t34;
    uint8_t* _t37;
    uint8_t* _t49;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->len;
    _t3 = *_t2;
    _t4 = _t3 + _t1;
    _t5 = _t4;
    _t6 = &_t0->capacity;
    _t7 = *_t6;
    _t8 = _t5 > _t7;
    if (_t8) goto L_then; else goto L_else;
L_then:
    _t9 = &_t0->capacity;
    _t10 = *_t9;
    _t11 = (uint64_t)0LL;
    _t12 = _t10 == _t11;
    if (_t12) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    _t13 = (uint64_t)8LL;
    goto L_merge;
L_else:
    _t14 = &_t0->capacity;
    _t15 = *_t14;
    _t16 = (uint64_t)2LL;
    _t17 = _t15 * _t16;
    goto L_merge;
L_merge:
    _t18 = _t13;
    _t19 = _t18;
    _t20 = _t19 < _t5;
    if (_t20) goto L_then; else goto L_else;
L_then:
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    _t21 = _t5;
    _t22 = _t21;
    _t23 = 64LL;
    _t24 = (uint64_t)_t23;
    _t25 = _t22 * _t24;
    _t26 = (int64_t)_t25;
    malloc(_t26);
    _t28 = (struct Token**)_t27;
    _t29 = _t28;
    _t30 = &_t0->len;
    _t31 = *_t30;
    _t32 = (uint64_t)0LL;
    _t33 = _t31 > _t32;
    if (_t33) goto L_then; else goto L_else;
L_then:
    _t34 = (uint8_t*)_t29;
    _t35 = &_t0->data;
    _t36 = *_t35;
    _t37 = (uint8_t*)_t36;
    _t38 = &_t0->len;
    _t39 = *_t38;
    _t40 = (uint64_t)_t23;
    _t41 = _t39 * _t40;
    memcpy(_t34, _t37, _t41);
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    _t43 = &_t0->capacity;
    _t44 = *_t43;
    _t45 = (uint64_t)0LL;
    _t46 = _t44 > _t45;
    if (_t46) goto L_then; else goto L_else;
L_then:
    _t47 = &_t0->data;
    _t48 = *_t47;
    _t49 = (uint8_t*)_t48;
    free(_t49);
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    _t50 = &_t0->data;
    _t51 = *_t50;
    _t52 = &_t0->data;
    *_t52 = _t29;
    _t53 = &_t0->capacity;
    _t54 = *_t53;
    _t55 = &_t0->capacity;
    *_t55 = _t22;
    goto L_merge;
}

void VecToken_push(struct VecToken* _arg0, struct Token* _arg1) {
    int64_t _t14;
    struct Token* _t1;
    struct Token* _t8;
    struct Token** _t3;
    struct Token** _t6;
    struct Token** _t7;
    struct Token*** _t2;
    struct VecToken* _t0;
    uint64_t _t10;
    uint64_t _t12;
    uint64_t _t13;
    uint64_t _t5;
    uint64_t* _t11;
    uint64_t* _t15;
    uint64_t* _t4;
    uint64_t* _t9;
    
    _t0 = _arg0;
    _t1 = _arg1;
    VecToken_ensure_capacity(_t0, 1LL);
    _t2 = &_t0->data;
    _t3 = *_t2;
    _t4 = &_t0->len;
    _t5 = *_t4;
    _t6 = &_t3[_t5];
    _t7 = _t6;
    _t8 = *_t7;
    *_t7 = _t1;
    _t9 = &_t0->len;
    _t10 = *_t9;
    _t11 = &_t0->len;
    _t12 = *_t11;
    _t13 = (uint64_t)1LL;
    _t14 = _t12 + _t13;
    _t15 = &_t0->len;
    *_t15 = _t14;
    return;
}

void VecToken_pop(struct Token* _arg0, struct VecToken* _arg1) {
    int64_t _t7;
    struct Token* _t0;
    struct Token* _t15;
    struct Token** _t10;
    struct Token** _t13;
    struct Token** _t14;
    struct Token*** _t9;
    struct VecToken* _t1;
    uint64_t _t12;
    uint64_t _t3;
    uint64_t _t5;
    uint64_t _t6;
    uint64_t* _t11;
    uint64_t* _t2;
    uint64_t* _t4;
    uint64_t* _t8;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t1->len;
    _t3 = *_t2;
    _t4 = &_t1->len;
    _t5 = *_t4;
    _t6 = (uint64_t)1LL;
    _t7 = _t5 - _t6;
    _t8 = &_t1->len;
    *_t8 = _t7;
    _t9 = &_t1->data;
    _t10 = *_t9;
    _t11 = &_t1->len;
    _t12 = *_t11;
    _t13 = &_t10[_t12];
    _t14 = _t13;
    _t15 = *_t14;
    return;
}

void VecToken_get(struct Token* _arg0, struct VecToken* _arg1, uint64_t _arg2) {
    struct Token* _t0;
    struct Token** _t4;
    struct Token** _t5;
    struct Token** _t6;
    struct Token*** _t3;
    struct VecToken* _t1;
    uint64_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t1->data;
    _t4 = *_t3;
    _t5 = &_t4[_t2];
    _t6 = _t5;
    return;
}

void VecToken_get_mut(struct Token* _arg0, struct VecToken* _arg1, uint64_t _arg2) {
    struct Token* _t0;
    struct Token** _t4;
    struct Token** _t5;
    struct Token** _t6;
    struct Token*** _t3;
    struct VecToken* _t1;
    uint64_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t1->data;
    _t4 = *_t3;
    _t5 = &_t4[_t2];
    _t6 = _t5;
    return;
}

void VecToken_clear(struct VecToken* _arg0) {
    struct VecToken* _t0;
    uint64_t _t2;
    uint64_t* _t1;
    uint64_t* _t3;
    
    _t0 = _arg0;
    _t1 = &_t0->len;
    _t2 = *_t1;
    _t3 = &_t0->len;
    *_t3 = 0LL;
    return;
}

void VecToken_drop(struct VecToken* _arg0) {
    int64_t _t4;
    struct Token** _t6;
    struct Token*** _t5;
    struct VecToken* _t0;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t* _t1;
    uint8_t* _t7;
    
    _t0 = _arg0;
    _t1 = &_t0->capacity;
    _t2 = *_t1;
    _t3 = (uint64_t)0LL;
    _t4 = _t2 > _t3;
    if (_t4) goto L_then; else goto L_else;
L_then:
    _t5 = &_t0->data;
    _t6 = *_t5;
    _t7 = (uint8_t*)_t6;
    free(_t7);
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    return;
}

void Lexer_new(struct Lexer* _arg0, uint8_t* _arg1, uint64_t _arg2, uint64_t _arg3) {
    struct Lexer* _t0;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t* _t5;
    uint64_t* _t6;
    uint64_t* _t7;
    uint64_t* _t8;
    uint8_t* _t1;
    uint8_t** _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = &_t0->source;
    *_t4 = _t1;
    _t5 = &_t0->source_len;
    *_t5 = _t2;
    _t6 = &_t0->pos;
    *_t6 = 0LL;
    _t7 = &_t0->start;
    *_t7 = 0LL;
    _t8 = &_t0->file_id;
    *_t8 = _t3;
    return;
}

uint8_t Lexer_peek(struct Lexer* _arg0) {
    int64_t _t5;
    struct Lexer* _t0;
    uint64_t _t10;
    uint64_t _t2;
    uint64_t _t4;
    uint64_t* _t1;
    uint64_t* _t3;
    uint64_t* _t9;
    uint8_t _t13;
    uint8_t _t6;
    uint8_t* _t11;
    uint8_t* _t12;
    uint8_t* _t8;
    uint8_t** _t7;
    
    _t0 = _arg0;
    _t1 = &_t0->pos;
    _t2 = *_t1;
    _t3 = &_t0->source_len;
    _t4 = *_t3;
    _t5 = _t2 >= _t4;
    if (_t5) goto L_then; else goto L_else;
L_then:
    _t6 = (uint8_t)0LL;
    return _t6;
L_else:
    goto L_merge;
L_merge:
    _t7 = &_t0->source;
    _t8 = *_t7;
    _t9 = &_t0->pos;
    _t10 = *_t9;
    _t11 = &_t8[_t10];
    _t12 = _t11;
    _t13 = *_t12;
    return _t13;
}

uint8_t Lexer_peek_next(struct Lexer* _arg0) {
    int64_t _t4;
    int64_t _t7;
    struct Lexer* _t0;
    uint64_t _t12;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t _t6;
    uint64_t* _t11;
    uint64_t* _t1;
    uint64_t* _t5;
    uint8_t _t16;
    uint8_t _t8;
    uint8_t* _t10;
    uint8_t* _t13;
    uint8_t* _t14;
    uint8_t* _t15;
    uint8_t** _t9;
    
    _t0 = _arg0;
    _t1 = &_t0->pos;
    _t2 = *_t1;
    _t3 = (uint64_t)1LL;
    _t4 = _t2 + _t3;
    _t5 = &_t0->source_len;
    _t6 = *_t5;
    _t7 = _t4 >= _t6;
    if (_t7) goto L_then; else goto L_else;
L_then:
    _t8 = (uint8_t)0LL;
    return _t8;
L_else:
    goto L_merge;
L_merge:
    _t9 = &_t0->source;
    _t10 = *_t9;
    _t11 = &_t0->pos;
    _t12 = *_t11;
    _t13 = &_t10[_t12];
    _t14 = &_t13[1LL];
    _t15 = _t14;
    _t16 = *_t15;
    return _t16;
}

uint8_t Lexer_advance(struct Lexer* _arg0) {
    int64_t _t8;
    struct Lexer* _t0;
    uint64_t _t4;
    uint64_t _t6;
    uint64_t _t7;
    uint64_t* _t3;
    uint64_t* _t5;
    uint64_t* _t9;
    uint8_t _t1;
    uint8_t _t2;
    
    _t0 = _arg0;
    _t1 = Lexer_peek(_t0);
    _t2 = _t1;
    _t3 = &_t0->pos;
    _t4 = *_t3;
    _t5 = &_t0->pos;
    _t6 = *_t5;
    _t7 = (uint64_t)1LL;
    _t8 = _t6 + _t7;
    _t9 = &_t0->pos;
    *_t9 = _t8;
    return _t2;
}

bool Lexer_is_at_end(struct Lexer* _arg0) {
    int64_t _t5;
    struct Lexer* _t0;
    uint64_t _t2;
    uint64_t _t4;
    uint64_t* _t1;
    uint64_t* _t3;
    
    _t0 = _arg0;
    _t1 = &_t0->pos;
    _t2 = *_t1;
    _t3 = &_t0->source_len;
    _t4 = *_t3;
    _t5 = _t2 >= _t4;
    return _t5;
}

void Lexer_make_span(struct Span* _arg0, struct Lexer* _arg1) {
    struct Lexer* _t1;
    struct Span* _t0;
    uint64_t _t3;
    uint64_t _t6;
    uint64_t _t9;
    uint64_t* _t10;
    uint64_t* _t2;
    uint64_t* _t4;
    uint64_t* _t5;
    uint64_t* _t7;
    uint64_t* _t8;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t1->file_id;
    _t3 = *_t2;
    _t4 = &_t0->file_id;
    *_t4 = _t3;
    _t5 = &_t1->start;
    _t6 = *_t5;
    _t7 = &_t0->start;
    *_t7 = _t6;
    _t8 = &_t1->pos;
    _t9 = *_t8;
    _t10 = &_t0->end;
    *_t10 = _t9;
    return;
}

void Lexer_make_token(struct Token* _arg0, struct Lexer* _arg1, struct TokenKind* _arg2) {
    struct Lexer* _t1;
    struct Span* _t4;
    struct Span** _t5;
    struct Token* _t0;
    struct TokenKind* _t2;
    struct TokenKind** _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t0->kind;
    *_t3 = _t2;
    struct Span _alloca__t4;
    _t4 = &_alloca__t4;
    Lexer_make_span(_t4, _t1);
    _t5 = &_t0->span;
    *_t5 = _t4;
    return;
}

bool Lexer_is_alpha(uint8_t _arg0) {
    int64_t _t10;
    int64_t _t11;
    int64_t _t13;
    int64_t _t14;
    int64_t _t2;
    int64_t _t4;
    int64_t _t5;
    int64_t _t7;
    int64_t _t9;
    uint8_t _t0;
    uint8_t _t12;
    uint8_t _t1;
    uint8_t _t3;
    uint8_t _t6;
    uint8_t _t8;
    
    _t0 = _arg0;
    _t1 = (uint8_t)65LL;
    _t2 = _t0 >= _t1;
    _t3 = (uint8_t)90LL;
    _t4 = _t0 <= _t3;
    _t5 = _t2 && _t4;
    _t6 = (uint8_t)97LL;
    _t7 = _t0 >= _t6;
    _t8 = (uint8_t)122LL;
    _t9 = _t0 <= _t8;
    _t10 = _t7 && _t9;
    _t11 = _t5 || _t10;
    _t12 = (uint8_t)95LL;
    _t13 = _t0 == _t12;
    _t14 = _t11 || _t13;
    return _t14;
}

bool Lexer_is_digit(uint8_t _arg0) {
    int64_t _t2;
    int64_t _t4;
    int64_t _t5;
    uint8_t _t0;
    uint8_t _t1;
    uint8_t _t3;
    
    _t0 = _arg0;
    _t1 = (uint8_t)48LL;
    _t2 = _t0 >= _t1;
    _t3 = (uint8_t)57LL;
    _t4 = _t0 <= _t3;
    _t5 = _t2 && _t4;
    return _t5;
}

bool Lexer_is_alnum(uint8_t _arg0) {
    bool _t1;
    bool _t2;
    int64_t _t3;
    uint8_t _t0;
    
    _t0 = _arg0;
    _t1 = Lexer_is_alpha(_t0);
    _t2 = Lexer_is_digit(_t0);
    _t3 = _t1 || _t2;
    return _t3;
}

bool Lexer_is_whitespace(uint8_t _arg0) {
    int64_t _t10;
    int64_t _t11;
    int64_t _t2;
    int64_t _t4;
    int64_t _t5;
    int64_t _t7;
    int64_t _t8;
    uint8_t _t0;
    uint8_t _t1;
    uint8_t _t3;
    uint8_t _t6;
    uint8_t _t9;
    
    _t0 = _arg0;
    _t1 = (uint8_t)32LL;
    _t2 = _t0 == _t1;
    _t3 = (uint8_t)9LL;
    _t4 = _t0 == _t3;
    _t5 = _t2 || _t4;
    _t6 = (uint8_t)10LL;
    _t7 = _t0 == _t6;
    _t8 = _t5 || _t7;
    _t9 = (uint8_t)13LL;
    _t10 = _t0 == _t9;
    _t11 = _t8 || _t10;
    return _t11;
}

void Lexer_skip_whitespace(struct Lexer* _arg0) {
    struct Lexer* _t0;
    
    _t0 = _arg0;
    return;
}

void Lexer_read_identifier(struct Token* _arg0, struct Lexer* _arg1) {
    int64_t _t10;
    int64_t _t6;
    int64_t _t7;
    struct Lexer* _t1;
    struct String* _t8;
    struct String* _t9;
    struct Token* _t0;
    struct Token* _t13;
    struct TokenKind* _t11;
    struct TokenKind* _t12;
    uint64_t _t3;
    uint64_t _t5;
    uint64_t* _t2;
    uint64_t* _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t1->pos;
    _t3 = *_t2;
    _t4 = &_t1->start;
    _t5 = *_t4;
    _t6 = _t3 - _t5;
    _t7 = _t6;
    struct String _alloca__t8;
    _t8 = &_alloca__t8;
    String_new(_t8);
    _t9 = _t8;
    _t10 = 0LL;
    struct TokenKind _alloca__t11;
    _t11 = &_alloca__t11;
    keyword_from_str(_t11, ((void)0));
    _t12 = _t11;
    struct Token _alloca__t13;
    _t13 = &_alloca__t13;
    Lexer_make_token(_t13, _t1, _t12);
    return;
}

void Lexer_read_number(struct Token* _arg0, struct Lexer* _arg1) {
    bool _t24;
    double _t43;
    double _t44;
    int64_t _t11;
    int64_t _t12;
    int64_t _t13;
    int64_t _t16;
    int64_t _t17;
    int64_t _t18;
    int64_t _t22;
    int64_t _t25;
    int64_t _t29;
    int64_t _t2;
    int64_t _t32;
    int64_t _t33;
    int64_t _t37;
    int64_t _t40;
    int64_t _t41;
    int64_t _t45;
    int64_t _t47;
    int64_t _t48;
    int64_t _t49;
    int64_t _t5;
    int64_t _t8;
    struct Lexer* _t1;
    struct Token* _t0;
    struct Token* _t19;
    struct Token* _t46;
    struct Token* _t50;
    struct Token* _t51;
    uint8_t _t10;
    uint8_t _t14;
    uint8_t _t15;
    uint8_t _t20;
    uint8_t _t21;
    uint8_t _t23;
    uint8_t _t26;
    uint8_t _t27;
    uint8_t _t28;
    uint8_t _t30;
    uint8_t _t31;
    uint8_t _t34;
    uint8_t _t35;
    uint8_t _t36;
    uint8_t _t38;
    uint8_t _t39;
    uint8_t _t3;
    uint8_t _t42;
    uint8_t _t4;
    uint8_t _t6;
    uint8_t _t7;
    uint8_t _t9;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = 0;
    _t3 = Lexer_peek(_t1);
    _t4 = (uint8_t)48LL;
    _t5 = _t3 == _t4;
    _t6 = Lexer_peek_next(_t1);
    _t7 = (uint8_t)120LL;
    _t8 = _t6 == _t7;
    _t9 = Lexer_peek_next(_t1);
    _t10 = (uint8_t)88LL;
    _t11 = _t9 == _t10;
    _t12 = _t8 || _t11;
    _t13 = _t5 && _t12;
    if (_t13) goto L_then; else goto L_else;
L_then:
    _t14 = Lexer_advance(_t1);
    _t15 = Lexer_advance(_t1);
    _t16 = Lexer_parse_hex(_t1);
    _t17 = _t16;
    TokenKind_IntLit(_t17);
    struct Token _alloca__t19;
    _t19 = &_alloca__t19;
    Lexer_make_token(_t19, _t1, _t18);
    return;
L_else:
    goto L_merge;
L_merge:
    _t20 = Lexer_peek(_t1);
    _t21 = (uint8_t)46LL;
    _t22 = _t20 == _t21;
    _t23 = Lexer_peek_next(_t1);
    _t24 = Lexer_is_digit(_t23);
    _t25 = _t22 && _t24;
    if (_t25) goto L_then; else goto L_else;
L_then:
    _t2 = 1;
    _t26 = Lexer_advance(_t1);
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    _t27 = Lexer_peek(_t1);
    _t28 = (uint8_t)101LL;
    _t29 = _t27 == _t28;
    _t30 = Lexer_peek(_t1);
    _t31 = (uint8_t)69LL;
    _t32 = _t30 == _t31;
    _t33 = _t29 || _t32;
    if (_t33) goto L_then; else goto L_else;
L_then:
    _t2 = 1;
    _t34 = Lexer_advance(_t1);
    _t35 = Lexer_peek(_t1);
    _t36 = (uint8_t)43LL;
    _t37 = _t35 == _t36;
    _t38 = Lexer_peek(_t1);
    _t39 = (uint8_t)45LL;
    _t40 = _t38 == _t39;
    _t41 = _t37 || _t40;
    if (_t41) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    if (_t2) goto L_then; else goto L_else;
L_then:
    _t42 = Lexer_advance(_t1);
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
L_then:
    _t43 = Lexer_parse_float(_t1);
    _t44 = _t43;
    TokenKind_FloatLit(_t44);
    struct Token _alloca__t46;
    _t46 = &_alloca__t46;
    Lexer_make_token(_t46, _t1, _t45);
    goto L_merge;
L_else:
    _t47 = Lexer_parse_int(_t1);
    _t48 = _t47;
    TokenKind_IntLit(_t48);
    struct Token _alloca__t50;
    _t50 = &_alloca__t50;
    Lexer_make_token(_t50, _t1, _t49);
    goto L_merge;
L_merge:
    _t51 = _t46;
    return;
}

bool Lexer_is_hex_digit(uint8_t _arg0) {
    bool _t1;
    int64_t _t11;
    int64_t _t12;
    int64_t _t13;
    int64_t _t3;
    int64_t _t5;
    int64_t _t6;
    int64_t _t7;
    int64_t _t9;
    uint8_t _t0;
    uint8_t _t10;
    uint8_t _t2;
    uint8_t _t4;
    uint8_t _t8;
    
    _t0 = _arg0;
    _t1 = Lexer_is_digit(_t0);
    _t2 = (uint8_t)65LL;
    _t3 = _t0 >= _t2;
    _t4 = (uint8_t)70LL;
    _t5 = _t0 <= _t4;
    _t6 = _t3 && _t5;
    _t7 = _t1 || _t6;
    _t8 = (uint8_t)97LL;
    _t9 = _t0 >= _t8;
    _t10 = (uint8_t)102LL;
    _t11 = _t0 <= _t10;
    _t12 = _t9 && _t11;
    _t13 = _t7 || _t12;
    return _t13;
}

int64_t Lexer_parse_int(struct Lexer* _arg0) {
    int64_t _t1;
    struct Lexer* _t0;
    uint64_t _t3;
    uint64_t _t4;
    uint64_t* _t2;
    
    _t0 = _arg0;
    _t1 = 0LL;
    _t2 = &_t0->start;
    _t3 = *_t2;
    _t4 = _t3;
    return _t1;
}

int64_t Lexer_parse_hex(struct Lexer* _arg0) {
    int64_t _t1;
    int64_t _t5;
    int64_t _t6;
    struct Lexer* _t0;
    uint64_t _t3;
    uint64_t _t4;
    uint64_t* _t2;
    
    _t0 = _arg0;
    _t1 = 0LL;
    _t2 = &_t0->start;
    _t3 = *_t2;
    _t4 = (uint64_t)2LL;
    _t5 = _t3 + _t4;
    _t6 = _t5;
    return _t1;
}

double Lexer_parse_float(struct Lexer* _arg0) {
    int64_t _t10;
    int64_t _t11;
    int64_t _t12;
    int64_t _t16;
    int64_t _t17;
    int64_t _t18;
    int64_t _t19;
    int64_t _t20;
    int64_t _t5;
    int64_t _t6;
    int64_t _t8;
    int64_t _t9;
    struct Lexer* _t0;
    uint64_t _t14;
    uint64_t _t15;
    uint64_t _t2;
    uint64_t _t4;
    uint64_t _t7;
    uint64_t* _t13;
    uint64_t* _t1;
    uint64_t* _t3;
    
    _t0 = _arg0;
    _t1 = &_t0->pos;
    _t2 = *_t1;
    _t3 = &_t0->start;
    _t4 = *_t3;
    _t5 = _t2 - _t4;
    _t6 = _t5;
    _t7 = (uint64_t)1LL;
    _t8 = _t6 + _t7;
    _t9 = (int64_t)_t8;
    malloc(_t9);
    _t11 = _t10;
    _t12 = 0LL;
    _t13 = &_t0->start;
    _t14 = *_t13;
    _t15 = _t14;
    _t16 = &_t11[_t12];
    _t17 = *_t16;
    _t18 = &_t11[_t12];
    *_t18 = 0LL;
    atof(_t11);
    _t20 = _t19;
    free(_t11);
    return _t20;
}

void Lexer_read_string(struct Token* _arg0, struct Lexer* _arg1) {
    int64_t _t5;
    struct Lexer* _t1;
    struct String* _t3;
    struct String* _t4;
    struct Token* _t0;
    struct Token* _t6;
    uint8_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = Lexer_advance(_t1);
    struct String _alloca__t3;
    _t3 = &_alloca__t3;
    String_new(_t3);
    _t4 = _t3;
    TokenKind_StringLit(_t4);
    struct Token _alloca__t6;
    _t6 = &_alloca__t6;
    Lexer_make_token(_t6, _t1, _t5);
    return;
}

void Lexer_read_char(struct Token* _arg0, struct Lexer* _arg1) {
    int64_t _t11;
    int64_t _t13;
    int64_t _t14;
    int64_t _t17;
    int64_t _t19;
    int64_t _t20;
    int64_t _t22;
    int64_t _t23;
    int64_t _t25;
    int64_t _t26;
    int64_t _t28;
    int64_t _t29;
    int64_t _t31;
    int64_t _t32;
    int64_t _t33;
    int64_t _t35;
    int64_t _t5;
    struct Lexer* _t1;
    struct Token* _t0;
    struct Token* _t36;
    uint8_t _t10;
    uint8_t _t12;
    uint8_t _t15;
    uint8_t _t16;
    uint8_t _t18;
    uint8_t _t21;
    uint8_t _t24;
    uint8_t _t27;
    uint8_t _t2;
    uint8_t _t30;
    uint8_t _t34;
    uint8_t _t3;
    uint8_t _t4;
    uint8_t _t6;
    uint8_t _t7;
    uint8_t _t8;
    uint8_t _t9;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = Lexer_advance(_t1);
    _t3 = Lexer_peek(_t1);
    _t4 = (uint8_t)92LL;
    _t5 = _t3 == _t4;
    if (_t5) goto L_then; else goto L_else;
L_then:
    _t6 = Lexer_advance(_t1);
    _t7 = Lexer_peek(_t1);
    _t8 = _t7;
    _t9 = Lexer_advance(_t1);
    _t10 = (uint8_t)110LL;
    _t11 = _t8 == _t10;
    if (_t11) goto L_then; else goto L_else;
L_else:
    _t12 = Lexer_advance(_t1);
    goto L_merge;
L_merge:
    _t13 = _t20;
    _t14 = _t13;
    _t15 = Lexer_peek(_t1);
    _t16 = (uint8_t)39LL;
    _t17 = _t15 == _t16;
    if (_t17) goto L_then; else goto L_else;
L_then:
    goto L_merge;
L_else:
    _t18 = (uint8_t)114LL;
    _t19 = _t8 == _t18;
    if (_t19) goto L_then; else goto L_else;
L_merge:
    _t20 = 10LL;
    goto L_merge;
L_then:
    goto L_merge;
L_else:
    _t21 = (uint8_t)116LL;
    _t22 = _t8 == _t21;
    if (_t22) goto L_then; else goto L_else;
L_merge:
    _t23 = 13LL;
    goto L_merge;
L_then:
    goto L_merge;
L_else:
    _t24 = (uint8_t)92LL;
    _t25 = _t8 == _t24;
    if (_t25) goto L_then; else goto L_else;
L_merge:
    _t26 = 9LL;
    goto L_merge;
L_then:
    goto L_merge;
L_else:
    _t27 = (uint8_t)39LL;
    _t28 = _t8 == _t27;
    if (_t28) goto L_then; else goto L_else;
L_merge:
    _t29 = 92LL;
    goto L_merge;
L_then:
    goto L_merge;
L_else:
    _t30 = (uint8_t)48LL;
    _t31 = _t8 == _t30;
    if (_t31) goto L_then; else goto L_else;
L_merge:
    _t32 = 39LL;
    goto L_merge;
L_then:
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    _t33 = 0LL;
    goto L_merge;
L_then:
    _t34 = Lexer_advance(_t1);
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    TokenKind_CharLit(_t14);
    struct Token _alloca__t36;
    _t36 = &_alloca__t36;
    Lexer_make_token(_t36, _t1, _t35);
    return;
}

void Lexer_match_operator(struct TokenKind* _arg0, struct Lexer* _arg1, uint8_t _arg2) {
    int64_t _t100;
    int64_t _t102;
    int64_t _t104;
    int64_t _t106;
    int64_t _t108;
    int64_t _t110;
    int64_t _t112;
    int64_t _t114;
    int64_t _t116;
    int64_t _t118;
    int64_t _t119;
    int64_t _t13;
    int64_t _t15;
    int64_t _t19;
    int64_t _t23;
    int64_t _t25;
    int64_t _t29;
    int64_t _t31;
    int64_t _t34;
    int64_t _t37;
    int64_t _t39;
    int64_t _t43;
    int64_t _t47;
    int64_t _t49;
    int64_t _t4;
    int64_t _t53;
    int64_t _t55;
    int64_t _t59;
    int64_t _t63;
    int64_t _t65;
    int64_t _t69;
    int64_t _t73;
    int64_t _t75;
    int64_t _t79;
    int64_t _t7;
    int64_t _t81;
    int64_t _t84;
    int64_t _t87;
    int64_t _t89;
    int64_t _t93;
    int64_t _t95;
    int64_t _t98;
    int64_t _t9;
    struct Lexer* _t1;
    struct TokenKind* _t0;
    uint8_t _t101;
    uint8_t _t103;
    uint8_t _t105;
    uint8_t _t107;
    uint8_t _t109;
    uint8_t _t10;
    uint8_t _t111;
    uint8_t _t113;
    uint8_t _t115;
    uint8_t _t117;
    uint8_t _t11;
    uint8_t _t12;
    uint8_t _t14;
    uint8_t _t16;
    uint8_t _t17;
    uint8_t _t18;
    uint8_t _t20;
    uint8_t _t21;
    uint8_t _t22;
    uint8_t _t24;
    uint8_t _t26;
    uint8_t _t27;
    uint8_t _t28;
    uint8_t _t2;
    uint8_t _t30;
    uint8_t _t32;
    uint8_t _t33;
    uint8_t _t35;
    uint8_t _t36;
    uint8_t _t38;
    uint8_t _t3;
    uint8_t _t40;
    uint8_t _t41;
    uint8_t _t42;
    uint8_t _t44;
    uint8_t _t45;
    uint8_t _t46;
    uint8_t _t48;
    uint8_t _t50;
    uint8_t _t51;
    uint8_t _t52;
    uint8_t _t54;
    uint8_t _t56;
    uint8_t _t57;
    uint8_t _t58;
    uint8_t _t5;
    uint8_t _t60;
    uint8_t _t61;
    uint8_t _t62;
    uint8_t _t64;
    uint8_t _t66;
    uint8_t _t67;
    uint8_t _t68;
    uint8_t _t6;
    uint8_t _t70;
    uint8_t _t71;
    uint8_t _t72;
    uint8_t _t74;
    uint8_t _t76;
    uint8_t _t77;
    uint8_t _t78;
    uint8_t _t80;
    uint8_t _t82;
    uint8_t _t83;
    uint8_t _t85;
    uint8_t _t86;
    uint8_t _t88;
    uint8_t _t8;
    uint8_t _t90;
    uint8_t _t91;
    uint8_t _t92;
    uint8_t _t94;
    uint8_t _t96;
    uint8_t _t97;
    uint8_t _t99;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = (uint8_t)43LL;
    _t4 = _t2 == _t3;
    if (_t4) goto L_then; else goto L_else;
L_then:
    _t5 = Lexer_peek(_t1);
    _t6 = (uint8_t)61LL;
    _t7 = _t5 == _t6;
    if (_t7) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t8 = (uint8_t)45LL;
    _t9 = _t2 == _t8;
    if (_t9) goto L_then; else goto L_else;
L_then:
    _t10 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    _t11 = Lexer_peek(_t1);
    _t12 = (uint8_t)62LL;
    _t13 = _t11 == _t12;
    if (_t13) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t14 = (uint8_t)42LL;
    _t15 = _t2 == _t14;
    if (_t15) goto L_then; else goto L_else;
L_then:
    _t16 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    _t17 = Lexer_peek(_t1);
    _t18 = (uint8_t)61LL;
    _t19 = _t17 == _t18;
    if (_t19) goto L_then; else goto L_else;
L_then:
    _t20 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    _t21 = Lexer_peek(_t1);
    _t22 = (uint8_t)61LL;
    _t23 = _t21 == _t22;
    if (_t23) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t24 = (uint8_t)47LL;
    _t25 = _t2 == _t24;
    if (_t25) goto L_then; else goto L_else;
L_then:
    _t26 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    _t27 = Lexer_peek(_t1);
    _t28 = (uint8_t)61LL;
    _t29 = _t27 == _t28;
    if (_t29) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t30 = (uint8_t)37LL;
    _t31 = _t2 == _t30;
    if (_t31) goto L_then; else goto L_else;
L_then:
    _t32 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t33 = (uint8_t)61LL;
    _t34 = _t2 == _t33;
    if (_t34) goto L_then; else goto L_else;
L_then:
    _t35 = Lexer_peek(_t1);
    _t36 = (uint8_t)61LL;
    _t37 = _t35 == _t36;
    if (_t37) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t38 = (uint8_t)33LL;
    _t39 = _t2 == _t38;
    if (_t39) goto L_then; else goto L_else;
L_then:
    _t40 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    _t41 = Lexer_peek(_t1);
    _t42 = (uint8_t)62LL;
    _t43 = _t41 == _t42;
    if (_t43) goto L_then; else goto L_else;
L_then:
    _t44 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    _t45 = Lexer_peek(_t1);
    _t46 = (uint8_t)61LL;
    _t47 = _t45 == _t46;
    if (_t47) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t48 = (uint8_t)60LL;
    _t49 = _t2 == _t48;
    if (_t49) goto L_then; else goto L_else;
L_then:
    _t50 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    _t51 = Lexer_peek(_t1);
    _t52 = (uint8_t)61LL;
    _t53 = _t51 == _t52;
    if (_t53) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t54 = (uint8_t)62LL;
    _t55 = _t2 == _t54;
    if (_t55) goto L_then; else goto L_else;
L_then:
    _t56 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    _t57 = Lexer_peek(_t1);
    _t58 = (uint8_t)60LL;
    _t59 = _t57 == _t58;
    if (_t59) goto L_then; else goto L_else;
L_then:
    _t60 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    _t61 = Lexer_peek(_t1);
    _t62 = (uint8_t)61LL;
    _t63 = _t61 == _t62;
    if (_t63) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t64 = (uint8_t)38LL;
    _t65 = _t2 == _t64;
    if (_t65) goto L_then; else goto L_else;
L_then:
    _t66 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    _t67 = Lexer_peek(_t1);
    _t68 = (uint8_t)62LL;
    _t69 = _t67 == _t68;
    if (_t69) goto L_then; else goto L_else;
L_then:
    _t70 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    _t71 = Lexer_peek(_t1);
    _t72 = (uint8_t)38LL;
    _t73 = _t71 == _t72;
    if (_t73) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t74 = (uint8_t)124LL;
    _t75 = _t2 == _t74;
    if (_t75) goto L_then; else goto L_else;
L_then:
    _t76 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    _t77 = Lexer_peek(_t1);
    _t78 = (uint8_t)124LL;
    _t79 = _t77 == _t78;
    if (_t79) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t80 = (uint8_t)94LL;
    _t81 = _t2 == _t80;
    if (_t81) goto L_then; else goto L_else;
L_then:
    _t82 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t83 = (uint8_t)46LL;
    _t84 = _t2 == _t83;
    if (_t84) goto L_then; else goto L_else;
L_then:
    _t85 = Lexer_peek(_t1);
    _t86 = (uint8_t)46LL;
    _t87 = _t85 == _t86;
    if (_t87) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t88 = (uint8_t)58LL;
    _t89 = _t2 == _t88;
    if (_t89) goto L_then; else goto L_else;
L_then:
    _t90 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    _t91 = Lexer_peek(_t1);
    _t92 = (uint8_t)58LL;
    _t93 = _t91 == _t92;
    if (_t93) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t94 = (uint8_t)40LL;
    _t95 = _t2 == _t94;
    if (_t95) goto L_then; else goto L_else;
L_then:
    _t96 = Lexer_advance(_t1);
    return;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t97 = (uint8_t)41LL;
    _t98 = _t2 == _t97;
    if (_t98) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t99 = (uint8_t)123LL;
    _t100 = _t2 == _t99;
    if (_t100) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t101 = (uint8_t)125LL;
    _t102 = _t2 == _t101;
    if (_t102) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t103 = (uint8_t)91LL;
    _t104 = _t2 == _t103;
    if (_t104) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t105 = (uint8_t)93LL;
    _t106 = _t2 == _t105;
    if (_t106) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t107 = (uint8_t)44LL;
    _t108 = _t2 == _t107;
    if (_t108) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t109 = (uint8_t)59LL;
    _t110 = _t2 == _t109;
    if (_t110) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t111 = (uint8_t)64LL;
    _t112 = _t2 == _t111;
    if (_t112) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t113 = (uint8_t)35LL;
    _t114 = _t2 == _t113;
    if (_t114) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t115 = (uint8_t)63LL;
    _t116 = _t2 == _t115;
    if (_t116) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t117 = (uint8_t)126LL;
    _t118 = _t2 == _t117;
    if (_t118) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    TokenKind_Unknown(_t2);
    return;
}

void Lexer_next_token(struct Token* _arg0, struct Lexer* _arg1) {
    bool _t12;
    bool _t21;
    bool _t7;
    int64_t _t18;
    int64_t _t27;
    int64_t _t31;
    int64_t _t37;
    int64_t _t41;
    int64_t _t47;
    struct Lexer* _t1;
    struct Span* _t8;
    struct Token* _t0;
    struct Token* _t20;
    struct Token* _t29;
    struct Token* _t39;
    struct Token* _t49;
    struct Token* _t52;
    struct Token* _t9;
    struct TokenKind* _t50;
    struct TokenKind* _t51;
    uint64_t _t14;
    uint64_t _t16;
    uint64_t _t17;
    uint64_t _t23;
    uint64_t _t25;
    uint64_t _t26;
    uint64_t _t33;
    uint64_t _t35;
    uint64_t _t36;
    uint64_t _t3;
    uint64_t _t43;
    uint64_t _t45;
    uint64_t _t46;
    uint64_t _t5;
    uint64_t* _t13;
    uint64_t* _t15;
    uint64_t* _t19;
    uint64_t* _t22;
    uint64_t* _t24;
    uint64_t* _t28;
    uint64_t* _t2;
    uint64_t* _t32;
    uint64_t* _t34;
    uint64_t* _t38;
    uint64_t* _t42;
    uint64_t* _t44;
    uint64_t* _t48;
    uint64_t* _t4;
    uint64_t* _t6;
    uint8_t _t10;
    uint8_t _t11;
    uint8_t _t30;
    uint8_t _t40;
    
    _t0 = _arg0;
    _t1 = _arg1;
    Lexer_skip_whitespace(_t1);
    _t2 = &_t1->start;
    _t3 = *_t2;
    _t4 = &_t1->pos;
    _t5 = *_t4;
    _t6 = &_t1->start;
    *_t6 = _t5;
    _t7 = Lexer_is_at_end(_t1);
    if (_t7) goto L_then; else goto L_else;
L_then:
    struct Span _alloca__t8;
    _t8 = &_alloca__t8;
    Lexer_make_span(_t8, _t1);
    struct Token _alloca__t9;
    _t9 = &_alloca__t9;
    Token_eof(_t9, _t8);
    return;
L_else:
    goto L_merge;
L_merge:
    _t10 = Lexer_advance(_t1);
    _t11 = _t10;
    _t12 = Lexer_is_alpha(_t11);
    if (_t12) goto L_then; else goto L_else;
L_then:
    _t13 = &_t1->pos;
    _t14 = *_t13;
    _t15 = &_t1->pos;
    _t16 = *_t15;
    _t17 = (uint64_t)1LL;
    _t18 = _t16 - _t17;
    _t19 = &_t1->pos;
    *_t19 = _t18;
    struct Token _alloca__t20;
    _t20 = &_alloca__t20;
    Lexer_read_identifier(_t20, _t1);
    return;
L_else:
    goto L_merge;
L_merge:
    _t21 = Lexer_is_digit(_t11);
    if (_t21) goto L_then; else goto L_else;
L_then:
    _t22 = &_t1->pos;
    _t23 = *_t22;
    _t24 = &_t1->pos;
    _t25 = *_t24;
    _t26 = (uint64_t)1LL;
    _t27 = _t25 - _t26;
    _t28 = &_t1->pos;
    *_t28 = _t27;
    struct Token _alloca__t29;
    _t29 = &_alloca__t29;
    Lexer_read_number(_t29, _t1);
    return;
L_else:
    goto L_merge;
L_merge:
    _t30 = (uint8_t)34LL;
    _t31 = _t11 == _t30;
    if (_t31) goto L_then; else goto L_else;
L_then:
    _t32 = &_t1->pos;
    _t33 = *_t32;
    _t34 = &_t1->pos;
    _t35 = *_t34;
    _t36 = (uint64_t)1LL;
    _t37 = _t35 - _t36;
    _t38 = &_t1->pos;
    *_t38 = _t37;
    struct Token _alloca__t39;
    _t39 = &_alloca__t39;
    Lexer_read_string(_t39, _t1);
    return;
L_else:
    goto L_merge;
L_merge:
    _t40 = (uint8_t)39LL;
    _t41 = _t11 == _t40;
    if (_t41) goto L_then; else goto L_else;
L_then:
    _t42 = &_t1->pos;
    _t43 = *_t42;
    _t44 = &_t1->pos;
    _t45 = *_t44;
    _t46 = (uint64_t)1LL;
    _t47 = _t45 - _t46;
    _t48 = &_t1->pos;
    *_t48 = _t47;
    struct Token _alloca__t49;
    _t49 = &_alloca__t49;
    Lexer_read_char(_t49, _t1);
    return;
L_else:
    goto L_merge;
L_merge:
    struct TokenKind _alloca__t50;
    _t50 = &_alloca__t50;
    Lexer_match_operator(_t50, _t1, _t11);
    _t51 = _t50;
    struct Token _alloca__t52;
    _t52 = &_alloca__t52;
    Lexer_make_token(_t52, _t1, _t51);
    return;
}

void Lexer_tokenize(struct VecToken* _arg0, struct Lexer* _arg1) {
    int64_t _t4;
    struct Lexer* _t1;
    struct VecToken* _t0;
    struct VecToken* _t2;
    struct VecToken* _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct VecToken _alloca__t2;
    _t2 = &_alloca__t2;
    VecToken_new(_t2);
    _t3 = _t2;
    _t4 = 0LL;
    return;
}

void main(void) {
    int64_t _t0;
    
    printf("Hello from Lexer!\n");
    return;
}

