// AetherLang IR to LLVM Converter
// Converts AetherLang IR to LLVM IR for native code generation

extern "C" {
    fn puts(s: *u8) -> i32;
    fn malloc(size: u64) -> *void;
    fn free(ptr: *void);
}

// LLVM FFI imports (subset)
extern "C" {
    // Context
    fn LLVMContextCreate() -> *void;
    fn LLVMContextDispose(ctx: *void);

    // Module
    fn LLVMModuleCreateWithNameInContext(name: *u8, ctx: *void) -> *void;
    fn LLVMDisposeModule(m: *void);
    fn LLVMSetTarget(m: *void, triple: *u8);
    fn LLVMPrintModuleToString(m: *void) -> *u8;
    fn LLVMDisposeMessage(msg: *u8);

    // Types
    fn LLVMVoidTypeInContext(ctx: *void) -> *void;
    fn LLVMInt1TypeInContext(ctx: *void) -> *void;
    fn LLVMInt8TypeInContext(ctx: *void) -> *void;
    fn LLVMInt16TypeInContext(ctx: *void) -> *void;
    fn LLVMInt32TypeInContext(ctx: *void) -> *void;
    fn LLVMInt64TypeInContext(ctx: *void) -> *void;
    fn LLVMFloatTypeInContext(ctx: *void) -> *void;
    fn LLVMDoubleTypeInContext(ctx: *void) -> *void;
    fn LLVMPointerType(elem: *void, addr_space: u32) -> *void;
    fn LLVMFunctionType(ret: *void, params: **void, count: u32, vararg: i32) -> *void;
    fn LLVMStructCreateNamed(ctx: *void, name: *u8) -> *void;
    fn LLVMStructSetBody(struct_ty: *void, elems: **void, elem_count: u32, packed: i32);
    fn LLVMGetTypeByName2(ctx: *void, name: *u8) -> *void;
    
    // Builder
    fn LLVMCreateBuilderInContext(ctx: *void) -> *void;
    fn LLVMDisposeBuilder(b: *void);
    fn LLVMPositionBuilderAtEnd(b: *void, block: *void);
    
    // Functions
    fn LLVMAddFunction(m: *void, name: *u8, ty: *void) -> *void;
    fn LLVMGetParam(func: *void, idx: u32) -> *void;
    
    // Basic Blocks
    fn LLVMAppendBasicBlockInContext(ctx: *void, func: *void, name: *u8) -> *void;
    
    // Constants
    fn LLVMConstInt(ty: *void, n: u64, sign_extend: i32) -> *void;
    fn LLVMConstReal(ty: *void, n: f64) -> *void;
    fn LLVMConstNull(ty: *void) -> *void;
    
    // Instructions - Arithmetic
    fn LLVMBuildAdd(b: *void, lhs: *void, rhs: *void, name: *u8) -> *void;
    fn LLVMBuildSub(b: *void, lhs: *void, rhs: *void, name: *u8) -> *void;
    fn LLVMBuildMul(b: *void, lhs: *void, rhs: *void, name: *u8) -> *void;
    fn LLVMBuildSDiv(b: *void, lhs: *void, rhs: *void, name: *u8) -> *void;
    fn LLVMBuildSRem(b: *void, lhs: *void, rhs: *void, name: *u8) -> *void;
    
    // Instructions - Bitwise
    fn LLVMBuildAnd(b: *void, lhs: *void, rhs: *void, name: *u8) -> *void;
    fn LLVMBuildOr(b: *void, lhs: *void, rhs: *void, name: *u8) -> *void;
    fn LLVMBuildXor(b: *void, lhs: *void, rhs: *void, name: *u8) -> *void;
    fn LLVMBuildShl(b: *void, lhs: *void, rhs: *void, name: *u8) -> *void;
    fn LLVMBuildAShr(b: *void, lhs: *void, rhs: *void, name: *u8) -> *void;
    
    // Instructions - Comparison
    fn LLVMBuildICmp(b: *void, op: i32, lhs: *void, rhs: *void, name: *u8) -> *void;
    
    // Instructions - Memory
    fn LLVMBuildAlloca(b: *void, ty: *void, name: *u8) -> *void;
    fn LLVMBuildLoad2(b: *void, ty: *void, ptr: *void, name: *u8) -> *void;
    fn LLVMBuildStore(b: *void, val: *void, ptr: *void) -> *void;
    fn LLVMBuildGEP2(b: *void, ty: *void, ptr: *void, indices: **void, num: u32, name: *u8) -> *void;
    
    // Instructions - Control Flow
    fn LLVMBuildBr(b: *void, dest: *void) -> *void;
    fn LLVMBuildCondBr(b: *void, cond: *void, then_bb: *void, else_bb: *void) -> *void;
    fn LLVMBuildRet(b: *void, val: *void) -> *void;
    fn LLVMBuildRetVoid(b: *void) -> *void;
    fn LLVMBuildCall2(b: *void, ty: *void, func: *void, args: **void, num: u32, name: *u8) -> *void;
    
    // Instructions - Conversion
    fn LLVMBuildZExt(b: *void, val: *void, ty: *void, name: *u8) -> *void;
    fn LLVMBuildSExt(b: *void, val: *void, ty: *void, name: *u8) -> *void;
    fn LLVMBuildTrunc(b: *void, val: *void, ty: *void, name: *u8) -> *void;
    fn LLVMBuildBitCast(b: *void, val: *void, ty: *void, name: *u8) -> *void;
    fn LLVMBuildGlobalStringPtr(b: *void, str: *u8, name: *u8) -> *void;
    
    // Target
    fn LLVMInitializeAllTargetInfos();
    fn LLVMInitializeAllTargets();
    fn LLVMInitializeAllTargetMCs();
    fn LLVMInitializeAllAsmPrinters();
    fn LLVMGetDefaultTargetTriple() -> *u8;
    fn LLVMGetTargetFromTriple(triple: *u8, target: **void, error: **u8) -> i32;
    fn LLVMCreateTargetMachine(
        target: *void, triple: *u8, cpu: *u8, features: *u8,
        level: i32, reloc: i32, code_model: i32
    ) -> *void;
    fn LLVMTargetMachineEmitToFile(
        tm: *void, m: *void, filename: *u8, codegen: i32, error: **u8
    ) -> i32;
    fn LLVMDisposeTargetMachine(tm: *void);
}

// ICmp predicates (matches LLVMIntPredicate from llvm-c/Core.h)
const LLVMIntEQ: i32 = 32
const LLVMIntNE: i32 = 33
const LLVMIntSGT: i32 = 38
const LLVMIntSGE: i32 = 39
const LLVMIntSLT: i32 = 40
const LLVMIntSLE: i32 = 41

// ==================== Simple Map (fixed-size for bootstrap) ====================

const MAX_VALUES: u64 = 1024
const MAX_BLOCKS: u64 = 256

pub struct ValueMap {
    keys: [u64; 1024],
    values: [*void; 1024],
    len: u64,
}

impl ValueMap {
    pub fn new() -> ValueMap {
        return ValueMap {
            keys: [0; 1024],
            values: [0 as *void; 1024],
            len: 0,
        };
    }

    pub fn set(self: *ValueMap, key: u64, val: *void) {
        // Check if key exists
        let mut i: u64 = 0;
        while i < (*self).len {
            if (*self).keys[i] == key {
                (*self).values[i] = val;
                return;
            }
            i = i + 1;
        }
        // Add new entry
        if (*self).len < MAX_VALUES {
            (*self).keys[(*self).len] = key;
            (*self).values[(*self).len] = val;
            (*self).len = (*self).len + 1;
        }
    }

    pub fn get(self: *ValueMap, key: u64) -> *void {
        let mut i: u64 = 0;
        while i < (*self).len {
            if (*self).keys[i] == key {
                return (*self).values[i];
            }
            i = i + 1;
        }
        return 0 as *void;
    }

    pub fn clear(self: *ValueMap) {
        (*self).len = 0;
    }
}

pub struct BlockMap {
    keys: [u64; 256],
    values: [*void; 256],
    len: u64,
}

impl BlockMap {
    pub fn new() -> BlockMap {
        return BlockMap {
            keys: [0; 256],
            values: [0 as *void; 256],
            len: 0,
        };
    }

    pub fn set(self: *BlockMap, key: u64, val: *void) {
        let mut i: u64 = 0;
        while i < (*self).len {
            if (*self).keys[i] == key {
                (*self).values[i] = val;
                return;
            }
            i = i + 1;
        }
        if (*self).len < MAX_BLOCKS {
            (*self).keys[(*self).len] = key;
            (*self).values[(*self).len] = val;
            (*self).len = (*self).len + 1;
        }
    }

    pub fn get(self: *BlockMap, key: u64) -> *void {
        let mut i: u64 = 0;
        while i < (*self).len {
            if (*self).keys[i] == key {
                return (*self).values[i];
            }
            i = i + 1;
        }
        return 0 as *void;
    }

    pub fn clear(self: *BlockMap) {
        (*self).len = 0;
    }
}

// ==================== IR to LLVM Converter ====================

pub struct IRToLLVM {
    context: *void,
    module: *void,
    builder: *void,
    current_func: *void,
    target_triple: *u8,
    // Value map: register id -> LLVM value
    value_map: ValueMap,
    // Block map: block id -> LLVM basic block
    block_map: BlockMap,
}

impl IRToLLVM {
    /// Create a new IR to LLVM converter
    pub fn new(module_name: *u8, target: *u8) -> IRToLLVM {
        // Initialize LLVM targets
        LLVMInitializeAllTargetInfos();
        LLVMInitializeAllTargets();
        LLVMInitializeAllTargetMCs();
        LLVMInitializeAllAsmPrinters();
        
        let ctx = LLVMContextCreate();
        let m = LLVMModuleCreateWithNameInContext(module_name, ctx);
        let b = LLVMCreateBuilderInContext(ctx);
        
        LLVMSetTarget(m, target);
        
        return IRToLLVM {
            context: ctx,
            module: m,
            builder: b,
            current_func: 0 as *void,
            target_triple: target,
            value_map: ValueMap::new(),
            block_map: BlockMap::new(),
        };
    }

    /// Dispose of resources
    pub fn dispose(self: *IRToLLVM) {
        if (*self).builder != (0 as *void) {
            LLVMDisposeBuilder((*self).builder);
        }
        if (*self).module != (0 as *void) {
            LLVMDisposeModule((*self).module);
        }
        if (*self).context != (0 as *void) {
            LLVMContextDispose((*self).context);
        }
    }

    // ==================== Value/Block Map Operations ====================

    /// Register a value (IR register -> LLVM value)
    pub fn set_value(self: *IRToLLVM, reg_id: u64, llvm_val: *void) {
        (*self).value_map.set(reg_id, llvm_val);
    }

    /// Get LLVM value for an IR register
    pub fn get_value(self: *IRToLLVM, reg_id: u64) -> *void {
        return (*self).value_map.get(reg_id);
    }

    /// Register a block (IR block id -> LLVM basic block)
    pub fn set_block(self: *IRToLLVM, block_id: u64, llvm_bb: *void) {
        (*self).block_map.set(block_id, llvm_bb);
    }

    /// Get LLVM basic block for an IR block id
    pub fn get_block(self: *IRToLLVM, block_id: u64) -> *void {
        return (*self).block_map.get(block_id);
    }

    /// Create and register a new block
    pub fn create_and_register_block(self: *IRToLLVM, block_id: u64, name: *u8) -> *void {
        let bb: *void = LLVMAppendBasicBlockInContext((*self).context, (*self).current_func, name);
        (*self).set_block(block_id, bb);
        return bb;
    }

    /// Clear maps for new function
    pub fn clear_function_state(self: *IRToLLVM) {
        (*self).value_map.clear();
        (*self).block_map.clear();
    }
    
    // ==================== Type Conversion ====================
    
    /// Convert IR type ID to LLVM type
    /// Type IDs: 0=I8, 1=I16, 2=I32, 3=I64, 4=U8..., 8=Bool, 9=Void, 10=Ptr
    pub fn ir_type_to_llvm(self: *IRToLLVM, type_id: u8) -> *void {
        let ctx = (*self).context;
        
        if type_id == 0 {
            return LLVMInt8TypeInContext(ctx);
        } else if type_id == 1 {
            return LLVMInt16TypeInContext(ctx);
        } else if type_id == 2 {
            return LLVMInt32TypeInContext(ctx);
        } else if type_id == 3 {
            return LLVMInt64TypeInContext(ctx);
        } else if type_id == 4 {
            return LLVMInt8TypeInContext(ctx);  // U8
        } else if type_id == 5 {
            return LLVMInt16TypeInContext(ctx); // U16
        } else if type_id == 6 {
            return LLVMInt32TypeInContext(ctx); // U32
        } else if type_id == 7 {
            return LLVMInt64TypeInContext(ctx); // U64
        } else if type_id == 8 {
            return LLVMInt1TypeInContext(ctx);  // Bool
        } else if type_id == 9 {
            return LLVMVoidTypeInContext(ctx);  // Void
        } else if type_id == 10 {
            // Ptr - default to i8*
            let i8_ty = LLVMInt8TypeInContext(ctx);
            return LLVMPointerType(i8_ty, 0);
        }
        
        // Default to i64
        return LLVMInt64TypeInContext(ctx);
    }
    
    /// Get i64 type
    pub fn i64_type(self: *IRToLLVM) -> *void {
        return LLVMInt64TypeInContext((*self).context);
    }
    
    /// Get i32 type
    pub fn i32_type(self: *IRToLLVM) -> *void {
        return LLVMInt32TypeInContext((*self).context);
    }
    
    /// Get i1 (bool) type
    pub fn bool_type(self: *IRToLLVM) -> *void {
        return LLVMInt1TypeInContext((*self).context);
    }
    
    /// Get void type
    pub fn void_type(self: *IRToLLVM) -> *void {
        return LLVMVoidTypeInContext((*self).context);
    }
    
    /// Get pointer type
    pub fn ptr_type(self: *IRToLLVM, elem: *void) -> *void {
        return LLVMPointerType(elem, 0);
    }
    
    // ==================== Function Generation ====================
    
    /// Add a function to the module
    pub fn add_function(self: *IRToLLVM, name: *u8, ret_type: *void, param_types: **void, param_count: u32) -> *void {
        let func_ty = LLVMFunctionType(ret_type, param_types, param_count, 0);
        let func = LLVMAddFunction((*self).module, name, func_ty);
        (*self).current_func = func;
        return func;
    }
    
    /// Create a basic block
    pub fn create_block(self: *IRToLLVM, name: *u8) -> *void {
        return LLVMAppendBasicBlockInContext((*self).context, (*self).current_func, name);
    }
    
    /// Position builder at end of block
    pub fn position_at_end(self: *IRToLLVM, block: *void) {
        LLVMPositionBuilderAtEnd((*self).builder, block);
    }
    
    // ==================== Instruction Generation ====================
    
    /// Generate binary operation
    /// op: 0=Add, 1=Sub, 2=Mul, 3=Div, 4=Rem, 5=And, 6=Or, 7=Xor, 8=Shl, 9=Shr, 10=Eq, 11=Ne, 12=Lt, 13=Le, 14=Gt, 15=Ge
    pub fn gen_binop(self: *IRToLLVM, op: u8, lhs: *void, rhs: *void, name: *u8) -> *void {
        let b = (*self).builder;
        
        if op == 0 {
            return LLVMBuildAdd(b, lhs, rhs, name);
        } else if op == 1 {
            return LLVMBuildSub(b, lhs, rhs, name);
        } else if op == 2 {
            return LLVMBuildMul(b, lhs, rhs, name);
        } else if op == 3 {
            return LLVMBuildSDiv(b, lhs, rhs, name);
        } else if op == 4 {
            return LLVMBuildSRem(b, lhs, rhs, name);
        } else if op == 5 {
            return LLVMBuildAnd(b, lhs, rhs, name);
        } else if op == 6 {
            return LLVMBuildOr(b, lhs, rhs, name);
        } else if op == 7 {
            return LLVMBuildXor(b, lhs, rhs, name);
        } else if op == 8 {
            return LLVMBuildShl(b, lhs, rhs, name);
        } else if op == 9 {
            return LLVMBuildAShr(b, lhs, rhs, name);
        } else if op == 10 {
            return LLVMBuildICmp(b, LLVMIntEQ, lhs, rhs, name);
        } else if op == 11 {
            return LLVMBuildICmp(b, LLVMIntNE, lhs, rhs, name);
        } else if op == 12 {
            return LLVMBuildICmp(b, LLVMIntSLT, lhs, rhs, name);
        } else if op == 13 {
            return LLVMBuildICmp(b, LLVMIntSLE, lhs, rhs, name);
        } else if op == 14 {
            return LLVMBuildICmp(b, LLVMIntSGT, lhs, rhs, name);
        } else if op == 15 {
            return LLVMBuildICmp(b, LLVMIntSGE, lhs, rhs, name);
        }
        
        // Default: add
        return LLVMBuildAdd(b, lhs, rhs, name);
    }
    
    /// Generate alloca
    pub fn gen_alloca(self: *IRToLLVM, ty: *void, name: *u8) -> *void {
        return LLVMBuildAlloca((*self).builder, ty, name);
    }
    
    /// Generate load
    pub fn gen_load(self: *IRToLLVM, ty: *void, ptr: *void, name: *u8) -> *void {
        return LLVMBuildLoad2((*self).builder, ty, ptr, name);
    }
    
    /// Generate store
    pub fn gen_store(self: *IRToLLVM, val: *void, ptr: *void) {
        LLVMBuildStore((*self).builder, val, ptr);
    }
    
    /// Generate branch
    pub fn gen_br(self: *IRToLLVM, dest: *void) {
        LLVMBuildBr((*self).builder, dest);
    }
    
    /// Generate conditional branch
    pub fn gen_cond_br(self: *IRToLLVM, cond: *void, then_bb: *void, else_bb: *void) {
        LLVMBuildCondBr((*self).builder, cond, then_bb, else_bb);
    }
    
    /// Generate return
    pub fn gen_ret(self: *IRToLLVM, val: *void) {
        LLVMBuildRet((*self).builder, val);
    }
    
    /// Generate return void
    pub fn gen_ret_void(self: *IRToLLVM) {
        LLVMBuildRetVoid((*self).builder);
    }
    
    /// Generate function call
    pub fn gen_call(self: *IRToLLVM, func_ty: *void, func: *void, args: **void, arg_count: u32, name: *u8) -> *void {
        return LLVMBuildCall2((*self).builder, func_ty, func, args, arg_count, name);
    }
    
    // ==================== Constants ====================
    
    /// Generate i64 constant
    pub fn const_i64(self: *IRToLLVM, n: i64) -> *void {
        let ty = (*self).i64_type();
        return LLVMConstInt(ty, n as u64, 1);
    }
    
    /// Generate i32 constant
    pub fn const_i32(self: *IRToLLVM, n: i32) -> *void {
        let ty = (*self).i32_type();
        return LLVMConstInt(ty, n as u64, 1);
    }
    
    /// Generate bool constant
    pub fn const_bool(self: *IRToLLVM, b: bool) -> *void {
        let ty = (*self).bool_type();
        let val: u64 = if b { 1 } else { 0 };
        return LLVMConstInt(ty, val, 0);
    }
    
    /// Generate global string
    pub fn const_string(self: *IRToLLVM, s: *u8, name: *u8) -> *void {
        return LLVMBuildGlobalStringPtr((*self).builder, s, name);
    }

    // ==================== Struct Type Generation ====================

    /// Create or get a named struct type
    /// If is_repr_c is true, the struct will use packed=1 for C-compatible layout
    pub fn create_struct_type(self: *IRToLLVM, name: *u8, field_types: **void, field_count: u32, is_repr_c: bool) -> *void {
        let ctx = (*self).context;

        // Check if struct already exists
        let existing = LLVMGetTypeByName2(ctx, name);
        if existing != (0 as *void) {
            return existing;
        }

        // Create named struct
        let struct_ty = LLVMStructCreateNamed(ctx, name);

        // Set struct body with appropriate packing
        // For #[repr(C)], we use packed=0 (natural C alignment)
        // For #[repr(Packed)], we would use packed=1 (no padding)
        // Note: repr(C) means "use C ABI layout" which is actually packed=0
        let packed: i32 = if is_repr_c { 0 } else { 0 };
        LLVMStructSetBody(struct_ty, field_types, field_count, packed);

        return struct_ty;
    }

    /// Create struct type for #[repr(Packed)]
    pub fn create_packed_struct_type(self: *IRToLLVM, name: *u8, field_types: **void, field_count: u32) -> *void {
        let ctx = (*self).context;

        let existing = LLVMGetTypeByName2(ctx, name);
        if existing != (0 as *void) {
            return existing;
        }

        let struct_ty = LLVMStructCreateNamed(ctx, name);
        LLVMStructSetBody(struct_ty, field_types, field_count, 1);  // packed=1

        return struct_ty;
    }

    // ==================== Output ====================

    /// Print LLVM IR to stdout
    pub fn print_ir(self: *IRToLLVM) {
        let ir = LLVMPrintModuleToString((*self).module);
        puts(ir);
        LLVMDisposeMessage(ir);
    }
    
    /// Get the LLVM module
    pub fn get_module(self: *IRToLLVM) -> *void {
        return (*self).module;
    }

    // ==================== Control Flow Generation ====================

    /// Generate LLVM IR for while loop
    /// Returns the exit block for continuation
    pub fn gen_while(self: *IRToLLVM, cond_val: *void, body_fn: u64) -> *void {
        let cond_block: *void = (*self).create_block("while.cond\0" as *u8);
        let body_block: *void = (*self).create_block("while.body\0" as *u8);
        let exit_block: *void = (*self).create_block("while.exit\0" as *u8);

        // Branch to condition
        (*self).gen_br(cond_block);

        // Condition block
        (*self).position_at_end(cond_block);
        // Evaluate condition (would call body_fn or get from context)
        (*self).gen_cond_br(cond_val, body_block, exit_block);

        // Body block
        (*self).position_at_end(body_block);
        // Body would be generated here
        (*self).gen_br(cond_block);

        // Continue at exit
        (*self).position_at_end(exit_block);

        return exit_block;
    }

    /// Generate LLVM IR for infinite loop
    pub fn gen_loop(self: *IRToLLVM) -> *void {
        let body_block: *void = (*self).create_block("loop.body\0" as *u8);
        let exit_block: *void = (*self).create_block("loop.exit\0" as *u8);

        // Branch to body
        (*self).gen_br(body_block);

        // Body block
        (*self).position_at_end(body_block);
        // Body would be generated here, with break jumping to exit_block
        (*self).gen_br(body_block); // Loop back

        // Exit block (reached via break)
        (*self).position_at_end(exit_block);

        return exit_block;
    }

    /// Generate LLVM IR for for loop (desugared to while)
    pub fn gen_for(self: *IRToLLVM, start_val: *void, end_val: *void, step_val: *void) -> *void {
        let init_block: *void = (*self).create_block("for.init\0" as *u8);
        let cond_block: *void = (*self).create_block("for.cond\0" as *u8);
        let body_block: *void = (*self).create_block("for.body\0" as *u8);
        let incr_block: *void = (*self).create_block("for.incr\0" as *u8);
        let exit_block: *void = (*self).create_block("for.exit\0" as *u8);

        // Branch to init
        (*self).gen_br(init_block);

        // Init block: allocate and initialize loop variable
        (*self).position_at_end(init_block);
        let i64_ty: *void = (*self).i64_type();
        let loop_var: *void = (*self).gen_alloca(i64_ty, "i\0" as *u8);
        (*self).gen_store(start_val, loop_var);
        (*self).gen_br(cond_block);

        // Condition block: compare with end
        (*self).position_at_end(cond_block);
        let current: *void = (*self).gen_load(i64_ty, loop_var, "cur\0" as *u8);
        let cmp: *void = (*self).gen_binop(12, current, end_val, "cmp\0" as *u8); // Lt
        (*self).gen_cond_br(cmp, body_block, exit_block);

        // Body block
        (*self).position_at_end(body_block);
        // Body would be generated here
        (*self).gen_br(incr_block);

        // Increment block
        (*self).position_at_end(incr_block);
        let cur2: *void = (*self).gen_load(i64_ty, loop_var, "cur2\0" as *u8);
        let next: *void = (*self).gen_binop(0, cur2, step_val, "next\0" as *u8); // Add
        (*self).gen_store(next, loop_var);
        (*self).gen_br(cond_block);

        // Exit block
        (*self).position_at_end(exit_block);

        return exit_block;
    }

    /// Generate LLVM IR for match expression
    /// scrutinee: the value being matched
    /// arm_count: number of match arms
    pub fn gen_match(self: *IRToLLVM, scrutinee: *void, arm_count: u64) -> *void {
        let exit_block: *void = (*self).create_block("match.exit\0" as *u8);

        // Allocate result variable
        let i64_ty: *void = (*self).i64_type();
        let result_ptr: *void = (*self).gen_alloca(i64_ty, "match.result\0" as *u8);

        // Generate comparison chain for each arm
        let mut i: u64 = 0;
        let mut current_block: *void = 0 as *void;

        while i < arm_count {
            let arm_check: *void = (*self).create_block("match.arm\0" as *u8);
            let arm_body: *void = (*self).create_block("match.body\0" as *u8);
            let next_arm: *void = (*self).create_block("match.next\0" as *u8);

            if i == 0 {
                (*self).gen_br(arm_check);
            }

            // Check pattern
            (*self).position_at_end(arm_check);
            let pattern_val: *void = (*self).const_i64(i as i64);
            let cmp: *void = (*self).gen_binop(10, scrutinee, pattern_val, "eq\0" as *u8); // Eq

            // Last arm is wildcard - unconditional
            if i == arm_count - 1 {
                (*self).gen_br(arm_body);
            } else {
                (*self).gen_cond_br(cmp, arm_body, next_arm);
            }

            // Arm body
            (*self).position_at_end(arm_body);
            let arm_result: *void = (*self).const_i64((i as i64) * 100 + 100);
            (*self).gen_store(arm_result, result_ptr);
            (*self).gen_br(exit_block);

            // Setup for next arm
            (*self).position_at_end(next_arm);
            current_block = next_arm;

            i = i + 1;
        }

        // Exit block
        (*self).position_at_end(exit_block);
        let result: *void = (*self).gen_load(i64_ty, result_ptr, "result\0" as *u8);

        return result;
    }

    /// Generate LLVM IR for if expression
    pub fn gen_if(self: *IRToLLVM, cond: *void, has_else: bool) -> *void {
        let then_block: *void = (*self).create_block("if.then\0" as *u8);
        let else_block: *void = (*self).create_block("if.else\0" as *u8);
        let merge_block: *void = (*self).create_block("if.merge\0" as *u8);

        // Conditional branch
        (*self).gen_cond_br(cond, then_block, else_block);

        // Then block
        (*self).position_at_end(then_block);
        // Then body would be generated here
        (*self).gen_br(merge_block);

        // Else block
        (*self).position_at_end(else_block);
        if has_else {
            // Else body would be generated here
        }
        (*self).gen_br(merge_block);

        // Merge block
        (*self).position_at_end(merge_block);

        return merge_block;
    }

    // ==================== Closure Generation ====================

    /// Generate LLVM IR for closure
    /// Creates: 1. Environment struct, 2. Closure function, 3. Closure object
    pub fn gen_closure(self: *IRToLLVM, capture_count: u64, param_count: u64) -> *void {
        let i64_ty: *void = (*self).i64_type();
        let ptr_ty: *void = (*self).ptr_type(i64_ty);

        // Allocate closure struct: { env*, fn* }
        let closure_ptr: *void = (*self).gen_alloca(i64_ty, "closure\0" as *u8);

        if capture_count > 0 {
            // Allocate environment
            let env_ptr: *void = (*self).gen_alloca(i64_ty, "env\0" as *u8);

            // Copy captures into environment
            let mut i: u64 = 0;
            while i < capture_count {
                // Would store each captured variable
                let captured: *void = (*self).const_i64(i as i64);
                (*self).gen_store(captured, env_ptr);
                i = i + 1;
            }

            // Store env in closure
            (*self).gen_store(env_ptr, closure_ptr);
        }

        // Function pointer would be stored here
        // In real impl, would generate a thunk function

        return closure_ptr;
    }

    /// Generate LLVM IR for closure call
    pub fn gen_closure_call(self: *IRToLLVM, closure: *void, args: **void, arg_count: u32) -> *void {
        // Load function pointer from closure
        let i64_ty: *void = (*self).i64_type();
        let fn_ptr: *void = (*self).gen_load(i64_ty, closure, "fn\0" as *u8);

        // Load environment pointer
        // let env_ptr = ... (would be at offset 1)

        // Call with env as first argument
        // In real impl, would prepend env to args
        let func_ty: *void = LLVMFunctionType(i64_ty, 0 as **void, 0, 0);
        return (*self).gen_call(func_ty, fn_ptr, args, arg_count, "call\0" as *u8);
    }

    // ==================== Array/Tuple Generation ====================

    /// Generate LLVM IR for array literal
    pub fn gen_array(self: *IRToLLVM, elements: **void, elem_count: u32) -> *void {
        let i64_ty: *void = (*self).i64_type();

        // Allocate array
        let array_ptr: *void = (*self).gen_alloca(i64_ty, "array\0" as *u8);

        // Store each element (simplified - would use GEP in real impl)
        let mut i: u32 = 0;
        while i < elem_count {
            // Would compute GEP and store
            i = i + 1;
        }

        return array_ptr;
    }

    /// Generate LLVM IR for array index access
    pub fn gen_array_index(self: *IRToLLVM, array: *void, index: *void) -> *void {
        let i64_ty: *void = (*self).i64_type();

        // GEP to element
        let elem_ptr: *void = LLVMBuildGEP2(
            (*self).builder, i64_ty, array,
            &index as **void, 1, "elem\0" as *u8
        );

        // Load element
        return (*self).gen_load(i64_ty, elem_ptr, "val\0" as *u8);
    }

    // ==================== IR Module Conversion ====================

    /// Convert an entire IR module to LLVM IR
    pub fn convert_module(self: *IRToLLVM, ir_module: *ir_gen::IRModule) {
        if ir_module == (0 as *ir_gen::IRModule) {
            return;
        }

        let func_count: u64 = (*ir_module).func_count;
        let mut i: u64 = 0;

        while i < func_count {
            let ir_func: *ir_gen::IRFunction = (*ir_module).get_function(i);
            if ir_func != (0 as *ir_gen::IRFunction) {
                (*self).convert_function(ir_func);
            }
            i = i + 1;
        }
    }

    /// Convert an IR function to LLVM
    pub fn convert_function(self: *IRToLLVM, ir_func: *ir_gen::IRFunction) {
        if ir_func == (0 as *ir_gen::IRFunction) {
            return;
        }

        // Clear function state
        (*self).clear_function_state();

        // Get function info
        let name: *u8 = (*ir_func).name;
        let ret_type: *void = (*self).ir_type_to_llvm((*ir_func).return_type as u8);

        // Create LLVM function (no params for now)
        let func: *void = (*self).add_function(name, ret_type, 0 as **void, 0);
        (*self).current_func = func;

        // Create all basic blocks first (for forward references)
        let block_count: u64 = (*ir_func).block_count;
        let mut i: u64 = 0;
        while i < block_count {
            let ir_block: *ir_gen::BasicBlock = (*ir_func).get_block(i);
            if ir_block != (0 as *ir_gen::BasicBlock) {
                let label: *u8 = (*ir_block).label;
                let llvm_bb: *void = (*self).create_and_register_block(i, label);
            }
            i = i + 1;
        }

        // Generate code for each block
        i = 0;
        while i < block_count {
            let ir_block: *ir_gen::BasicBlock = (*ir_func).get_block(i);
            if ir_block != (0 as *ir_gen::BasicBlock) {
                (*self).convert_block(ir_block);
            }
            i = i + 1;
        }
    }

    /// Convert an IR basic block to LLVM
    pub fn convert_block(self: *IRToLLVM, ir_block: *ir_gen::BasicBlock) {
        if ir_block == (0 as *ir_gen::BasicBlock) {
            return;
        }

        // Position builder at this block
        let block_id: u64 = (*ir_block).id;
        let llvm_bb: *void = (*self).get_block(block_id);
        if llvm_bb == (0 as *void) {
            return;
        }
        (*self).position_at_end(llvm_bb);

        // Convert all instructions
        let instr_count: u64 = (*ir_block).instructions.len;
        let mut i: u64 = 0;
        while i < instr_count {
            let instr: *ir_gen::Instruction = (*ir_block).instructions.get(i);
            if instr != (0 as *ir_gen::Instruction) {
                (*self).convert_instruction(instr);
            }
            i = i + 1;
        }

        // Convert terminator
        if (*ir_block).has_terminator {
            (*self).convert_terminator(&(*ir_block).terminator);
        }
    }

    /// Convert an IR instruction to LLVM
    pub fn convert_instruction(self: *IRToLLVM, instr: *ir_gen::Instruction) {
        if instr == (0 as *ir_gen::Instruction) {
            return;
        }

        let kind: ir_gen::InstrKind = (*instr).kind;
        let dest: u64 = (*instr).dest;

        if kind == ir_gen::InstrKind::BinOp {
            // Binary operation
            let lhs: *void = (*self).convert_value(&(*instr).src1);
            let rhs: *void = (*self).convert_value(&(*instr).src2);
            let op: u8 = (*self).convert_binop((*instr).op);
            let result: *void = (*self).gen_binop(op, lhs, rhs, "binop\0" as *u8);
            (*self).set_value(dest, result);

        } else if kind == ir_gen::InstrKind::Alloca {
            // Stack allocation
            let i64_ty: *void = (*self).i64_type();
            let result: *void = (*self).gen_alloca(i64_ty, "alloca\0" as *u8);
            (*self).set_value(dest, result);

        } else if kind == ir_gen::InstrKind::Load {
            // Load from pointer
            let ptr: *void = (*self).convert_value(&(*instr).src1);
            let i64_ty: *void = (*self).i64_type();
            let result: *void = (*self).gen_load(i64_ty, ptr, "load\0" as *u8);
            (*self).set_value(dest, result);

        } else if kind == ir_gen::InstrKind::Store {
            // Store to pointer
            let ptr: *void = (*self).convert_value(&(*instr).src1);
            let val: *void = (*self).convert_value(&(*instr).src2);
            (*self).gen_store(val, ptr);
        }
        // Other instruction kinds can be added as needed
    }

    /// Convert an IR value to LLVM value
    pub fn convert_value(self: *IRToLLVM, val: *ir_gen::Value) -> *void {
        if val == (0 as *ir_gen::Value) {
            return (*self).const_i64(0);
        }

        let kind: ir_gen::ValueKind = (*val).kind;

        if kind == ir_gen::ValueKind::Constant {
            return (*self).const_i64((*val).int_val);
        } else if kind == ir_gen::ValueKind::Register {
            let llvm_val: *void = (*self).get_value((*val).reg);
            if llvm_val != (0 as *void) {
                return llvm_val;
            }
            // Fallback: return 0
            return (*self).const_i64(0);
        } else if kind == ir_gen::ValueKind::Global {
            // Would lookup global by name
            return (*self).const_i64(0);
        }

        return (*self).const_i64(0);
    }

    /// Convert IR terminator to LLVM
    pub fn convert_terminator(self: *IRToLLVM, term: *ir_gen::Terminator) {
        if term == (0 as *ir_gen::Terminator) {
            return;
        }

        let kind: ir_gen::TerminatorKind = (*term).kind;

        if kind == ir_gen::TerminatorKind::Return {
            let ret_val: *void = (*self).convert_value(&(*term).value);
            (*self).gen_ret(ret_val);

        } else if kind == ir_gen::TerminatorKind::Branch {
            let target_bb: *void = (*self).get_block((*term).target);
            if target_bb != (0 as *void) {
                (*self).gen_br(target_bb);
            }

        } else if kind == ir_gen::TerminatorKind::CondBranch {
            let cond: *void = (*self).convert_value(&(*term).cond);
            let then_bb: *void = (*self).get_block((*term).then_target);
            let else_bb: *void = (*self).get_block((*term).else_target);
            if then_bb != (0 as *void) && else_bb != (0 as *void) {
                (*self).gen_cond_br(cond, then_bb, else_bb);
            }

        } else if kind == ir_gen::TerminatorKind::Unreachable {
            // Generate unreachable (or just return void)
            (*self).gen_ret_void();
        }
    }

    /// Convert IR BinOp to LLVM op code
    pub fn convert_binop(self: *IRToLLVM, op: ir_gen::BinOp) -> u8 {
        if op == ir_gen::BinOp::Add { return 0; }
        else if op == ir_gen::BinOp::Sub { return 1; }
        else if op == ir_gen::BinOp::Mul { return 2; }
        else if op == ir_gen::BinOp::Div { return 3; }
        else if op == ir_gen::BinOp::Rem { return 4; }
        else if op == ir_gen::BinOp::And { return 5; }
        else if op == ir_gen::BinOp::Or { return 6; }
        else if op == ir_gen::BinOp::Xor { return 7; }
        else if op == ir_gen::BinOp::Shl { return 8; }
        else if op == ir_gen::BinOp::Shr { return 9; }
        else if op == ir_gen::BinOp::Eq { return 10; }
        else if op == ir_gen::BinOp::Ne { return 11; }
        else if op == ir_gen::BinOp::Lt { return 12; }
        else if op == ir_gen::BinOp::Le { return 13; }
        else if op == ir_gen::BinOp::Gt { return 14; }
        else if op == ir_gen::BinOp::Ge { return 15; }
        return 0; // Default: Add
    }

    /// Convert IR type to LLVM type ID
    pub fn ir_type_to_llvm(self: *IRToLLVM, ty: u8) -> *void {
        let ctx = (*self).context;

        if ty == 0 { return LLVMInt8TypeInContext(ctx); }      // I8
        else if ty == 1 { return LLVMInt16TypeInContext(ctx); } // I16
        else if ty == 2 { return LLVMInt32TypeInContext(ctx); } // I32
        else if ty == 3 { return LLVMInt64TypeInContext(ctx); } // I64
        else if ty == 9 { return LLVMVoidTypeInContext(ctx); }  // Void

        // Default to i64
        return LLVMInt64TypeInContext(ctx);
    }
}

// ==================== Import IR types ====================

use ir_gen::{
    IRModule, IRFunction, BasicBlock, Instruction, InstrKind,
    Terminator, TerminatorKind, Value, ValueKind, BinOp, IRType,
}

// ==================== Test ====================

fn main() -> i32 {
    puts("IR to LLVM Converter for AetherLang\0" as *u8);
    puts("Initializing LLVM...\0" as *u8);
    
    // Just test LLVM initialization
    LLVMInitializeAllTargetInfos();
    puts("  - TargetInfos OK\0" as *u8);
    
    LLVMInitializeAllTargets();
    puts("  - Targets OK\0" as *u8);
    
    LLVMInitializeAllTargetMCs();
    puts("  - TargetMCs OK\0" as *u8);
    
    LLVMInitializeAllAsmPrinters();
    puts("  - AsmPrinters OK\0" as *u8);
    
    // Create context
    let ctx = LLVMContextCreate();
    puts("  - Context created\0" as *u8);
    
    // Create module
    let m = LLVMModuleCreateWithNameInContext("test\0" as *u8, ctx);
    puts("  - Module created\0" as *u8);
    
    // Print IR
    let ir = LLVMPrintModuleToString(m);
    puts("Generated IR:\0" as *u8);
    puts(ir);
    LLVMDisposeMessage(ir);
    
    // Cleanup
    LLVMDisposeModule(m);
    LLVMContextDispose(ctx);
    
    puts("\n--- Done ---\0" as *u8);
    return 0;
}
