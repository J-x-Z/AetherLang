// AetherLang AST Types
// Simplified AST for self-hosting parser

// ==================== Basic Types ====================

/// Identifier with span
pub struct Ident {
    pub name: String,
    pub span: Span,
}

impl Ident {
    pub fn new(name: String, span: Span) -> Ident {
        return Ident { name: name, span: span };
    }
}

/// Source location
pub struct Span {
    pub start: u64,
    pub end: u64,
}

impl Span {
    pub fn new(start: u64, end: u64) -> Span {
        return Span { start: start, end: end };
    }
    
    pub fn dummy() -> Span {
        return Span { start: 0, end: 0 };
    }
}

// ==================== Types ====================

/// Type representation
pub enum Type {
    /// Named type: i32, String, MyStruct
    Named { name: Ident },
    /// Pointer type: *T, *mut T
    Ptr { inner: *Type, is_mut: bool },
    /// Reference type: &T, &mut T
    Ref { inner: *Type, is_mut: bool },
    /// Array type: [T; N]
    Array { elem: *Type, size: u64 },
    /// Function type: fn(A, B) -> R
    Func { params: *VecType, ret: *Type },
    /// Tuple type: (A, B, C)
    Tuple { elems: *VecType },
    /// Unit type: ()
    Unit,
}

// ==================== Expressions ====================

/// Binary operator
pub enum BinOp {
    Add,    // +
    Sub,    // -
    Mul,    // *
    Div,    // /
    Mod,    // %
    And,    // &&
    Or,     // ||
    BitAnd, // &
    BitOr,  // |
    BitXor, // ^
    Shl,    // <<
    Shr,    // >>
    Eq,     // ==
    Ne,     // !=
    Lt,     // <
    Le,     // <=
    Gt,     // >
    Ge,     // >=
}

/// Unary operator
pub enum UnOp {
    Neg,    // -
    Not,    // !
    BitNot, // ~
    Deref,  // *
    Ref,    // &
    RefMut, // &mut
}

/// Literal values
pub enum Literal {
    Int { value: i64 },
    Float { value: f64 },
    String { value: String },
    Char { value: i32 },
    Bool { value: bool },
}

/// Expression
pub enum Expr {
    /// Literal value
    Lit { lit: Literal, span: Span },
    /// Identifier
    Ident { name: Ident },
    /// Path: Foo::Bar::baz
    Path { segments: *VecIdent, span: Span },
    /// Binary operation: a + b
    Binary { left: *Expr, op: BinOp, right: *Expr, span: Span },
    /// Unary operation: -a, !b
    Unary { op: UnOp, expr: *Expr, span: Span },
    /// Function call: foo(a, b)
    Call { func: *Expr, args: *VecExpr, span: Span },
    /// Field access: expr.field
    Field { expr: *Expr, field: Ident, span: Span },
    /// Method call: expr.method(args)
    Method { expr: *Expr, method: Ident, args: *VecExpr, span: Span },
    /// Index: expr[index]
    Index { expr: *Expr, index: *Expr, span: Span },
    /// Block: { stmts }
    Block { block: *Block },
    /// If: if cond { then } else { else }
    If { cond: *Expr, then_block: *Block, else_block: *Block, span: Span },
    /// While: while cond { body }
    While { cond: *Expr, body: *Block, span: Span },
    /// For: for x in iter { body }
    For { var: Ident, iter: *Expr, body: *Block, span: Span },
    /// Loop: loop { body }
    Loop { body: *Block, span: Span },
    /// Struct literal: Foo { a: 1, b: 2 }
    StructLit { name: Ident, fields: *VecFieldInit, span: Span },
    /// Array: [a, b, c]
    Array { elems: *VecExpr, span: Span },
    /// Cast: expr as Type
    Cast { expr: *Expr, ty: *Type, span: Span },
    /// Return: return expr
    Return { value: *Expr, span: Span },
    /// Break
    Break { span: Span },
    /// Continue
    Continue { span: Span },
}

/// Field initializer for struct literal
pub struct FieldInit {
    pub name: Ident,
    pub value: Expr,
}

// ==================== Statements ====================

/// Statement
pub enum Stmt {
    /// let [mut] name [: type] = expr
    Let { name: Ident, is_mut: bool, ty: *Type, value: *Expr, span: Span },
    /// Expression statement
    Expr { expr: Expr },
    /// Return statement
    Return { value: *Expr, span: Span },
    /// Break
    Break { span: Span },
    /// Continue
    Continue { span: Span },
    /// Empty
    Empty { span: Span },
}

/// Block of statements
pub struct Block {
    pub stmts: *VecStmt,
    pub span: Span,
}

impl Block {
    pub fn new() -> Block {
        return Block { stmts: 0 as *VecStmt, span: Span::dummy() };
    }
}

// ==================== Items ====================

/// Function parameter
pub struct Param {
    pub name: Ident,
    pub ty: Type,
    pub is_mut: bool,
    pub span: Span,
}

/// Function definition
pub struct Function {
    pub name: Ident,
    pub params: *VecParam,
    pub ret_type: *Type,
    pub body: Block,
    pub is_pub: bool,
    pub span: Span,
}

/// Struct field
pub struct Field {
    pub name: Ident,
    pub ty: Type,
    pub is_pub: bool,
    pub span: Span,
}

/// Struct definition
pub struct StructDef {
    pub name: Ident,
    pub fields: *VecField,
    pub is_pub: bool,
    pub span: Span,
}

/// Enum variant
pub struct Variant {
    pub name: Ident,
    pub fields: *VecType,
    pub span: Span,
}

/// Enum definition
pub struct EnumDef {
    pub name: Ident,
    pub variants: *VecVariant,
    pub is_pub: bool,
    pub span: Span,
}

/// Impl block
pub struct ImplBlock {
    pub target: Ident,
    pub methods: *VecFunction,
    pub span: Span,
}

/// Extern function
pub struct ExternFn {
    pub name: Ident,
    pub params: *VecParam,
    pub ret_type: *Type,
    pub span: Span,
}

/// Extern block
pub struct ExternBlock {
    pub abi: String,
    pub items: *VecExternFn,
    pub span: Span,
}

/// Top-level item
pub enum Item {
    Function { func: Function },
    Struct { def: StructDef },
    Enum { def: EnumDef },
    Impl { block: ImplBlock },
    Extern { block: ExternBlock },
}

/// Program (compilation unit)
pub struct Program {
    pub items: *VecItem,
}

impl Program {
    pub fn new() -> Program {
        return Program { items: 0 as *VecItem };
    }
}

// ==================== Vector Types (manual) ====================
// These are placeholder types - actual implementation uses Vec<T>

pub struct VecType {
    pub data: *Type,
    pub len: u64,
    pub cap: u64,
}

pub struct VecExpr {
    pub data: *Expr,
    pub len: u64,
    pub cap: u64,
}

pub struct VecStmt {
    pub data: *Stmt,
    pub len: u64,
    pub cap: u64,
}

pub struct VecIdent {
    pub data: *Ident,
    pub len: u64,
    pub cap: u64,
}

pub struct VecParam {
    pub data: *Param,
    pub len: u64,
    pub cap: u64,
}

pub struct VecField {
    pub data: *Field,
    pub len: u64,
    pub cap: u64,
}

pub struct VecVariant {
    pub data: *Variant,
    pub len: u64,
    pub cap: u64,
}

pub struct VecFunction {
    pub data: *Function,
    pub len: u64,
    pub cap: u64,
}

pub struct VecExternFn {
    pub data: *ExternFn,
    pub len: u64,
    pub cap: u64,
}

pub struct VecItem {
    pub data: *Item,
    pub len: u64,
    pub cap: u64,
}

pub struct VecFieldInit {
    pub data: *FieldInit,
    pub len: u64,
    pub cap: u64,
}

// ==================== Main ====================

fn main() {
    puts("AST types defined!");
}

extern "C" {
    fn puts(s: *u8) -> i32;
}
