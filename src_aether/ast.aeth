// AetherLang AST Types
// Simplified AST for self-hosting parser
// Note: Using tuple variants instead of struct variants (Aether syntax limitation)

extern "C" {
    fn puts(s: *u8) -> i32;
    fn malloc(size: u64) -> *u8;
}

// ==================== Attributes ====================

/// Representation kind for #[repr(...)]
pub enum ReprKind {
    Default,    // Aether default layout
    C,          // C-compatible layout
    Packed,     // Packed (no padding)
    Transparent, // Single-field struct optimization
}

/// Attribute kind
pub enum AttrKind {
    Repr,       // #[repr(C)]
    Naked,      // #[naked]
    Interrupt,  // #[interrupt]
    Simd,       // #[simd]
    Inline,     // #[inline] / #[inline(always)]
    NoMangle,   // #[no_mangle]
    Custom,     // User-defined attribute
}

/// A single attribute: #[name] or #[name(args)]
pub struct Attribute {
    pub kind: AttrKind,
    pub name: Ident,
    pub repr: ReprKind,     // For #[repr(...)]
    pub has_args: bool,
    pub arg_str: *u8,       // Raw argument string
    pub arg_len: u64,
    pub span: Span,
}

impl Attribute {
    pub fn new_repr(repr: ReprKind) -> Attribute {
        return Attribute {
            kind: AttrKind::Repr,
            name: Ident::new("repr\0" as *u8, 4),
            repr: repr,
            has_args: true,
            arg_str: 0 as *u8,
            arg_len: 0,
            span: Span::dummy(),
        };
    }

    pub fn new_naked() -> Attribute {
        return Attribute {
            kind: AttrKind::Naked,
            name: Ident::new("naked\0" as *u8, 5),
            repr: ReprKind::Default,
            has_args: false,
            arg_str: 0 as *u8,
            arg_len: 0,
            span: Span::dummy(),
        };
    }

    pub fn new_interrupt() -> Attribute {
        return Attribute {
            kind: AttrKind::Interrupt,
            name: Ident::new("interrupt\0" as *u8, 9),
            repr: ReprKind::Default,
            has_args: false,
            arg_str: 0 as *u8,
            arg_len: 0,
            span: Span::dummy(),
        };
    }
}

/// List of attributes
pub struct AttributeList {
    pub data: *Attribute,
    pub len: u64,
    pub cap: u64,
}

impl AttributeList {
    pub fn new() -> AttributeList {
        return AttributeList {
            data: 0 as *Attribute,
            len: 0,
            cap: 0,
        };
    }

    pub fn has_repr_c(self: *AttributeList) -> bool {
        let mut i: u64 = 0;
        while i < (*self).len {
            let attr: *Attribute = ((*self).data as u64 + i * 64) as *Attribute;
            if (*attr).kind == AttrKind::Repr && (*attr).repr == ReprKind::C {
                return true;
            }
            i = i + 1;
        }
        return false;
    }

    pub fn has_naked(self: *AttributeList) -> bool {
        let mut i: u64 = 0;
        while i < (*self).len {
            let attr: *Attribute = ((*self).data as u64 + i * 64) as *Attribute;
            if (*attr).kind == AttrKind::Naked {
                return true;
            }
            i = i + 1;
        }
        return false;
    }
}

// ==================== Basic Types ====================

/// Identifier with span (simplified - just name for now)
pub struct Ident {
    pub name: *u8,  // C-string pointer
    pub len: u64,
}

impl Ident {
    pub fn new(name: *u8, len: u64) -> Ident {
        return Ident { name: name, len: len };
    }
}

/// Source location
pub struct Span {
    pub start: u64,
    pub end: u64,
}

impl Span {
    pub fn new(start: u64, end: u64) -> Span {
        return Span { start: start, end: end };
    }
    
    pub fn dummy() -> Span {
        return Span { start: 0, end: 0 };
    }
}

// ==================== Types ====================

/// Type tag (discriminant for Type union)
pub enum TypeKind {
    Named,
    Ptr,
    Ref,
    Array,
    Func,
    Tuple,
    Unit,
}

/// Type representation (use struct + tag instead of enum with data)
pub struct Type {
    pub kind: TypeKind,
    pub name: Ident,        // For Named
    pub inner: *Type,       // For Ptr, Ref
    pub is_mut: bool,       // For Ptr, Ref
    pub size: u64,          // For Array
    pub span: Span,
}

impl Type {
    pub fn new_named(name: Ident) -> Type {
        return Type { 
            kind: TypeKind::Named, 
            name: name,
            inner: 0 as *Type,
            is_mut: false,
            size: 0,
            span: Span::dummy(),
        };
    }
    
    pub fn new_unit() -> Type {
        return Type {
            kind: TypeKind::Unit,
            name: Ident::new(0 as *u8, 0),
            inner: 0 as *Type,
            is_mut: false,
            size: 0,
            span: Span::dummy(),
        };
    }
}

// ==================== Binary/Unary Operators ====================

pub enum BinOp {
    Add,
    Sub,
    Mul,
    Div,
    Mod,
    And,
    Or,
    Eq,
    Ne,
    Lt,
    Le,
    Gt,
    Ge,
}

pub enum UnOp {
    Neg,
    Not,
    Deref,
    Ref,
}

// ==================== Literals ====================

pub enum LitKind {
    Int,
    Bool,
    String,
    Char,
}

pub struct Literal {
    pub kind: LitKind,
    pub int_val: i64,
    pub bool_val: bool,
    pub str_ptr: *u8,
    pub str_len: u64,
}

impl Literal {
    pub fn new_int(val: i64) -> Literal {
        return Literal {
            kind: LitKind::Int,
            int_val: val,
            bool_val: false,
            str_ptr: 0 as *u8,
            str_len: 0,
        };
    }
    
    pub fn new_bool(val: bool) -> Literal {
        return Literal {
            kind: LitKind::Bool,
            int_val: 0,
            bool_val: val,
            str_ptr: 0 as *u8,
            str_len: 0,
        };
    }
}

// ==================== Expressions ====================

pub enum ExprKind {
    Lit,
    Ident,
    Binary,
    Unary,
    Call,
    Field,
    Index,
    If,
    While,
    Block,
    Return,
    Break,
    Continue,
}

pub struct Expr {
    pub kind: ExprKind,
    pub span: Span,
    
    // Lit
    pub lit: Literal,
    
    // Ident
    pub name: Ident,
    
    // Binary
    pub bin_op: BinOp,
    pub left: *Expr,
    pub right: *Expr,
    
    // Unary
    pub un_op: UnOp,
    pub operand: *Expr,
    
    // Call
    pub callee: *Expr,
    pub args: *ExprList,
    
    // Field
    pub object: *Expr,
    pub field: Ident,
    
    // If
    pub cond: *Expr,
    pub then_block: *Block,
    pub else_block: *Block,
    
    // While
    pub body: *Block,
}

// ==================== Statements ====================

pub enum StmtKind {
    Let,
    Expr,
    Return,
    Break,
    Continue,
    Empty,
}

pub struct Stmt {
    pub kind: StmtKind,
    pub span: Span,
    
    // Let
    pub let_name: Ident,
    pub let_type: *Type,
    pub let_value: *Expr,
    pub is_mut: bool,
    
    // Expr
    pub expr: *Expr,
    
    // Return
    pub ret_value: *Expr,
}

pub struct Block {
    pub stmts: *StmtList,
    pub span: Span,
}

// ==================== Items ====================

pub struct Param {
    pub name: Ident,
    pub ty: Type,
    pub span: Span,
}

pub struct Function {
    pub name: Ident,
    pub params: *ParamList,
    pub ret_type: *Type,
    pub body: Block,
    pub is_pub: bool,
    pub attrs: *AttributeList,  // #[naked], #[interrupt], etc.
    pub span: Span,
}

pub struct StructField {
    pub name: Ident,
    pub ty: Type,
    pub is_pub: bool,
}

pub struct StructDef {
    pub name: Ident,
    pub fields: *FieldList,
    pub is_pub: bool,
    pub attrs: *AttributeList,  // #[repr(C)], #[repr(packed)], etc.
    pub span: Span,
}

pub struct EnumVariant {
    pub name: Ident,
    pub span: Span,
}

pub struct EnumDef {
    pub name: Ident,
    pub variants: *VariantList,
    pub is_pub: bool,
    pub attrs: *AttributeList,  // #[repr(C)], #[repr(u8)], etc.
    pub span: Span,
}

pub struct ImplBlock {
    pub target: Ident,
    pub methods: *FunctionList,
    pub span: Span,
}

pub struct ExternFn {
    pub name: Ident,
    pub params: *ParamList,
    pub ret_type: *Type,
    pub span: Span,
}

pub struct ExternBlock {
    pub abi: *u8,
    pub items: *ExternFnList,
    pub span: Span,
}

pub enum ItemKind {
    Function,
    Struct,
    Enum,
    Impl,
    Extern,
}

pub struct Item {
    pub kind: ItemKind,
    pub func: Function,
    pub struct_def: StructDef,
    pub enum_def: EnumDef,
    pub impl_block: ImplBlock,
    pub extern_block: ExternBlock,
}

pub struct Program {
    pub items: *ItemList,
}

// ==================== List Types ====================

pub struct ExprList {
    pub data: *Expr,
    pub len: u64,
    pub cap: u64,
}

pub struct StmtList {
    pub data: *Stmt,
    pub len: u64,
    pub cap: u64,
}

pub struct ParamList {
    pub data: *Param,
    pub len: u64,
    pub cap: u64,
}

pub struct FieldList {
    pub data: *StructField,
    pub len: u64,
    pub cap: u64,
}

pub struct VariantList {
    pub data: *EnumVariant,
    pub len: u64,
    pub cap: u64,
}

pub struct FunctionList {
    pub data: *Function,
    pub len: u64,
    pub cap: u64,
}

pub struct ExternFnList {
    pub data: *ExternFn,
    pub len: u64,
    pub cap: u64,
}

pub struct ItemList {
    pub data: *Item,
    pub len: u64,
    pub cap: u64,
}

// ==================== Main ====================

fn main() {
    puts("AST types defined!");
}
