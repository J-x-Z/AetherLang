/* Generated by AetherLang C Backend */
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <immintrin.h>  /* SSE/AVX */

/* AetherLang Runtime */
static void aether_print(const char* s) { printf("%s", s); }
static void aether_println(const char* s) { printf("%s\n", s); }
static void aether_print_i64(int64_t n) { printf("%lld", (long long)n); }
static void aether_println_i64(int64_t n) { printf("%lld\n", (long long)n); }
static void aether_assert(bool c) { if(!c) { fprintf(stderr, "Assertion failed\n"); exit(1); } }

/* Struct Definitions */
struct ResolvedType {
    struct TypeKind* kind;
    uint8_t* name;
    struct ResolvedType** inner;
    bool is_mut;
};

struct Symbol {
    uint8_t* name;
    struct SymbolKind* kind;
    struct ResolvedType* ty;
    bool is_mutable;
};

struct Scope {
    uint64_t id;
    uint64_t parent;
    uint64_t symbol_count;
};

struct SymbolEntry {
    uint64_t name_hash;
    struct SymbolKind* kind;
    struct TypeKind* type_kind;
    uint64_t scope_id;
    bool is_mutable;
};

struct SymbolTable {
    uint64_t current_scope;
    uint64_t next_scope_id;
    uint64_t symbol_count;
};

struct VarEntry {
    uint64_t name_hash;
    struct VarState* state;
    uint64_t borrow_count;
    uint64_t scope_id;
    bool is_copy;
};

struct OwnershipState {
    uint64_t var_count;
    uint64_t current_scope;
    uint64_t error_count;
};

struct SemanticAnalyzer {
    struct SymbolTable* symbols;
    uint64_t error_count;
    bool strict_mode;
};

void ResolvedType_new(struct ResolvedType*, struct TypeKind*);
void ResolvedType_i64_type(struct ResolvedType*);
void ResolvedType_bool_type(struct ResolvedType*);
void ResolvedType_void_type(struct ResolvedType*);
void Symbol_new(struct Symbol*, uint8_t*, struct SymbolKind*, struct ResolvedType*);
void Symbol_variable(struct Symbol*, uint8_t*, struct ResolvedType*, bool);
void Scope_new(struct Scope*, uint64_t, uint64_t);
void SymbolEntry_new(struct SymbolEntry*, uint64_t, struct SymbolKind*, struct TypeKind*, uint64_t);
void SymbolTable_new(struct SymbolTable*);
uint64_t SymbolTable_hash_name(uint8_t*);
uint64_t SymbolTable_enter_scope(struct SymbolTable*);
void SymbolTable_exit_scope(struct SymbolTable*);
bool SymbolTable_define(struct SymbolTable*, struct Symbol*);
bool SymbolTable_define_typed(struct SymbolTable*, uint8_t*, struct SymbolKind*, struct TypeKind*);
bool SymbolTable_lookup(struct SymbolTable*, uint8_t*);
void SymbolTable_lookup_type(struct TypeKind*, struct SymbolTable*, uint8_t*);
bool SymbolTable_lookup_local(struct SymbolTable*, uint8_t*);
uint64_t SymbolTable_current(struct SymbolTable*);
void VarEntry_new(struct VarEntry*, uint64_t, uint64_t, bool);
void OwnershipState_new(struct OwnershipState*);
void OwnershipState_enter_scope(struct OwnershipState*);
void OwnershipState_exit_scope(struct OwnershipState*);
void OwnershipState_add_owned(struct OwnershipState*, uint8_t*, bool);
bool OwnershipState_is_available(struct OwnershipState*, uint8_t*);
bool OwnershipState_move_var(struct OwnershipState*, uint8_t*);
bool OwnershipState_borrow(struct OwnershipState*, uint8_t*);
bool OwnershipState_borrow_mut(struct OwnershipState*, uint8_t*);
void OwnershipState_release_borrow(struct OwnershipState*, uint8_t*);
void OwnershipState_release_mut_borrow(struct OwnershipState*, uint8_t*);
bool OwnershipState_check_use(struct OwnershipState*, uint8_t*);
bool OwnershipState_is_copy_type(struct TypeKind*);
bool OwnershipState_has_borrows(struct OwnershipState*, uint8_t*);
bool OwnershipState_has_mut_borrows(struct OwnershipState*, uint8_t*);
void SemanticAnalyzer_new(struct SemanticAnalyzer*);
void SemanticAnalyzer_set_strict_mode(struct SemanticAnalyzer*, bool);
void SemanticAnalyzer_register_builtins(struct SemanticAnalyzer*);
bool SemanticAnalyzer_analyze(struct SemanticAnalyzer*);
bool SemanticAnalyzer_collect_definition(struct SemanticAnalyzer*);
bool SemanticAnalyzer_check_item(struct SemanticAnalyzer*);
bool SemanticAnalyzer_check_function(struct SemanticAnalyzer*);
bool SemanticAnalyzer_check_impl(struct SemanticAnalyzer*);
bool SemanticAnalyzer_check_block(struct SemanticAnalyzer*);
bool SemanticAnalyzer_check_stmt(struct SemanticAnalyzer*);
bool SemanticAnalyzer_check_let(struct SemanticAnalyzer*);
bool SemanticAnalyzer_check_return(struct SemanticAnalyzer*);
void SemanticAnalyzer_check_expr(struct TypeKind*, struct SemanticAnalyzer*);
void SemanticAnalyzer_check_literal(struct TypeKind*, struct SemanticAnalyzer*, uint8_t);
void SemanticAnalyzer_check_ident(struct TypeKind*, struct SemanticAnalyzer*, uint8_t*);
void SemanticAnalyzer_check_binary(struct TypeKind*, struct SemanticAnalyzer*, uint8_t, struct TypeKind*, struct TypeKind*);
void SemanticAnalyzer_check_unary(struct TypeKind*, struct SemanticAnalyzer*, uint8_t, struct TypeKind*);
void SemanticAnalyzer_check_call(struct TypeKind*, struct SemanticAnalyzer*, uint8_t*);
void SemanticAnalyzer_check_field(struct TypeKind*, struct SemanticAnalyzer*);
void SemanticAnalyzer_check_method(struct TypeKind*, struct SemanticAnalyzer*);
void SemanticAnalyzer_check_if(struct TypeKind*, struct SemanticAnalyzer*);
void SemanticAnalyzer_check_while(struct TypeKind*, struct SemanticAnalyzer*);
void SemanticAnalyzer_check_for(struct TypeKind*, struct SemanticAnalyzer*);
void SemanticAnalyzer_check_match(struct TypeKind*, struct SemanticAnalyzer*);
void SemanticAnalyzer_resolve_type(struct TypeKind*, struct SemanticAnalyzer*);
bool SemanticAnalyzer_is_integer_type(struct TypeKind*);
bool SemanticAnalyzer_types_compatible(struct SemanticAnalyzer*, struct TypeKind*, struct TypeKind*);
void SemanticAnalyzer_report_error(struct SemanticAnalyzer*, uint8_t*);
void SemanticAnalyzer_define_builtin(struct SemanticAnalyzer*, uint8_t*, struct TypeKind*);
void SemanticAnalyzer_check_index(struct TypeKind*, struct SemanticAnalyzer*);
void SemanticAnalyzer_check_cast(struct TypeKind*, struct SemanticAnalyzer*);
void SemanticAnalyzer_check_struct_lit(struct TypeKind*, struct SemanticAnalyzer*);
void SemanticAnalyzer_check_array_lit(struct TypeKind*, struct SemanticAnalyzer*);
void SemanticAnalyzer_check_ref(struct TypeKind*, struct SemanticAnalyzer*);
void main(void);

void ResolvedType_new(struct ResolvedType* _arg0, struct TypeKind* _arg1) {
    bool* _t7;
    struct ResolvedType* _t0;
    struct ResolvedType** _t5;
    struct ResolvedType*** _t6;
    struct TypeKind* _t1;
    struct TypeKind** _t2;
    uint8_t* _t3;
    uint8_t** _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->kind;
    *_t2 = _t1;
    _t3 = (uint8_t*)0LL;
    _t4 = &_t0->name;
    *_t4 = _t3;
    _t5 = (struct ResolvedType**)0LL;
    _t6 = &_t0->inner;
    *_t6 = _t5;
    _t7 = &_t0->is_mut;
    *_t7 = 0;
    return;
}

void ResolvedType_i64_type(struct ResolvedType* _arg0) {
    struct ResolvedType* _t0;
    struct ResolvedType* _t1;
    
    _t0 = _arg0;
    struct ResolvedType _alloca__t1;
    _t1 = &_alloca__t1;
    ResolvedType_new(_t1, TypeKind_I64);
    return;
}

void ResolvedType_bool_type(struct ResolvedType* _arg0) {
    struct ResolvedType* _t0;
    struct ResolvedType* _t1;
    
    _t0 = _arg0;
    struct ResolvedType _alloca__t1;
    _t1 = &_alloca__t1;
    ResolvedType_new(_t1, TypeKind_Bool);
    return;
}

void ResolvedType_void_type(struct ResolvedType* _arg0) {
    struct ResolvedType* _t0;
    struct ResolvedType* _t1;
    
    _t0 = _arg0;
    struct ResolvedType _alloca__t1;
    _t1 = &_alloca__t1;
    ResolvedType_new(_t1, TypeKind_Void);
    return;
}

void Symbol_new(struct Symbol* _arg0, uint8_t* _arg1, struct SymbolKind* _arg2, struct ResolvedType* _arg3) {
    bool* _t7;
    struct ResolvedType* _t3;
    struct ResolvedType** _t6;
    struct Symbol* _t0;
    struct SymbolKind* _t2;
    struct SymbolKind** _t5;
    uint8_t* _t1;
    uint8_t** _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = &_t0->name;
    *_t4 = _t1;
    _t5 = &_t0->kind;
    *_t5 = _t2;
    _t6 = &_t0->ty;
    *_t6 = _t3;
    _t7 = &_t0->is_mutable;
    *_t7 = 0;
    return;
}

void Symbol_variable(struct Symbol* _arg0, uint8_t* _arg1, struct ResolvedType* _arg2, bool _arg3) {
    bool _t3;
    bool* _t7;
    struct ResolvedType* _t2;
    struct ResolvedType** _t6;
    struct Symbol* _t0;
    struct SymbolKind** _t5;
    uint8_t* _t1;
    uint8_t** _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = &_t0->name;
    *_t4 = _t1;
    _t5 = &_t0->kind;
    *_t5 = SymbolKind_Variable;
    _t6 = &_t0->ty;
    *_t6 = _t2;
    _t7 = &_t0->is_mutable;
    *_t7 = _t3;
    return;
}

void Scope_new(struct Scope* _arg0, uint64_t _arg1, uint64_t _arg2) {
    struct Scope* _t0;
    uint64_t _t1;
    uint64_t _t2;
    uint64_t* _t3;
    uint64_t* _t4;
    uint64_t* _t5;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t0->id;
    *_t3 = _t1;
    _t4 = &_t0->parent;
    *_t4 = _t2;
    _t5 = &_t0->symbol_count;
    *_t5 = 0LL;
    return;
}

void SymbolEntry_new(struct SymbolEntry* _arg0, uint64_t _arg1, struct SymbolKind* _arg2, struct TypeKind* _arg3, uint64_t _arg4) {
    bool* _t9;
    struct SymbolEntry* _t0;
    struct SymbolKind* _t2;
    struct SymbolKind** _t6;
    struct TypeKind* _t3;
    struct TypeKind** _t7;
    uint64_t _t1;
    uint64_t _t4;
    uint64_t* _t5;
    uint64_t* _t8;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = _arg4;
    _t5 = &_t0->name_hash;
    *_t5 = _t1;
    _t6 = &_t0->kind;
    *_t6 = _t2;
    _t7 = &_t0->type_kind;
    *_t7 = _t3;
    _t8 = &_t0->scope_id;
    *_t8 = _t4;
    _t9 = &_t0->is_mutable;
    *_t9 = 0;
    return;
}

void SymbolTable_new(struct SymbolTable* _arg0) {
    struct SymbolTable* _t0;
    uint64_t* _t1;
    uint64_t* _t2;
    uint64_t* _t3;
    
    _t0 = _arg0;
    _t1 = &_t0->current_scope;
    *_t1 = 0LL;
    _t2 = &_t0->next_scope_id;
    *_t2 = 1LL;
    _t3 = &_t0->symbol_count;
    *_t3 = 0LL;
    return;
}

uint64_t SymbolTable_hash_name(uint8_t* _arg0) {
    int64_t _t1;
    uint64_t _t3;
    uint8_t* _t0;
    uint8_t* _t2;
    
    _t0 = _arg0;
    _t1 = 5381LL;
    _t2 = _t0;
    _t3 = (uint64_t)_t1;
    return _t3;
}

uint64_t SymbolTable_enter_scope(struct SymbolTable* _arg0) {
    int64_t _t9;
    struct SymbolTable* _t0;
    uint64_t _t12;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t _t5;
    uint64_t _t7;
    uint64_t _t8;
    uint64_t* _t10;
    uint64_t* _t11;
    uint64_t* _t13;
    uint64_t* _t1;
    uint64_t* _t4;
    uint64_t* _t6;
    
    _t0 = _arg0;
    _t1 = &_t0->next_scope_id;
    _t2 = *_t1;
    _t3 = _t2;
    _t4 = &_t0->next_scope_id;
    _t5 = *_t4;
    _t6 = &_t0->next_scope_id;
    _t7 = *_t6;
    _t8 = (uint64_t)1LL;
    _t9 = _t7 + _t8;
    _t10 = &_t0->next_scope_id;
    *_t10 = _t9;
    _t11 = &_t0->current_scope;
    _t12 = *_t11;
    _t13 = &_t0->current_scope;
    *_t13 = _t3;
    return _t3;
}

void SymbolTable_exit_scope(struct SymbolTable* _arg0) {
    int64_t _t10;
    int64_t _t4;
    struct SymbolTable* _t0;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t _t6;
    uint64_t _t8;
    uint64_t _t9;
    uint64_t* _t11;
    uint64_t* _t1;
    uint64_t* _t5;
    uint64_t* _t7;
    
    _t0 = _arg0;
    _t1 = &_t0->current_scope;
    _t2 = *_t1;
    _t3 = (uint64_t)0LL;
    _t4 = _t2 > _t3;
    if (_t4) goto L_then; else goto L_else;
L_then:
    _t5 = &_t0->current_scope;
    _t6 = *_t5;
    _t7 = &_t0->current_scope;
    _t8 = *_t7;
    _t9 = (uint64_t)1LL;
    _t10 = _t8 - _t9;
    _t11 = &_t0->current_scope;
    *_t11 = _t10;
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    return;
}

bool SymbolTable_define(struct SymbolTable* _arg0, struct Symbol* _arg1) {
    int64_t _t7;
    struct Symbol* _t1;
    struct SymbolTable* _t0;
    uint64_t _t3;
    uint64_t _t5;
    uint64_t _t6;
    uint64_t* _t2;
    uint64_t* _t4;
    uint64_t* _t8;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->symbol_count;
    _t3 = *_t2;
    _t4 = &_t0->symbol_count;
    _t5 = *_t4;
    _t6 = (uint64_t)1LL;
    _t7 = _t5 + _t6;
    _t8 = &_t0->symbol_count;
    *_t8 = _t7;
    return 1;
}

bool SymbolTable_define_typed(struct SymbolTable* _arg0, uint8_t* _arg1, struct SymbolKind* _arg2, struct TypeKind* _arg3) {
    int64_t _t9;
    struct SymbolKind* _t2;
    struct SymbolTable* _t0;
    struct TypeKind* _t3;
    uint64_t _t5;
    uint64_t _t7;
    uint64_t _t8;
    uint64_t* _t10;
    uint64_t* _t4;
    uint64_t* _t6;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = &_t0->symbol_count;
    _t5 = *_t4;
    _t6 = &_t0->symbol_count;
    _t7 = *_t6;
    _t8 = (uint64_t)1LL;
    _t9 = _t7 + _t8;
    _t10 = &_t0->symbol_count;
    *_t10 = _t9;
    return 1;
}

bool SymbolTable_lookup(struct SymbolTable* _arg0, uint8_t* _arg1) {
    struct SymbolTable* _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return 0;
}

void SymbolTable_lookup_type(struct TypeKind* _arg0, struct SymbolTable* _arg1, uint8_t* _arg2) {
    int64_t _t12;
    int64_t _t16;
    int64_t _t8;
    struct SymbolTable* _t1;
    struct TypeKind* _t0;
    uint64_t _t10;
    uint64_t _t11;
    uint64_t _t14;
    uint64_t _t15;
    uint64_t _t3;
    uint64_t _t4;
    uint64_t _t6;
    uint64_t _t7;
    uint8_t* _t13;
    uint8_t* _t2;
    uint8_t* _t5;
    uint8_t* _t9;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = SymbolTable_hash_name(_t2);
    _t4 = _t3;
    _t5 = (uint8_t*)"puts";
    _t6 = SymbolTable_hash_name(_t5);
    _t7 = _t6;
    _t8 = _t4 == _t7;
    if (_t8) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t9 = (uint8_t*)"malloc";
    _t10 = SymbolTable_hash_name(_t9);
    _t11 = _t10;
    _t12 = _t4 == _t11;
    if (_t12) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t13 = (uint8_t*)"putchar";
    _t14 = SymbolTable_hash_name(_t13);
    _t15 = _t14;
    _t16 = _t4 == _t15;
    if (_t16) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    return;
}

bool SymbolTable_lookup_local(struct SymbolTable* _arg0, uint8_t* _arg1) {
    struct SymbolTable* _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return 0;
}

uint64_t SymbolTable_current(struct SymbolTable* _arg0) {
    struct SymbolTable* _t0;
    uint64_t _t2;
    uint64_t* _t1;
    
    _t0 = _arg0;
    _t1 = &_t0->current_scope;
    _t2 = *_t1;
    return _t2;
}

void VarEntry_new(struct VarEntry* _arg0, uint64_t _arg1, uint64_t _arg2, bool _arg3) {
    bool _t3;
    bool* _t8;
    struct VarEntry* _t0;
    struct VarState** _t5;
    uint64_t _t1;
    uint64_t _t2;
    uint64_t* _t4;
    uint64_t* _t6;
    uint64_t* _t7;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = &_t0->name_hash;
    *_t4 = _t1;
    _t5 = &_t0->state;
    *_t5 = VarState_Owned;
    _t6 = &_t0->borrow_count;
    *_t6 = 0LL;
    _t7 = &_t0->scope_id;
    *_t7 = _t2;
    _t8 = &_t0->is_copy;
    *_t8 = _t3;
    return;
}

void OwnershipState_new(struct OwnershipState* _arg0) {
    struct OwnershipState* _t0;
    uint64_t* _t1;
    uint64_t* _t2;
    uint64_t* _t3;
    
    _t0 = _arg0;
    _t1 = &_t0->var_count;
    *_t1 = 0LL;
    _t2 = &_t0->current_scope;
    *_t2 = 0LL;
    _t3 = &_t0->error_count;
    *_t3 = 0LL;
    return;
}

void OwnershipState_enter_scope(struct OwnershipState* _arg0) {
    int64_t _t6;
    struct OwnershipState* _t0;
    uint64_t _t2;
    uint64_t _t4;
    uint64_t _t5;
    uint64_t* _t1;
    uint64_t* _t3;
    uint64_t* _t7;
    
    _t0 = _arg0;
    _t1 = &_t0->current_scope;
    _t2 = *_t1;
    _t3 = &_t0->current_scope;
    _t4 = *_t3;
    _t5 = (uint64_t)1LL;
    _t6 = _t4 + _t5;
    _t7 = &_t0->current_scope;
    *_t7 = _t6;
    return;
}

void OwnershipState_exit_scope(struct OwnershipState* _arg0) {
    int64_t _t10;
    int64_t _t4;
    struct OwnershipState* _t0;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t _t6;
    uint64_t _t8;
    uint64_t _t9;
    uint64_t* _t11;
    uint64_t* _t1;
    uint64_t* _t5;
    uint64_t* _t7;
    
    _t0 = _arg0;
    _t1 = &_t0->current_scope;
    _t2 = *_t1;
    _t3 = (uint64_t)0LL;
    _t4 = _t2 > _t3;
    if (_t4) goto L_then; else goto L_else;
L_then:
    _t5 = &_t0->current_scope;
    _t6 = *_t5;
    _t7 = &_t0->current_scope;
    _t8 = *_t7;
    _t9 = (uint64_t)1LL;
    _t10 = _t8 - _t9;
    _t11 = &_t0->current_scope;
    *_t11 = _t10;
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    return;
}

void OwnershipState_add_owned(struct OwnershipState* _arg0, uint8_t* _arg1, bool _arg2) {
    bool _t2;
    int64_t _t8;
    struct OwnershipState* _t0;
    uint64_t _t4;
    uint64_t _t6;
    uint64_t _t7;
    uint64_t* _t3;
    uint64_t* _t5;
    uint64_t* _t9;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t0->var_count;
    _t4 = *_t3;
    _t5 = &_t0->var_count;
    _t6 = *_t5;
    _t7 = (uint64_t)1LL;
    _t8 = _t6 + _t7;
    _t9 = &_t0->var_count;
    *_t9 = _t8;
    return;
}

bool OwnershipState_is_available(struct OwnershipState* _arg0, uint8_t* _arg1) {
    struct OwnershipState* _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return 1;
}

bool OwnershipState_move_var(struct OwnershipState* _arg0, uint8_t* _arg1) {
    bool _t2;
    bool _t3;
    int64_t _t9;
    struct OwnershipState* _t0;
    uint64_t _t5;
    uint64_t _t7;
    uint64_t _t8;
    uint64_t* _t10;
    uint64_t* _t4;
    uint64_t* _t6;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = OwnershipState_is_available(_t0, _t1);
    _t3 = !_t2;
    if (_t3) goto L_then; else goto L_else;
L_then:
    _t4 = &_t0->error_count;
    _t5 = *_t4;
    _t6 = &_t0->error_count;
    _t7 = *_t6;
    _t8 = (uint64_t)1LL;
    _t9 = _t7 + _t8;
    _t10 = &_t0->error_count;
    *_t10 = _t9;
    return 0;
L_else:
    goto L_merge;
L_merge:
    return 1;
}

bool OwnershipState_borrow(struct OwnershipState* _arg0, uint8_t* _arg1) {
    struct OwnershipState* _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return 1;
}

bool OwnershipState_borrow_mut(struct OwnershipState* _arg0, uint8_t* _arg1) {
    struct OwnershipState* _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return 1;
}

void OwnershipState_release_borrow(struct OwnershipState* _arg0, uint8_t* _arg1) {
    struct OwnershipState* _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void OwnershipState_release_mut_borrow(struct OwnershipState* _arg0, uint8_t* _arg1) {
    struct OwnershipState* _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

bool OwnershipState_check_use(struct OwnershipState* _arg0, uint8_t* _arg1) {
    bool _t2;
    bool _t3;
    int64_t _t9;
    struct OwnershipState* _t0;
    uint64_t _t5;
    uint64_t _t7;
    uint64_t _t8;
    uint64_t* _t10;
    uint64_t* _t4;
    uint64_t* _t6;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = OwnershipState_is_available(_t0, _t1);
    _t3 = !_t2;
    if (_t3) goto L_then; else goto L_else;
L_then:
    _t4 = &_t0->error_count;
    _t5 = *_t4;
    _t6 = &_t0->error_count;
    _t7 = *_t6;
    _t8 = (uint64_t)1LL;
    _t9 = _t7 + _t8;
    _t10 = &_t0->error_count;
    *_t10 = _t9;
    return 0;
L_else:
    goto L_merge;
L_merge:
    return 1;
}

bool OwnershipState_is_copy_type(struct TypeKind* _arg0) {
    int64_t _t10;
    int64_t _t11;
    int64_t _t12;
    int64_t _t13;
    int64_t _t14;
    int64_t _t15;
    int64_t _t16;
    int64_t _t17;
    int64_t _t1;
    int64_t _t2;
    int64_t _t3;
    int64_t _t4;
    int64_t _t5;
    int64_t _t6;
    int64_t _t7;
    int64_t _t8;
    int64_t _t9;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _t0 == TypeKind_I8;
    _t2 = _t0 == TypeKind_I16;
    _t3 = _t1 || _t2;
    _t4 = _t0 == TypeKind_I32;
    _t5 = _t3 || _t4;
    _t6 = _t0 == TypeKind_I64;
    _t7 = _t5 || _t6;
    _t8 = _t0 == TypeKind_U8;
    _t9 = _t7 || _t8;
    _t10 = _t0 == TypeKind_U16;
    _t11 = _t9 || _t10;
    _t12 = _t0 == TypeKind_U32;
    _t13 = _t11 || _t12;
    _t14 = _t0 == TypeKind_U64;
    _t15 = _t13 || _t14;
    _t16 = _t0 == TypeKind_Bool;
    _t17 = _t15 || _t16;
    return _t17;
}

bool OwnershipState_has_borrows(struct OwnershipState* _arg0, uint8_t* _arg1) {
    struct OwnershipState* _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return 0;
}

bool OwnershipState_has_mut_borrows(struct OwnershipState* _arg0, uint8_t* _arg1) {
    struct OwnershipState* _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return 0;
}

void SemanticAnalyzer_new(struct SemanticAnalyzer* _arg0) {
    bool* _t4;
    struct SemanticAnalyzer* _t0;
    struct SymbolTable* _t1;
    struct SymbolTable** _t2;
    uint64_t* _t3;
    
    _t0 = _arg0;
    struct SymbolTable _alloca__t1;
    _t1 = &_alloca__t1;
    SymbolTable_new(_t1);
    _t2 = &_t0->symbols;
    *_t2 = _t1;
    _t3 = &_t0->error_count;
    *_t3 = 0LL;
    _t4 = &_t0->strict_mode;
    *_t4 = 0;
    return;
}

void SemanticAnalyzer_set_strict_mode(struct SemanticAnalyzer* _arg0, bool _arg1) {
    bool _t1;
    bool _t3;
    bool* _t2;
    bool* _t4;
    struct SemanticAnalyzer* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->strict_mode;
    _t3 = *_t2;
    _t4 = &_t0->strict_mode;
    *_t4 = _t1;
    return;
}

void SemanticAnalyzer_register_builtins(struct SemanticAnalyzer* _arg0) {
    struct SemanticAnalyzer* _t0;
    
    _t0 = _arg0;
    return;
}

bool SemanticAnalyzer_analyze(struct SemanticAnalyzer* _arg0) {
    int64_t _t4;
    struct SemanticAnalyzer* _t0;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t* _t1;
    
    _t0 = _arg0;
    _t1 = &_t0->error_count;
    _t2 = *_t1;
    _t3 = (uint64_t)0LL;
    _t4 = _t2 == _t3;
    return _t4;
}

bool SemanticAnalyzer_collect_definition(struct SemanticAnalyzer* _arg0) {
    struct SemanticAnalyzer* _t0;
    
    _t0 = _arg0;
    return 1;
}

bool SemanticAnalyzer_check_item(struct SemanticAnalyzer* _arg0) {
    struct SemanticAnalyzer* _t0;
    
    _t0 = _arg0;
    return 1;
}

bool SemanticAnalyzer_check_function(struct SemanticAnalyzer* _arg0) {
    struct SemanticAnalyzer* _t0;
    struct SymbolTable* _t2;
    struct SymbolTable* _t5;
    struct SymbolTable** _t1;
    struct SymbolTable** _t4;
    uint64_t _t3;
    
    _t0 = _arg0;
    _t1 = &_t0->symbols;
    _t2 = *_t1;
    _t3 = SymbolTable_enter_scope(_t2);
    _t4 = &_t0->symbols;
    _t5 = *_t4;
    SymbolTable_exit_scope(_t5);
    return 1;
}

bool SemanticAnalyzer_check_impl(struct SemanticAnalyzer* _arg0) {
    struct SemanticAnalyzer* _t0;
    
    _t0 = _arg0;
    return 1;
}

bool SemanticAnalyzer_check_block(struct SemanticAnalyzer* _arg0) {
    struct SemanticAnalyzer* _t0;
    struct SymbolTable* _t2;
    struct SymbolTable* _t5;
    struct SymbolTable** _t1;
    struct SymbolTable** _t4;
    uint64_t _t3;
    
    _t0 = _arg0;
    _t1 = &_t0->symbols;
    _t2 = *_t1;
    _t3 = SymbolTable_enter_scope(_t2);
    _t4 = &_t0->symbols;
    _t5 = *_t4;
    SymbolTable_exit_scope(_t5);
    return 1;
}

bool SemanticAnalyzer_check_stmt(struct SemanticAnalyzer* _arg0) {
    struct SemanticAnalyzer* _t0;
    
    _t0 = _arg0;
    return 1;
}

bool SemanticAnalyzer_check_let(struct SemanticAnalyzer* _arg0) {
    struct SemanticAnalyzer* _t0;
    
    _t0 = _arg0;
    return 1;
}

bool SemanticAnalyzer_check_return(struct SemanticAnalyzer* _arg0) {
    struct SemanticAnalyzer* _t0;
    
    _t0 = _arg0;
    return 1;
}

void SemanticAnalyzer_check_expr(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void SemanticAnalyzer_check_literal(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1, uint8_t _arg2) {
    int64_t _t10;
    int64_t _t12;
    int64_t _t4;
    int64_t _t6;
    int64_t _t8;
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    uint8_t _t11;
    uint8_t _t2;
    uint8_t _t3;
    uint8_t _t5;
    uint8_t _t7;
    uint8_t _t9;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = (uint8_t)0LL;
    _t4 = _t2 == _t3;
    if (_t4) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    _t5 = (uint8_t)1LL;
    _t6 = _t2 == _t5;
    if (_t6) goto L_then; else goto L_else;
L_merge:
    return;
L_then:
    return;
L_else:
    _t7 = (uint8_t)2LL;
    _t8 = _t2 == _t7;
    if (_t8) goto L_then; else goto L_else;
L_merge:
    goto L_merge;
L_then:
    return;
L_else:
    _t9 = (uint8_t)3LL;
    _t10 = _t2 == _t9;
    if (_t10) goto L_then; else goto L_else;
L_merge:
    goto L_merge;
L_then:
    return;
L_else:
    _t11 = (uint8_t)4LL;
    _t12 = _t2 == _t11;
    if (_t12) goto L_then; else goto L_else;
L_merge:
    goto L_merge;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
}

void SemanticAnalyzer_check_ident(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1, uint8_t* _arg2) {
    struct SemanticAnalyzer* _t1;
    struct SymbolTable* _t4;
    struct SymbolTable** _t3;
    struct TypeKind* _t0;
    struct TypeKind* _t5;
    uint8_t* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t1->symbols;
    _t4 = *_t3;
    struct TypeKind _alloca__t5;
    _t5 = &_alloca__t5;
    SymbolTable_lookup_type(_t5, _t4, _t2);
    return;
}

void SemanticAnalyzer_check_binary(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1, uint8_t _arg2, struct TypeKind* _arg3, struct TypeKind* _arg4) {
    bool _t15;
    bool _t16;
    int64_t _t11;
    int64_t _t12;
    int64_t _t13;
    int64_t _t14;
    int64_t _t6;
    int64_t _t8;
    int64_t _t9;
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    struct TypeKind* _t3;
    struct TypeKind* _t4;
    uint8_t _t10;
    uint8_t _t2;
    uint8_t _t5;
    uint8_t _t7;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = _arg4;
    _t5 = (uint8_t)6LL;
    _t6 = _t2 >= _t5;
    _t7 = (uint8_t)11LL;
    _t8 = _t2 <= _t7;
    _t9 = _t6 && _t8;
    if (_t9) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t10 = (uint8_t)12LL;
    _t11 = _t2 >= _t10;
    if (_t11) goto L_then; else goto L_else;
L_then:
    _t12 = _t3 != TypeKind_Bool;
    _t13 = _t4 != TypeKind_Bool;
    _t14 = _t12 || _t13;
    if (_t14) goto L_then; else goto L_else;
L_else:
    goto L_merge;
L_merge:
    _t15 = SemanticAnalyzer_types_compatible(_t1, _t3, _t4);
    _t16 = !_t15;
    if (_t16) goto L_then; else goto L_else;
L_then:
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    return;
L_then:
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    return;
}

void SemanticAnalyzer_check_unary(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1, uint8_t _arg2, struct TypeKind* _arg3) {
    int64_t _t11;
    int64_t _t5;
    int64_t _t7;
    int64_t _t9;
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    struct TypeKind* _t3;
    uint8_t _t10;
    uint8_t _t2;
    uint8_t _t4;
    uint8_t _t6;
    uint8_t _t8;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = (uint8_t)0LL;
    _t5 = _t2 == _t4;
    if (_t5) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t6 = (uint8_t)1LL;
    _t7 = _t2 == _t6;
    if (_t7) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t8 = (uint8_t)2LL;
    _t9 = _t2 == _t8;
    if (_t9) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    _t10 = (uint8_t)3LL;
    _t11 = _t2 == _t10;
    if (_t11) goto L_then; else goto L_else;
L_then:
    return;
L_else:
    goto L_merge;
L_merge:
    return;
}

void SemanticAnalyzer_check_call(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1, uint8_t* _arg2) {
    struct SemanticAnalyzer* _t1;
    struct SymbolTable* _t4;
    struct SymbolTable** _t3;
    struct TypeKind* _t0;
    struct TypeKind* _t5;
    uint8_t* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t1->symbols;
    _t4 = *_t3;
    struct TypeKind _alloca__t5;
    _t5 = &_alloca__t5;
    SymbolTable_lookup_type(_t5, _t4, _t2);
    return;
}

void SemanticAnalyzer_check_field(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void SemanticAnalyzer_check_method(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void SemanticAnalyzer_check_if(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void SemanticAnalyzer_check_while(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void SemanticAnalyzer_check_for(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void SemanticAnalyzer_check_match(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void SemanticAnalyzer_resolve_type(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

bool SemanticAnalyzer_is_integer_type(struct TypeKind* _arg0) {
    int64_t _t10;
    int64_t _t11;
    int64_t _t12;
    int64_t _t13;
    int64_t _t14;
    int64_t _t15;
    int64_t _t1;
    int64_t _t2;
    int64_t _t3;
    int64_t _t4;
    int64_t _t5;
    int64_t _t6;
    int64_t _t7;
    int64_t _t8;
    int64_t _t9;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _t0 == TypeKind_I8;
    _t2 = _t0 == TypeKind_I16;
    _t3 = _t1 || _t2;
    _t4 = _t0 == TypeKind_I32;
    _t5 = _t3 || _t4;
    _t6 = _t0 == TypeKind_I64;
    _t7 = _t5 || _t6;
    _t8 = _t0 == TypeKind_U8;
    _t9 = _t7 || _t8;
    _t10 = _t0 == TypeKind_U16;
    _t11 = _t9 || _t10;
    _t12 = _t0 == TypeKind_U32;
    _t13 = _t11 || _t12;
    _t14 = _t0 == TypeKind_U64;
    _t15 = _t13 || _t14;
    return _t15;
}

bool SemanticAnalyzer_types_compatible(struct SemanticAnalyzer* _arg0, struct TypeKind* _arg1, struct TypeKind* _arg2) {
    bool _t4;
    bool _t5;
    int64_t _t10;
    int64_t _t3;
    int64_t _t6;
    int64_t _t7;
    int64_t _t8;
    int64_t _t9;
    struct SemanticAnalyzer* _t0;
    struct TypeKind* _t1;
    struct TypeKind* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _t1 == _t2;
    if (_t3) goto L_then; else goto L_else;
L_then:
    return 1;
L_else:
    goto L_merge;
L_merge:
    _t4 = SemanticAnalyzer_is_integer_type(_t1);
    _t5 = SemanticAnalyzer_is_integer_type(_t2);
    _t6 = _t4 && _t5;
    if (_t6) goto L_then; else goto L_else;
L_then:
    return 1;
L_else:
    goto L_merge;
L_merge:
    _t7 = _t1 == TypeKind_Void;
    if (_t7) goto L_then; else goto L_else;
L_then:
    return 1;
L_else:
    goto L_merge;
L_merge:
    _t8 = _t1 == TypeKind_Unknown;
    _t9 = _t2 == TypeKind_Unknown;
    _t10 = _t8 || _t9;
    if (_t10) goto L_then; else goto L_else;
L_then:
    return 1;
L_else:
    goto L_merge;
L_merge:
    return 0;
}

void SemanticAnalyzer_report_error(struct SemanticAnalyzer* _arg0, uint8_t* _arg1) {
    int64_t _t7;
    struct SemanticAnalyzer* _t0;
    uint64_t _t3;
    uint64_t _t5;
    uint64_t _t6;
    uint64_t* _t2;
    uint64_t* _t4;
    uint64_t* _t8;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->error_count;
    _t3 = *_t2;
    _t4 = &_t0->error_count;
    _t5 = *_t4;
    _t6 = (uint64_t)1LL;
    _t7 = _t5 + _t6;
    _t8 = &_t0->error_count;
    *_t8 = _t7;
    return;
}

void SemanticAnalyzer_define_builtin(struct SemanticAnalyzer* _arg0, uint8_t* _arg1, struct TypeKind* _arg2) {
    struct SemanticAnalyzer* _t0;
    struct TypeKind* _t2;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    return;
}

void SemanticAnalyzer_check_index(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void SemanticAnalyzer_check_cast(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void SemanticAnalyzer_check_struct_lit(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void SemanticAnalyzer_check_array_lit(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void SemanticAnalyzer_check_ref(struct TypeKind* _arg0, struct SemanticAnalyzer* _arg1) {
    struct SemanticAnalyzer* _t1;
    struct TypeKind* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void main(void) {
    int64_t _t0;
    int64_t _t10;
    int64_t _t7;
    struct ResolvedType* _t8;
    struct ResolvedType* _t9;
    struct SemanticAnalyzer* _t1;
    struct SemanticAnalyzer* _t2;
    struct SymbolTable* _t4;
    struct SymbolTable** _t3;
    uint64_t _t5;
    uint64_t _t6;
    
    puts("Semantic analyzer defined!");
    struct SemanticAnalyzer _alloca__t1;
    _t1 = &_alloca__t1;
    SemanticAnalyzer_new(_t1);
    _t2 = _t1;
    SemanticAnalyzer_register_builtins(_t2);
    _t3 = &_t2->symbols;
    _t4 = *_t3;
    _t5 = SymbolTable_enter_scope(_t4);
    _t6 = _t5;
    puts("Created semantic analyzer!");
    struct ResolvedType _alloca__t8;
    _t8 = &_alloca__t8;
    ResolvedType_i64_type(_t8);
    _t9 = _t8;
    puts("Semantic analysis self-hosting working!");
    return;
}

