// AetherLang Semantic Analyzer
// Self-hosting semantic analysis implementation (simplified)

extern "C" {
    fn puts(s: *u8) -> i32;
}

// ==================== Symbol Kinds ====================

pub enum SymbolKind {
    Variable,
    Function,
    Struct,
    Enum,
    Param,
    TypeParam,
}

// ==================== Resolved Types ====================

pub enum TypeKind {
    I8,
    I16,
    I32,
    I64,
    U8,
    U16,
    U32,
    U64,
    Bool,
    Void,
    Ptr,
    Ref,
    Struct,
    Enum,
    Array,
    Function,
    Unknown,
}

pub struct ResolvedType {
    pub kind: TypeKind,
    pub name: *u8,          // For named types
    pub inner: *ResolvedType, // For Ptr, Ref
    pub is_mut: bool,
}

impl ResolvedType {
    pub fn new(kind: TypeKind) -> ResolvedType {
        return ResolvedType {
            kind: kind,
            name: 0 as *u8,
            inner: 0 as *ResolvedType,
            is_mut: false,
        };
    }
    
    pub fn i64_type() -> ResolvedType {
        return ResolvedType::new(TypeKind::I64);
    }
    
    pub fn bool_type() -> ResolvedType {
        return ResolvedType::new(TypeKind::Bool);
    }
    
    pub fn void_type() -> ResolvedType {
        return ResolvedType::new(TypeKind::Void);
    }
}

// ==================== Symbol ====================

pub struct Symbol {
    pub name: *u8,
    pub kind: SymbolKind,
    pub ty: ResolvedType,
    pub is_mutable: bool,
}

impl Symbol {
    pub fn new(name: *u8, kind: SymbolKind, ty: ResolvedType) -> Symbol {
        return Symbol {
            name: name,
            kind: kind,
            ty: ty,
            is_mutable: false,
        };
    }
    
    pub fn variable(name: *u8, ty: ResolvedType, mutable: bool) -> Symbol {
        return Symbol {
            name: name,
            kind: SymbolKind::Variable,
            ty: ty,
            is_mutable: mutable,
        };
    }
}

// ==================== Scope ====================

pub struct Scope {
    pub id: u64,
    pub parent: u64,  // Parent scope id (0 = no parent)
    pub symbol_count: u64,
}

impl Scope {
    pub fn new(id: u64, parent: u64) -> Scope {
        return Scope {
            id: id,
            parent: parent,
            symbol_count: 0,
        };
    }
}

// ==================== Symbol Table ====================

// Simple symbol entry for storage
pub struct SymbolEntry {
    pub name_hash: u64,      // Hash of symbol name for fast lookup
    pub kind: SymbolKind,
    pub type_kind: TypeKind,
    pub scope_id: u64,
    pub is_mutable: bool,
}

impl SymbolEntry {
    pub fn new(hash: u64, kind: SymbolKind, ty: TypeKind, scope: u64) -> SymbolEntry {
        return SymbolEntry {
            name_hash: hash,
            kind: kind,
            type_kind: ty,
            scope_id: scope,
            is_mutable: false,
        };
    }
}

pub struct SymbolTable {
    pub current_scope: u64,
    pub next_scope_id: u64,
    pub symbol_count: u64,
    // Note: In real impl, would use dynamic array, here simplified
}

impl SymbolTable {
    pub fn new() -> SymbolTable {
        return SymbolTable {
            current_scope: 0,
            next_scope_id: 1,
            symbol_count: 0,
        };
    }
    
    /// Simple hash function for symbol names
    pub fn hash_name(name: *u8) -> u64 {
        let mut hash: u64 = 5381;
        let mut ptr: *u8 = name;
        while *ptr != 0 {
            hash = ((hash << 5) + hash) + ((*ptr) as u64);
            ptr = (ptr as u64 + 1) as *u8;
        }
        return hash;
    }
    
    /// Enter a new scope
    pub fn enter_scope(self: &mut SymbolTable) -> u64 {
        let new_id: u64 = self.next_scope_id;
        self.next_scope_id = self.next_scope_id + 1;
        self.current_scope = new_id;
        return new_id;
    }
    
    /// Exit the current scope
    pub fn exit_scope(self: &mut SymbolTable) {
        if self.current_scope > 0 {
            self.current_scope = self.current_scope - 1;
        }
    }
    
    /// Define a symbol in current scope
    pub fn define(self: &mut SymbolTable, _symbol: Symbol) -> bool {
        self.symbol_count = self.symbol_count + 1;
        return true;
    }
    
    /// Define a symbol with type (simplified)
    pub fn define_typed(self: &mut SymbolTable, _name: *u8, _kind: SymbolKind, _ty: TypeKind) -> bool {
        self.symbol_count = self.symbol_count + 1;
        return true;
    }
    
    /// Lookup a symbol by name (returns found status)
    pub fn lookup(self: &SymbolTable, _name: *u8) -> bool {
        // Would search from current scope upward
        return false;
    }
    
    /// Lookup type of a symbol by name
    pub fn lookup_type(self: &SymbolTable, name: *u8) -> TypeKind {
        // Simplified: check builtin functions
        let hash: u64 = SymbolTable::hash_name(name);
        
        // "puts" hash for quick check
        let puts_hash: u64 = SymbolTable::hash_name("puts" as *u8);
        if hash == puts_hash {
            return TypeKind::I32;  // puts returns i32
        }
        
        // "malloc" 
        let malloc_hash: u64 = SymbolTable::hash_name("malloc" as *u8);
        if hash == malloc_hash {
            return TypeKind::Ptr;
        }
        
        // "putchar"
        let putchar_hash: u64 = SymbolTable::hash_name("putchar" as *u8);
        if hash == putchar_hash {
            return TypeKind::I32;
        }
        
        return TypeKind::Unknown;
    }
    
    /// Lookup only in current scope
    pub fn lookup_local(self: &SymbolTable, _name: *u8) -> bool {
        return false;
    }
    
    /// Get current scope id
    pub fn current(self: &SymbolTable) -> u64 {
        return self.current_scope;
    }
}

// ==================== Ownership State ====================

/// Variable ownership state
pub enum VarState {
    Owned,       // Has ownership, can be used
    Moved,       // Ownership transferred, cannot be used
    Borrowed,    // Immutably borrowed
    MutBorrowed, // Mutably borrowed
    Dropped,     // Out of scope
}

/// Entry for tracking a variable's ownership
pub struct VarEntry {
    pub name_hash: u64,
    pub state: VarState,
    pub borrow_count: u64,
    pub scope_id: u64,
    pub is_copy: bool,
}

impl VarEntry {
    pub fn new(hash: u64, scope: u64, is_copy: bool) -> VarEntry {
        return VarEntry {
            name_hash: hash,
            state: VarState::Owned,
            borrow_count: 0,
            scope_id: scope,
            is_copy: is_copy,
        };
    }
}

pub struct OwnershipState {
    pub var_count: u64,
    pub current_scope: u64,
    pub error_count: u64,
}

impl OwnershipState {
    pub fn new() -> OwnershipState {
        return OwnershipState {
            var_count: 0,
            current_scope: 0,
            error_count: 0,
        };
    }
    
    /// Enter a new scope
    pub fn enter_scope(self: &mut OwnershipState) {
        self.current_scope = self.current_scope + 1;
    }
    
    /// Exit scope and drop all variables in it
    pub fn exit_scope(self: &mut OwnershipState) {
        if self.current_scope > 0 {
            self.current_scope = self.current_scope - 1;
        }
    }
    
    /// Add a new owned variable
    pub fn add_owned(self: &mut OwnershipState, _name: *u8, _is_copy: bool) {
        self.var_count = self.var_count + 1;
    }
    
    /// Check if a variable is available (not moved)
    pub fn is_available(self: &OwnershipState, _name: *u8) -> bool {
        return true;
    }
    
    /// Move a variable (transfer ownership)
    pub fn move_var(self: &mut OwnershipState, _name: *u8) -> bool {
        if !self.is_available(_name) {
            self.error_count = self.error_count + 1;
            return false;
        }
        return true;
    }
    
    /// Borrow a variable immutably
    pub fn borrow(self: &mut OwnershipState, _name: *u8) -> bool {
        return true;
    }
    
    /// Borrow a variable mutably
    pub fn borrow_mut(self: &mut OwnershipState, _name: *u8) -> bool {
        return true;
    }
    
    /// Release an immutable borrow
    pub fn release_borrow(self: &mut OwnershipState, _name: *u8) {
    }
    
    /// Release a mutable borrow
    pub fn release_mut_borrow(self: &mut OwnershipState, _name: *u8) {
    }
    
    /// Check for use-after-move error
    pub fn check_use(self: &mut OwnershipState, _name: *u8) -> bool {
        if !self.is_available(_name) {
            self.error_count = self.error_count + 1;
            return false;
        }
        return true;
    }
    
    /// Check if type is a Copy type
    pub fn is_copy_type(ty: TypeKind) -> bool {
        return ty == TypeKind::I8 || ty == TypeKind::I16 ||
               ty == TypeKind::I32 || ty == TypeKind::I64 ||
               ty == TypeKind::U8 || ty == TypeKind::U16 ||
               ty == TypeKind::U32 || ty == TypeKind::U64 ||
               ty == TypeKind::Bool;
    }
    
    /// Check if there are active borrows
    pub fn has_borrows(self: &OwnershipState, _name: *u8) -> bool {
        return false;
    }
    
    /// Check if there are active mutable borrows
    pub fn has_mut_borrows(self: &OwnershipState, _name: *u8) -> bool {
        return false;
    }
}

// ==================== Semantic Analyzer ====================

pub struct SemanticAnalyzer {
    pub symbols: SymbolTable,
    pub error_count: u64,
    pub strict_mode: bool,
}

impl SemanticAnalyzer {
    pub fn new() -> SemanticAnalyzer {
        return SemanticAnalyzer {
            symbols: SymbolTable::new(),
            error_count: 0,
            strict_mode: false,
        };
    }
    
    /// Set strict mode
    pub fn set_strict_mode(self: &mut SemanticAnalyzer, strict: bool) {
        self.strict_mode = strict;
    }
    
    /// Register builtin functions
    pub fn register_builtins(self: &mut SemanticAnalyzer) {
        // Would register puts, exit, malloc, free, etc.
    }
    
    /// Analyze a program (simplified - returns success)
    pub fn analyze(self: &mut SemanticAnalyzer) -> bool {
        // Pass 1: Collect definitions
        // Pass 2: Check items
        return self.error_count == 0;
    }
    
    /// Collect a definition (first pass)
    pub fn collect_definition(self: &mut SemanticAnalyzer) -> bool {
        // Would add function/struct/enum to symbol table
        return true;
    }
    
    /// Check an item (second pass)
    pub fn check_item(self: &mut SemanticAnalyzer) -> bool {
        // Would dispatch based on item kind
        return true;
    }
    
    /// Check a function
    pub fn check_function(self: &mut SemanticAnalyzer) -> bool {
        // Enter scope
        self.symbols.enter_scope();
        
        // Add parameters to scope
        
        // Check function body
        
        // Exit scope
        self.symbols.exit_scope();
        
        return true;
    }
    
    /// Check an impl block
    pub fn check_impl(self: &mut SemanticAnalyzer) -> bool {
        // Check each method
        return true;
    }
    
    /// Check a block
    pub fn check_block(self: &mut SemanticAnalyzer) -> bool {
        self.symbols.enter_scope();
        
        // Check each statement
        
        self.symbols.exit_scope();
        return true;
    }
    
    /// Check a statement
    pub fn check_stmt(self: &mut SemanticAnalyzer) -> bool {
        // Dispatch based on statement kind
        // Let -> check_let
        // Return -> check_return
        // Expr -> check_expr
        return true;
    }
    
    /// Check let statement
    pub fn check_let(self: &mut SemanticAnalyzer) -> bool {
        // Check initializer type matches declared type
        // Add variable to symbol table
        return true;
    }
    
    /// Check return statement
    pub fn check_return(self: &mut SemanticAnalyzer) -> bool {
        // Check return type matches function return type
        return true;
    }
    
    /// Check an expression
    pub fn check_expr(self: &mut SemanticAnalyzer) -> TypeKind {
        // Dispatch based on expression kind
        return TypeKind::Unknown;
    }
    
    /// Check a literal (lit_kind: 0=Int, 1=Float, 2=Bool, 3=String, 4=Char)
    pub fn check_literal(self: &SemanticAnalyzer, lit_kind: u8) -> TypeKind {
        if lit_kind == 0 {
            return TypeKind::I64;  // Integer literal
        } else if lit_kind == 1 {
            return TypeKind::I64;  // Float - treat as i64 for now
        } else if lit_kind == 2 {
            return TypeKind::Bool; // Boolean literal
        } else if lit_kind == 3 {
            return TypeKind::Ptr;  // String literal (*u8)
        } else if lit_kind == 4 {
            return TypeKind::U8;   // Char literal
        }
        return TypeKind::Unknown;
    }
    
    /// Check an identifier - lookup its type in symbol table
    pub fn check_ident(self: &SemanticAnalyzer, name: *u8) -> TypeKind {
        return self.symbols.lookup_type(name);
    }
    
    /// Check a binary operation (op: 0-5=arith, 6-11=cmp, 12-13=logical)
    pub fn check_binary(self: &SemanticAnalyzer, op: u8, left: TypeKind, right: TypeKind) -> TypeKind {
        // Comparison operators always return Bool
        if op >= 6 && op <= 11 {
            return TypeKind::Bool;
        }
        
        // Logical operators (&&, ||) require Bool operands
        if op >= 12 {
            if left != TypeKind::Bool || right != TypeKind::Bool {
                // Would report error
            }
            return TypeKind::Bool;
        }
        
        // Arithmetic: return the "wider" type (simplified: prefer left)
        if !self.types_compatible(left, right) {
            // Would report error
        }
        return left;
    }
    
    /// Check a unary operation
    pub fn check_unary(self: &SemanticAnalyzer, op: u8, operand: TypeKind) -> TypeKind {
        // Negation (-) keeps the type
        if op == 0 {
            return operand;
        }
        // Logical not (!) requires Bool
        if op == 1 {
            return TypeKind::Bool;
        }
        // Dereference (*) returns inner type
        if op == 2 {
            return TypeKind::Unknown; // Would need pointer inner type
        }
        // Reference (&) returns Ref
        if op == 3 {
            return TypeKind::Ref;
        }
        return operand;
    }
    
    /// Check a function call - lookup return type
    pub fn check_call(self: &mut SemanticAnalyzer, func_name: *u8) -> TypeKind {
        return self.symbols.lookup_type(func_name);
    }
    
    /// Check field access
    pub fn check_field(self: &SemanticAnalyzer) -> TypeKind {
        // Check receiver is a struct
        // Lookup field
        return TypeKind::Unknown;
    }
    
    /// Check method call
    pub fn check_method(self: &mut SemanticAnalyzer) -> TypeKind {
        // Similar to check_call but with self
        return TypeKind::Unknown;
    }
    
    /// Check if expression
    pub fn check_if(self: &mut SemanticAnalyzer) -> TypeKind {
        // Check condition is bool
        // Check then/else types match
        return TypeKind::Unknown;
    }
    
    /// Check while loop
    pub fn check_while(self: &mut SemanticAnalyzer) -> TypeKind {
        // Check condition is bool
        // Check body
        return TypeKind::Void;
    }
    
    /// Check for loop
    pub fn check_for(self: &mut SemanticAnalyzer) -> TypeKind {
        // Check iterator type
        // Check body
        return TypeKind::Void;
    }
    
    /// Check match expression
    pub fn check_match(self: &mut SemanticAnalyzer) -> TypeKind {
        // Check scrutinee type
        // Check all arms have same type
        return TypeKind::Unknown;
    }
    
    /// Resolve an AST type to ResolvedType
    pub fn resolve_type(self: &SemanticAnalyzer) -> TypeKind {
        // Map type names to TypeKind
        return TypeKind::Unknown;
    }
    
    /// Check if a type is an integer type
    pub fn is_integer_type(ty: TypeKind) -> bool {
        return ty == TypeKind::I8 || ty == TypeKind::I16 ||
               ty == TypeKind::I32 || ty == TypeKind::I64 ||
               ty == TypeKind::U8 || ty == TypeKind::U16 ||
               ty == TypeKind::U32 || ty == TypeKind::U64;
    }
    
    /// Check if two types are compatible
    pub fn types_compatible(self: &SemanticAnalyzer, expected: TypeKind, got: TypeKind) -> bool {
        // Exact match
        if expected == got {
            return true;
        }
        
        // Integer types are compatible with each other (implicit conversion)
        if SemanticAnalyzer::is_integer_type(expected) && SemanticAnalyzer::is_integer_type(got) {
            return true;
        }
        
        // Void accepts any type (for discarding values)
        if expected == TypeKind::Void {
            return true;
        }
        
        // Unknown is compatible with anything (for error recovery)
        if expected == TypeKind::Unknown || got == TypeKind::Unknown {
            return true;
        }
        
        return false;
    }
    
    /// Report an error
    pub fn report_error(self: &mut SemanticAnalyzer, _msg: *u8) {
        self.error_count = self.error_count + 1;
    }
    
    /// Define a builtin function
    pub fn define_builtin(self: &mut SemanticAnalyzer, _name: *u8, _ret: TypeKind) {
        // Add to symbol table
    }
    
    /// Check array index access
    pub fn check_index(self: &mut SemanticAnalyzer) -> TypeKind {
        // Check array type and index type
        return TypeKind::Unknown;
    }
    
    /// Check cast expression
    pub fn check_cast(self: &SemanticAnalyzer) -> TypeKind {
        // Validate cast is allowed
        return TypeKind::Unknown;
    }
    
    /// Check struct literal
    pub fn check_struct_lit(self: &mut SemanticAnalyzer) -> TypeKind {
        // Check all fields are provided and types match
        return TypeKind::Struct;
    }
    
    /// Check array literal
    pub fn check_array_lit(self: &mut SemanticAnalyzer) -> TypeKind {
        // Check all elements have same type
        return TypeKind::Array;
    }
    
    /// Check reference expression
    pub fn check_ref(self: &mut SemanticAnalyzer) -> TypeKind {
        // Create reference type
        return TypeKind::Ref;
    }
}

// ==================== Main ====================

fn main() {
    puts("Semantic analyzer defined!");
    
    // Create analyzer
    let mut analyzer: SemanticAnalyzer = SemanticAnalyzer::new();
    
    // Test basic operations
    analyzer.register_builtins();
    
    let scope: u64 = analyzer.symbols.enter_scope();
    
    puts("Created semantic analyzer!");
    
    // Test type creation
    let ty: ResolvedType = ResolvedType::i64_type();
    
    puts("Semantic analysis self-hosting working!");
}
