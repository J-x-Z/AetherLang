/* Generated by AetherLang C Backend */
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <immintrin.h>  /* SSE/AVX */

/* AetherLang Runtime */
static void aether_print(const char* s) { printf("%s", s); }
static void aether_println(const char* s) { printf("%s\n", s); }
static void aether_print_i64(int64_t n) { printf("%lld", (long long)n); }
static void aether_println_i64(int64_t n) { printf("%lld\n", (long long)n); }
static void aether_assert(bool c) { if(!c) { fprintf(stderr, "Assertion failed\n"); exit(1); } }

/* Struct Definitions */
struct Register {
    uint64_t id;
    struct IRType* ty;
};

struct Value {
    struct ValueKind* kind;
    uint64_t reg;
    int64_t int_val;
    uint8_t* name;
};

struct Instruction {
    struct InstrKind* kind;
    uint64_t dest;
    struct BinOp* op;
    struct Value* src1;
    struct Value* src2;
};

struct Terminator {
    struct TerminatorKind* kind;
    struct Value* value;
    uint64_t target;
    struct Value* cond;
    uint64_t then_target;
    uint64_t else_target;
};

struct BasicBlock {
    uint64_t id;
    uint8_t* label;
    uint64_t instr_count;
    bool has_terminator;
};

struct IRFunction {
    uint8_t* name;
    uint64_t param_count;
    uint64_t block_count;
    uint64_t next_reg;
    struct IRType* return_type;
};

struct IRModule {
    uint8_t* name;
    uint64_t func_count;
    uint64_t global_count;
};

struct IRGenerator {
    struct IRModule* module;
    uint64_t next_reg;
    uint64_t next_block;
    uint64_t current_function;
    uint64_t current_block;
};

void Register_new(struct Register*, uint64_t, struct IRType*);
void Value_from_reg(struct Value*, uint64_t);
void Value_from_const(struct Value*, int64_t);
void Value_from_global(struct Value*, uint8_t*);
void Instruction_binop(struct Instruction*, uint64_t, struct BinOp*, struct Value*, struct Value*);
void Instruction_load(struct Instruction*, uint64_t, struct Value*);
void Instruction_store(struct Instruction*, struct Value*, struct Value*);
void Instruction_alloca(struct Instruction*, uint64_t);
void Terminator_ret(struct Terminator*, struct Value*);
void Terminator_branch(struct Terminator*, uint64_t);
void Terminator_cond_branch(struct Terminator*, struct Value*, uint64_t, uint64_t);
void BasicBlock_new(struct BasicBlock*, uint64_t, uint8_t*);
void IRFunction_new(struct IRFunction*, uint8_t*, struct IRType*);
uint64_t IRFunction_alloc_reg(struct IRFunction*);
uint64_t IRFunction_add_block(struct IRFunction*);
void IRModule_new(struct IRModule*, uint8_t*);
uint64_t IRModule_add_function(struct IRModule*);
void IRGenerator_new(struct IRGenerator*, uint8_t*);
bool IRGenerator_generate(struct IRGenerator*);
bool IRGenerator_generate_item(struct IRGenerator*);
bool IRGenerator_generate_function(struct IRGenerator*);
bool IRGenerator_generate_method(struct IRGenerator*);
void IRGenerator_generate_block(struct Value*, struct IRGenerator*);
void IRGenerator_generate_stmt(struct Value*, struct IRGenerator*);
void IRGenerator_generate_expr_kind(struct Value*, struct IRGenerator*, uint8_t, int64_t, uint8_t);
void IRGenerator_generate_expr(struct Value*, struct IRGenerator*);
void IRGenerator_generate_literal(struct Value*, struct IRGenerator*, int64_t);
void IRGenerator_generate_binary_op(struct Value*, struct IRGenerator*, uint8_t);
void IRGenerator_generate_binary(struct Value*, struct IRGenerator*);
void IRGenerator_generate_unary_op(struct Value*, struct IRGenerator*, uint8_t);
void IRGenerator_generate_unary(struct Value*, struct IRGenerator*);
void IRGenerator_generate_call_instr(struct Value*, struct IRGenerator*);
void IRGenerator_generate_call(struct Value*, struct IRGenerator*);
void IRGenerator_generate_if_expr(struct Value*, struct IRGenerator*);
void IRGenerator_generate_if(struct Value*, struct IRGenerator*);
void IRGenerator_generate_while_loop(struct Value*, struct IRGenerator*);
void IRGenerator_generate_while(struct Value*, struct IRGenerator*);
void IRGenerator_generate_match(struct Value*, struct IRGenerator*);
void IRGenerator_generate_field_access(struct Value*, struct IRGenerator*);
void IRGenerator_generate_field(struct Value*, struct IRGenerator*);
void IRGenerator_generate_index_access(struct Value*, struct IRGenerator*);
void IRGenerator_generate_index(struct Value*, struct IRGenerator*);
uint64_t IRGenerator_alloc_reg(struct IRGenerator*);
uint64_t IRGenerator_alloc_block(struct IRGenerator*);
void IRGenerator_emit(struct IRGenerator*, struct Instruction*);
void IRGenerator_set_terminator(struct IRGenerator*, struct Terminator*);
bool IRGenerator_has_terminator(struct IRGenerator*);
void IRGenerator_ast_binop_to_ir(struct BinOp*, uint8_t);
void IRGenerator_ast_type_to_ir(struct IRType*, struct IRGenerator*);
void IRGenerator_get_value_type(struct IRType*, struct IRGenerator*, struct Value*);
bool IRGenerator_is_integer_type(struct IRType*);
void main(void);

void Register_new(struct Register* _arg0, uint64_t _arg1, struct IRType* _arg2) {
    struct IRType* _t2;
    struct IRType** _t4;
    struct Register* _t0;
    uint64_t _t1;
    uint64_t* _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t0->id;
    *_t3 = _t1;
    _t4 = &_t0->ty;
    *_t4 = _t2;
    return;
}

void Value_from_reg(struct Value* _arg0, uint64_t _arg1) {
    int64_t* _t4;
    struct Value* _t0;
    struct ValueKind** _t2;
    uint64_t _t1;
    uint64_t* _t3;
    uint8_t* _t5;
    uint8_t** _t6;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->kind;
    *_t2 = ValueKind_Register;
    _t3 = &_t0->reg;
    *_t3 = _t1;
    _t4 = &_t0->int_val;
    *_t4 = 0LL;
    _t5 = (uint8_t*)0LL;
    _t6 = &_t0->name;
    *_t6 = _t5;
    return;
}

void Value_from_const(struct Value* _arg0, int64_t _arg1) {
    int64_t _t1;
    int64_t* _t4;
    struct Value* _t0;
    struct ValueKind** _t2;
    uint64_t* _t3;
    uint8_t* _t5;
    uint8_t** _t6;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->kind;
    *_t2 = ValueKind_Constant;
    _t3 = &_t0->reg;
    *_t3 = 0LL;
    _t4 = &_t0->int_val;
    *_t4 = _t1;
    _t5 = (uint8_t*)0LL;
    _t6 = &_t0->name;
    *_t6 = _t5;
    return;
}

void Value_from_global(struct Value* _arg0, uint8_t* _arg1) {
    int64_t* _t4;
    struct Value* _t0;
    struct ValueKind** _t2;
    uint64_t* _t3;
    uint8_t* _t1;
    uint8_t** _t5;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->kind;
    *_t2 = ValueKind_Global;
    _t3 = &_t0->reg;
    *_t3 = 0LL;
    _t4 = &_t0->int_val;
    *_t4 = 0LL;
    _t5 = &_t0->name;
    *_t5 = _t1;
    return;
}

void Instruction_binop(struct Instruction* _arg0, uint64_t _arg1, struct BinOp* _arg2, struct Value* _arg3, struct Value* _arg4) {
    struct BinOp* _t2;
    struct BinOp** _t7;
    struct InstrKind** _t5;
    struct Instruction* _t0;
    struct Value* _t3;
    struct Value* _t4;
    struct Value** _t8;
    struct Value** _t9;
    uint64_t _t1;
    uint64_t* _t6;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = _arg4;
    _t5 = &_t0->kind;
    *_t5 = InstrKind_BinOp;
    _t6 = &_t0->dest;
    *_t6 = _t1;
    _t7 = &_t0->op;
    *_t7 = _t2;
    _t8 = &_t0->src1;
    *_t8 = _t3;
    _t9 = &_t0->src2;
    *_t9 = _t4;
    return;
}

void Instruction_load(struct Instruction* _arg0, uint64_t _arg1, struct Value* _arg2) {
    struct BinOp** _t5;
    struct InstrKind** _t3;
    struct Instruction* _t0;
    struct Value* _t2;
    struct Value* _t7;
    struct Value** _t6;
    struct Value** _t8;
    uint64_t _t1;
    uint64_t* _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t0->kind;
    *_t3 = InstrKind_Load;
    _t4 = &_t0->dest;
    *_t4 = _t1;
    _t5 = &_t0->op;
    *_t5 = BinOp_Add;
    _t6 = &_t0->src1;
    *_t6 = _t2;
    struct Value _alloca__t7;
    _t7 = &_alloca__t7;
    Value_from_const(_t7, 0LL);
    _t8 = &_t0->src2;
    *_t8 = _t7;
    return;
}

void Instruction_store(struct Instruction* _arg0, struct Value* _arg1, struct Value* _arg2) {
    struct BinOp** _t5;
    struct InstrKind** _t3;
    struct Instruction* _t0;
    struct Value* _t1;
    struct Value* _t2;
    struct Value** _t6;
    struct Value** _t7;
    uint64_t* _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t0->kind;
    *_t3 = InstrKind_Store;
    _t4 = &_t0->dest;
    *_t4 = 0LL;
    _t5 = &_t0->op;
    *_t5 = BinOp_Add;
    _t6 = &_t0->src1;
    *_t6 = _t1;
    _t7 = &_t0->src2;
    *_t7 = _t2;
    return;
}

void Instruction_alloca(struct Instruction* _arg0, uint64_t _arg1) {
    struct BinOp** _t4;
    struct InstrKind** _t2;
    struct Instruction* _t0;
    struct Value* _t5;
    struct Value* _t7;
    struct Value** _t6;
    struct Value** _t8;
    uint64_t _t1;
    uint64_t* _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->kind;
    *_t2 = InstrKind_Alloca;
    _t3 = &_t0->dest;
    *_t3 = _t1;
    _t4 = &_t0->op;
    *_t4 = BinOp_Add;
    struct Value _alloca__t5;
    _t5 = &_alloca__t5;
    Value_from_const(_t5, 0LL);
    _t6 = &_t0->src1;
    *_t6 = _t5;
    struct Value _alloca__t7;
    _t7 = &_alloca__t7;
    Value_from_const(_t7, 0LL);
    _t8 = &_t0->src2;
    *_t8 = _t7;
    return;
}

void Terminator_ret(struct Terminator* _arg0, struct Value* _arg1) {
    struct Terminator* _t0;
    struct TerminatorKind** _t2;
    struct Value* _t1;
    struct Value* _t5;
    struct Value** _t3;
    struct Value** _t6;
    uint64_t* _t4;
    uint64_t* _t7;
    uint64_t* _t8;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->kind;
    *_t2 = TerminatorKind_Return;
    _t3 = &_t0->value;
    *_t3 = _t1;
    _t4 = &_t0->target;
    *_t4 = 0LL;
    struct Value _alloca__t5;
    _t5 = &_alloca__t5;
    Value_from_const(_t5, 0LL);
    _t6 = &_t0->cond;
    *_t6 = _t5;
    _t7 = &_t0->then_target;
    *_t7 = 0LL;
    _t8 = &_t0->else_target;
    *_t8 = 0LL;
    return;
}

void Terminator_branch(struct Terminator* _arg0, uint64_t _arg1) {
    struct Terminator* _t0;
    struct TerminatorKind** _t2;
    struct Value* _t3;
    struct Value* _t6;
    struct Value** _t4;
    struct Value** _t7;
    uint64_t _t1;
    uint64_t* _t5;
    uint64_t* _t8;
    uint64_t* _t9;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->kind;
    *_t2 = TerminatorKind_Branch;
    struct Value _alloca__t3;
    _t3 = &_alloca__t3;
    Value_from_const(_t3, 0LL);
    _t4 = &_t0->value;
    *_t4 = _t3;
    _t5 = &_t0->target;
    *_t5 = _t1;
    struct Value _alloca__t6;
    _t6 = &_alloca__t6;
    Value_from_const(_t6, 0LL);
    _t7 = &_t0->cond;
    *_t7 = _t6;
    _t8 = &_t0->then_target;
    *_t8 = 0LL;
    _t9 = &_t0->else_target;
    *_t9 = 0LL;
    return;
}

void Terminator_cond_branch(struct Terminator* _arg0, struct Value* _arg1, uint64_t _arg2, uint64_t _arg3) {
    struct Terminator* _t0;
    struct TerminatorKind** _t4;
    struct Value* _t1;
    struct Value* _t5;
    struct Value** _t6;
    struct Value** _t8;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t* _t10;
    uint64_t* _t7;
    uint64_t* _t9;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = &_t0->kind;
    *_t4 = TerminatorKind_CondBranch;
    struct Value _alloca__t5;
    _t5 = &_alloca__t5;
    Value_from_const(_t5, 0LL);
    _t6 = &_t0->value;
    *_t6 = _t5;
    _t7 = &_t0->target;
    *_t7 = 0LL;
    _t8 = &_t0->cond;
    *_t8 = _t1;
    _t9 = &_t0->then_target;
    *_t9 = _t2;
    _t10 = &_t0->else_target;
    *_t10 = _t3;
    return;
}

void BasicBlock_new(struct BasicBlock* _arg0, uint64_t _arg1, uint8_t* _arg2) {
    bool* _t6;
    struct BasicBlock* _t0;
    uint64_t _t1;
    uint64_t* _t3;
    uint64_t* _t5;
    uint8_t* _t2;
    uint8_t** _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t0->id;
    *_t3 = _t1;
    _t4 = &_t0->label;
    *_t4 = _t2;
    _t5 = &_t0->instr_count;
    *_t5 = 0LL;
    _t6 = &_t0->has_terminator;
    *_t6 = 0;
    return;
}

void IRFunction_new(struct IRFunction* _arg0, uint8_t* _arg1, struct IRType* _arg2) {
    struct IRFunction* _t0;
    struct IRType* _t2;
    struct IRType** _t7;
    uint64_t* _t4;
    uint64_t* _t5;
    uint64_t* _t6;
    uint8_t* _t1;
    uint8_t** _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = &_t0->name;
    *_t3 = _t1;
    _t4 = &_t0->param_count;
    *_t4 = 0LL;
    _t5 = &_t0->block_count;
    *_t5 = 0LL;
    _t6 = &_t0->next_reg;
    *_t6 = 0LL;
    _t7 = &_t0->return_type;
    *_t7 = _t2;
    return;
}

uint64_t IRFunction_alloc_reg(struct IRFunction* _arg0) {
    int64_t _t9;
    struct IRFunction* _t0;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t _t5;
    uint64_t _t7;
    uint64_t _t8;
    uint64_t* _t10;
    uint64_t* _t1;
    uint64_t* _t4;
    uint64_t* _t6;
    
    _t0 = _arg0;
    _t1 = &_t0->next_reg;
    _t2 = *_t1;
    _t3 = _t2;
    _t4 = &_t0->next_reg;
    _t5 = *_t4;
    _t6 = &_t0->next_reg;
    _t7 = *_t6;
    _t8 = (uint64_t)1LL;
    _t9 = _t7 + _t8;
    _t10 = &_t0->next_reg;
    *_t10 = _t9;
    return _t3;
}

uint64_t IRFunction_add_block(struct IRFunction* _arg0) {
    int64_t _t9;
    struct IRFunction* _t0;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t _t5;
    uint64_t _t7;
    uint64_t _t8;
    uint64_t* _t10;
    uint64_t* _t1;
    uint64_t* _t4;
    uint64_t* _t6;
    
    _t0 = _arg0;
    _t1 = &_t0->block_count;
    _t2 = *_t1;
    _t3 = _t2;
    _t4 = &_t0->block_count;
    _t5 = *_t4;
    _t6 = &_t0->block_count;
    _t7 = *_t6;
    _t8 = (uint64_t)1LL;
    _t9 = _t7 + _t8;
    _t10 = &_t0->block_count;
    *_t10 = _t9;
    return _t3;
}

void IRModule_new(struct IRModule* _arg0, uint8_t* _arg1) {
    struct IRModule* _t0;
    uint64_t* _t3;
    uint64_t* _t4;
    uint8_t* _t1;
    uint8_t** _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = &_t0->name;
    *_t2 = _t1;
    _t3 = &_t0->func_count;
    *_t3 = 0LL;
    _t4 = &_t0->global_count;
    *_t4 = 0LL;
    return;
}

uint64_t IRModule_add_function(struct IRModule* _arg0) {
    int64_t _t9;
    struct IRModule* _t0;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t _t5;
    uint64_t _t7;
    uint64_t _t8;
    uint64_t* _t10;
    uint64_t* _t1;
    uint64_t* _t4;
    uint64_t* _t6;
    
    _t0 = _arg0;
    _t1 = &_t0->func_count;
    _t2 = *_t1;
    _t3 = _t2;
    _t4 = &_t0->func_count;
    _t5 = *_t4;
    _t6 = &_t0->func_count;
    _t7 = *_t6;
    _t8 = (uint64_t)1LL;
    _t9 = _t7 + _t8;
    _t10 = &_t0->func_count;
    *_t10 = _t9;
    return _t3;
}

void IRGenerator_new(struct IRGenerator* _arg0, uint8_t* _arg1) {
    struct IRGenerator* _t0;
    struct IRModule* _t2;
    struct IRModule** _t3;
    uint64_t* _t4;
    uint64_t* _t5;
    uint64_t* _t6;
    uint64_t* _t7;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct IRModule _alloca__t2;
    _t2 = &_alloca__t2;
    IRModule_new(_t2, _t1);
    _t3 = &_t0->module;
    *_t3 = _t2;
    _t4 = &_t0->next_reg;
    *_t4 = 0LL;
    _t5 = &_t0->next_block;
    *_t5 = 0LL;
    _t6 = &_t0->current_function;
    *_t6 = 0LL;
    _t7 = &_t0->current_block;
    *_t7 = 0LL;
    return;
}

bool IRGenerator_generate(struct IRGenerator* _arg0) {
    struct IRGenerator* _t0;
    
    _t0 = _arg0;
    return 1;
}

bool IRGenerator_generate_item(struct IRGenerator* _arg0) {
    struct IRGenerator* _t0;
    
    _t0 = _arg0;
    return 1;
}

bool IRGenerator_generate_function(struct IRGenerator* _arg0) {
    struct IRGenerator* _t0;
    struct IRModule* _t2;
    struct IRModule** _t1;
    struct Value* _t10;
    uint64_t _t3;
    uint64_t _t4;
    uint64_t _t6;
    uint64_t _t8;
    uint64_t _t9;
    uint64_t* _t5;
    uint64_t* _t7;
    
    _t0 = _arg0;
    _t1 = &_t0->module;
    _t2 = *_t1;
    _t3 = IRModule_add_function(_t2);
    _t4 = _t3;
    _t5 = &_t0->next_block;
    _t6 = *_t5;
    _t7 = &_t0->next_block;
    *_t7 = 0LL;
    _t8 = IRGenerator_alloc_block(_t0);
    _t9 = _t8;
    struct Value _alloca__t10;
    _t10 = &_alloca__t10;
    IRGenerator_generate_block(_t10, _t0);
    return 1;
}

bool IRGenerator_generate_method(struct IRGenerator* _arg0) {
    bool _t1;
    struct IRGenerator* _t0;
    
    _t0 = _arg0;
    _t1 = IRGenerator_generate_function(_t0);
    return _t1;
}

void IRGenerator_generate_block(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct Value _alloca__t2;
    _t2 = &_alloca__t2;
    Value_from_const(_t2, 0LL);
    return;
}

void IRGenerator_generate_stmt(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct Value _alloca__t2;
    _t2 = &_alloca__t2;
    Value_from_const(_t2, 0LL);
    return;
}

void IRGenerator_generate_expr_kind(struct Value* _arg0, struct IRGenerator* _arg1, uint8_t _arg2, int64_t _arg3, uint8_t _arg4) {
    int64_t _t13;
    int64_t _t16;
    int64_t _t19;
    int64_t _t22;
    int64_t _t25;
    int64_t _t28;
    int64_t _t3;
    int64_t _t6;
    int64_t _t9;
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t10;
    struct Value* _t11;
    struct Value* _t14;
    struct Value* _t17;
    struct Value* _t20;
    struct Value* _t23;
    struct Value* _t26;
    struct Value* _t29;
    struct Value* _t7;
    uint8_t _t12;
    uint8_t _t15;
    uint8_t _t18;
    uint8_t _t21;
    uint8_t _t24;
    uint8_t _t27;
    uint8_t _t2;
    uint8_t _t4;
    uint8_t _t5;
    uint8_t _t8;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _t4 = _arg4;
    _t5 = (uint8_t)0LL;
    _t6 = _t2 == _t5;
    if (_t6) goto L_then; else goto L_else;
L_then:
    struct Value _alloca__t7;
    _t7 = &_alloca__t7;
    Value_from_const(_t7, _t3);
    return;
L_else:
    _t8 = (uint8_t)1LL;
    _t9 = _t2 == _t8;
    if (_t9) goto L_then; else goto L_else;
L_merge:
    struct Value _alloca__t10;
    _t10 = &_alloca__t10;
    Value_from_const(_t10, 0LL);
    return;
L_then:
    struct Value _alloca__t11;
    _t11 = &_alloca__t11;
    Value_from_reg(_t11, 0LL);
    return;
L_else:
    _t12 = (uint8_t)2LL;
    _t13 = _t2 == _t12;
    if (_t13) goto L_then; else goto L_else;
L_merge:
    goto L_merge;
L_then:
    struct Value _alloca__t14;
    _t14 = &_alloca__t14;
    IRGenerator_generate_binary_op(_t14, _t1, _t4);
    return;
L_else:
    _t15 = (uint8_t)3LL;
    _t16 = _t2 == _t15;
    if (_t16) goto L_then; else goto L_else;
L_merge:
    goto L_merge;
L_then:
    struct Value _alloca__t17;
    _t17 = &_alloca__t17;
    IRGenerator_generate_unary_op(_t17, _t1, _t4);
    return;
L_else:
    _t18 = (uint8_t)4LL;
    _t19 = _t2 == _t18;
    if (_t19) goto L_then; else goto L_else;
L_merge:
    goto L_merge;
L_then:
    struct Value _alloca__t20;
    _t20 = &_alloca__t20;
    IRGenerator_generate_call_instr(_t20, _t1);
    return;
L_else:
    _t21 = (uint8_t)5LL;
    _t22 = _t2 == _t21;
    if (_t22) goto L_then; else goto L_else;
L_merge:
    goto L_merge;
L_then:
    struct Value _alloca__t23;
    _t23 = &_alloca__t23;
    IRGenerator_generate_field_access(_t23, _t1);
    return;
L_else:
    _t24 = (uint8_t)6LL;
    _t25 = _t2 == _t24;
    if (_t25) goto L_then; else goto L_else;
L_merge:
    goto L_merge;
L_then:
    struct Value _alloca__t26;
    _t26 = &_alloca__t26;
    IRGenerator_generate_index_access(_t26, _t1);
    return;
L_else:
    _t27 = (uint8_t)7LL;
    _t28 = _t2 == _t27;
    if (_t28) goto L_then; else goto L_else;
L_merge:
    goto L_merge;
L_then:
    struct Value _alloca__t29;
    _t29 = &_alloca__t29;
    IRGenerator_generate_if_expr(_t29, _t1);
    return;
L_else:
    goto L_merge;
L_merge:
    goto L_merge;
}

void IRGenerator_generate_expr(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct Value _alloca__t2;
    _t2 = &_alloca__t2;
    Value_from_const(_t2, 0LL);
    return;
}

void IRGenerator_generate_literal(struct Value* _arg0, struct IRGenerator* _arg1, int64_t _arg2) {
    int64_t _t2;
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    struct Value _alloca__t3;
    _t3 = &_alloca__t3;
    Value_from_const(_t3, _t2);
    return;
}

void IRGenerator_generate_binary_op(struct Value* _arg0, struct IRGenerator* _arg1, uint8_t _arg2) {
    struct BinOp* _t5;
    struct BinOp* _t6;
    struct IRGenerator* _t1;
    struct Instruction* _t11;
    struct Instruction* _t12;
    struct Value* _t0;
    struct Value* _t10;
    struct Value* _t13;
    struct Value* _t7;
    struct Value* _t8;
    struct Value* _t9;
    uint64_t _t3;
    uint64_t _t4;
    uint8_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = IRGenerator_alloc_reg(_t1);
    _t4 = _t3;
    struct BinOp _alloca__t5;
    _t5 = &_alloca__t5;
    IRGenerator_ast_binop_to_ir(_t5, _t2);
    _t6 = _t5;
    struct Value _alloca__t7;
    _t7 = &_alloca__t7;
    Value_from_reg(_t7, 0LL);
    _t8 = _t7;
    struct Value _alloca__t9;
    _t9 = &_alloca__t9;
    Value_from_reg(_t9, 1LL);
    _t10 = _t9;
    struct Instruction _alloca__t11;
    _t11 = &_alloca__t11;
    Instruction_binop(_t11, _t4, _t6, _t8, _t10);
    _t12 = _t11;
    IRGenerator_emit(_t1, _t12);
    struct Value _alloca__t13;
    _t13 = &_alloca__t13;
    Value_from_reg(_t13, _t4);
    return;
}

void IRGenerator_generate_binary(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct Value _alloca__t2;
    _t2 = &_alloca__t2;
    IRGenerator_generate_binary_op(_t2, _t1, 0LL);
    return;
}

void IRGenerator_generate_unary_op(struct Value* _arg0, struct IRGenerator* _arg1, uint8_t _arg2) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t5;
    uint64_t _t3;
    uint64_t _t4;
    uint8_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = IRGenerator_alloc_reg(_t1);
    _t4 = _t3;
    struct Value _alloca__t5;
    _t5 = &_alloca__t5;
    Value_from_reg(_t5, _t4);
    return;
}

void IRGenerator_generate_unary(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct Value _alloca__t2;
    _t2 = &_alloca__t2;
    IRGenerator_generate_unary_op(_t2, _t1, 0LL);
    return;
}

void IRGenerator_generate_call_instr(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t4;
    uint64_t _t2;
    uint64_t _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = IRGenerator_alloc_reg(_t1);
    _t3 = _t2;
    struct Value _alloca__t4;
    _t4 = &_alloca__t4;
    Value_from_reg(_t4, _t3);
    return;
}

void IRGenerator_generate_call(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct Value _alloca__t2;
    _t2 = &_alloca__t2;
    IRGenerator_generate_call_instr(_t2, _t1);
    return;
}

void IRGenerator_generate_if_expr(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Terminator* _t10;
    struct Terminator* _t11;
    struct Terminator* _t15;
    struct Terminator* _t16;
    struct Terminator* _t20;
    struct Value* _t0;
    struct Value* _t24;
    struct Value* _t8;
    struct Value* _t9;
    uint64_t _t13;
    uint64_t _t18;
    uint64_t _t22;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t _t4;
    uint64_t _t5;
    uint64_t _t6;
    uint64_t _t7;
    uint64_t* _t12;
    uint64_t* _t14;
    uint64_t* _t17;
    uint64_t* _t19;
    uint64_t* _t21;
    uint64_t* _t23;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = IRGenerator_alloc_block(_t1);
    _t3 = _t2;
    _t4 = IRGenerator_alloc_block(_t1);
    _t5 = _t4;
    _t6 = IRGenerator_alloc_block(_t1);
    _t7 = _t6;
    struct Value _alloca__t8;
    _t8 = &_alloca__t8;
    Value_from_reg(_t8, 0LL);
    _t9 = _t8;
    struct Terminator _alloca__t10;
    _t10 = &_alloca__t10;
    Terminator_cond_branch(_t10, _t9, _t3, _t5);
    _t11 = _t10;
    IRGenerator_set_terminator(_t1, _t11);
    _t12 = &_t1->current_block;
    _t13 = *_t12;
    _t14 = &_t1->current_block;
    *_t14 = _t3;
    struct Terminator _alloca__t15;
    _t15 = &_alloca__t15;
    Terminator_branch(_t15, _t7);
    _t16 = _t15;
    IRGenerator_set_terminator(_t1, _t16);
    _t17 = &_t1->current_block;
    _t18 = *_t17;
    _t19 = &_t1->current_block;
    *_t19 = _t5;
    struct Terminator _alloca__t20;
    _t20 = &_alloca__t20;
    Terminator_branch(_t20, _t7);
    IRGenerator_set_terminator(_t1, _t20);
    _t21 = &_t1->current_block;
    _t22 = *_t21;
    _t23 = &_t1->current_block;
    *_t23 = _t7;
    struct Value _alloca__t24;
    _t24 = &_alloca__t24;
    Value_from_const(_t24, 0LL);
    return;
}

void IRGenerator_generate_if(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct Value _alloca__t2;
    _t2 = &_alloca__t2;
    IRGenerator_generate_if_expr(_t2, _t1);
    return;
}

void IRGenerator_generate_while_loop(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Terminator* _t14;
    struct Terminator* _t18;
    struct Terminator* _t8;
    struct Value* _t0;
    struct Value* _t12;
    struct Value* _t13;
    struct Value* _t22;
    uint64_t _t10;
    uint64_t _t16;
    uint64_t _t20;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t _t4;
    uint64_t _t5;
    uint64_t _t6;
    uint64_t _t7;
    uint64_t* _t11;
    uint64_t* _t15;
    uint64_t* _t17;
    uint64_t* _t19;
    uint64_t* _t21;
    uint64_t* _t9;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = IRGenerator_alloc_block(_t1);
    _t3 = _t2;
    _t4 = IRGenerator_alloc_block(_t1);
    _t5 = _t4;
    _t6 = IRGenerator_alloc_block(_t1);
    _t7 = _t6;
    struct Terminator _alloca__t8;
    _t8 = &_alloca__t8;
    Terminator_branch(_t8, _t3);
    IRGenerator_set_terminator(_t1, _t8);
    _t9 = &_t1->current_block;
    _t10 = *_t9;
    _t11 = &_t1->current_block;
    *_t11 = _t3;
    struct Value _alloca__t12;
    _t12 = &_alloca__t12;
    Value_from_reg(_t12, 0LL);
    _t13 = _t12;
    struct Terminator _alloca__t14;
    _t14 = &_alloca__t14;
    Terminator_cond_branch(_t14, _t13, _t5, _t7);
    IRGenerator_set_terminator(_t1, _t14);
    _t15 = &_t1->current_block;
    _t16 = *_t15;
    _t17 = &_t1->current_block;
    *_t17 = _t5;
    struct Terminator _alloca__t18;
    _t18 = &_alloca__t18;
    Terminator_branch(_t18, _t3);
    IRGenerator_set_terminator(_t1, _t18);
    _t19 = &_t1->current_block;
    _t20 = *_t19;
    _t21 = &_t1->current_block;
    *_t21 = _t7;
    struct Value _alloca__t22;
    _t22 = &_alloca__t22;
    Value_from_const(_t22, 0LL);
    return;
}

void IRGenerator_generate_while(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct Value _alloca__t2;
    _t2 = &_alloca__t2;
    IRGenerator_generate_while_loop(_t2, _t1);
    return;
}

void IRGenerator_generate_match(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct Value _alloca__t2;
    _t2 = &_alloca__t2;
    Value_from_const(_t2, 0LL);
    return;
}

void IRGenerator_generate_field_access(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t4;
    uint64_t _t2;
    uint64_t _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = IRGenerator_alloc_reg(_t1);
    _t3 = _t2;
    struct Value _alloca__t4;
    _t4 = &_alloca__t4;
    Value_from_reg(_t4, _t3);
    return;
}

void IRGenerator_generate_field(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct Value _alloca__t2;
    _t2 = &_alloca__t2;
    IRGenerator_generate_field_access(_t2, _t1);
    return;
}

void IRGenerator_generate_index_access(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t4;
    uint64_t _t2;
    uint64_t _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = IRGenerator_alloc_reg(_t1);
    _t3 = _t2;
    struct Value _alloca__t4;
    _t4 = &_alloca__t4;
    Value_from_reg(_t4, _t3);
    return;
}

void IRGenerator_generate_index(struct Value* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct Value* _t0;
    struct Value* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct Value _alloca__t2;
    _t2 = &_alloca__t2;
    IRGenerator_generate_index_access(_t2, _t1);
    return;
}

uint64_t IRGenerator_alloc_reg(struct IRGenerator* _arg0) {
    int64_t _t9;
    struct IRGenerator* _t0;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t _t5;
    uint64_t _t7;
    uint64_t _t8;
    uint64_t* _t10;
    uint64_t* _t1;
    uint64_t* _t4;
    uint64_t* _t6;
    
    _t0 = _arg0;
    _t1 = &_t0->next_reg;
    _t2 = *_t1;
    _t3 = _t2;
    _t4 = &_t0->next_reg;
    _t5 = *_t4;
    _t6 = &_t0->next_reg;
    _t7 = *_t6;
    _t8 = (uint64_t)1LL;
    _t9 = _t7 + _t8;
    _t10 = &_t0->next_reg;
    *_t10 = _t9;
    return _t3;
}

uint64_t IRGenerator_alloc_block(struct IRGenerator* _arg0) {
    int64_t _t9;
    struct IRGenerator* _t0;
    uint64_t _t2;
    uint64_t _t3;
    uint64_t _t5;
    uint64_t _t7;
    uint64_t _t8;
    uint64_t* _t10;
    uint64_t* _t1;
    uint64_t* _t4;
    uint64_t* _t6;
    
    _t0 = _arg0;
    _t1 = &_t0->next_block;
    _t2 = *_t1;
    _t3 = _t2;
    _t4 = &_t0->next_block;
    _t5 = *_t4;
    _t6 = &_t0->next_block;
    _t7 = *_t6;
    _t8 = (uint64_t)1LL;
    _t9 = _t7 + _t8;
    _t10 = &_t0->next_block;
    *_t10 = _t9;
    return _t3;
}

void IRGenerator_emit(struct IRGenerator* _arg0, struct Instruction* _arg1) {
    struct IRGenerator* _t0;
    struct Instruction* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void IRGenerator_set_terminator(struct IRGenerator* _arg0, struct Terminator* _arg1) {
    struct IRGenerator* _t0;
    struct Terminator* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

bool IRGenerator_has_terminator(struct IRGenerator* _arg0) {
    struct IRGenerator* _t0;
    
    _t0 = _arg0;
    return 0;
}

void IRGenerator_ast_binop_to_ir(struct BinOp* _arg0, uint8_t _arg1) {
    struct BinOp* _t0;
    uint8_t _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void IRGenerator_ast_type_to_ir(struct IRType* _arg0, struct IRGenerator* _arg1) {
    struct IRGenerator* _t1;
    struct IRType* _t0;
    
    _t0 = _arg0;
    _t1 = _arg1;
    return;
}

void IRGenerator_get_value_type(struct IRType* _arg0, struct IRGenerator* _arg1, struct Value* _arg2) {
    struct IRGenerator* _t1;
    struct IRType* _t0;
    struct Value* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    return;
}

bool IRGenerator_is_integer_type(struct IRType* _arg0) {
    struct IRType* _t0;
    
    _t0 = _arg0;
    return 1;
}

void main(void) {
    int64_t _t0;
    int64_t _t20;
    int64_t _t9;
    struct IRGenerator* _t3;
    struct IRGenerator* _t4;
    struct Instruction* _t14;
    struct Instruction* _t15;
    struct Terminator* _t18;
    struct Terminator* _t19;
    struct Value* _t10;
    struct Value* _t11;
    struct Value* _t12;
    struct Value* _t13;
    struct Value* _t16;
    struct Value* _t17;
    uint64_t _t5;
    uint64_t _t6;
    uint64_t _t7;
    uint64_t _t8;
    uint8_t* _t1;
    uint8_t* _t2;
    
    puts("IR Generator defined!");
    _t1 = (uint8_t*)"test_module";
    _t2 = _t1;
    struct IRGenerator _alloca__t3;
    _t3 = &_alloca__t3;
    IRGenerator_new(_t3, _t2);
    _t4 = _t3;
    _t5 = IRGenerator_alloc_reg(_t4);
    _t6 = _t5;
    _t7 = IRGenerator_alloc_block(_t4);
    _t8 = _t7;
    puts("Created IR generator!");
    struct Value _alloca__t10;
    _t10 = &_alloca__t10;
    Value_from_const(_t10, 10LL);
    _t11 = _t10;
    struct Value _alloca__t12;
    _t12 = &_alloca__t12;
    Value_from_const(_t12, 20LL);
    _t13 = _t12;
    struct Instruction _alloca__t14;
    _t14 = &_alloca__t14;
    Instruction_binop(_t14, 0LL, BinOp_Add, _t11, _t13);
    _t15 = _t14;
    struct Value _alloca__t16;
    _t16 = &_alloca__t16;
    Value_from_reg(_t16, _t6);
    _t17 = _t16;
    struct Terminator _alloca__t18;
    _t18 = &_alloca__t18;
    Terminator_ret(_t18, _t17);
    _t19 = _t18;
    puts("IR generation self-hosting working!");
    return;
}

