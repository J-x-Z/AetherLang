1. 项目概述
1.1 项目目标
创建一门完全自举的系统编程语言 AetherLang，用于重写 Aether OS，实现真正的"全栈自主"。
核心目标：

✅ 语言能编译自己的编译器（自举）
✅ 适合操作系统开发（底层能力）
✅ 比 Rust 简单，比 C 安全
✅ 编译速度快（<1秒编译1000行代码）
✅ 18个月内完成可用版本

1.2 项目动机
痛点分析：
Rust的问题（基于实际OS开发经验）:
├── 生命周期标注复杂（'a, 'b, 'static 到处都是）
├── 借用检查器过于严格（unsafe 块泛滥）
├── 编译速度慢（改一行等30秒）
├── 错误信息冗长（一个错误几十行）
├── 学习曲线陡峭（trait, lifetime, macro）
└── 不适合快速原型开发

AetherLang的解决方案:
├── 简化所有权模型（own/ref/mut，无生命周期）
├── 宽松的编译时检查 + 运行时检查
├── 增量编译 + 简单IR（编译速度快10倍）
├── 清晰的错误信息（1-3行）
├── 渐进式学习曲线
└── 开发效率优先
1.3 项目范围
包含：

✅ 完整的语言规范（Spec）
✅ 自举编译器（能编译自己）
✅ 最小标准库（10个核心模块）
✅ 开发工具（语法高亮、LSP基础）
✅ 文档和示例（100+页）
包管理器（后续版本）

不包含（v1.0阶段）：

❌ 宏系统（先用代码生成）
❌ 异步运行时（先做同步）
❌ 泛型系统（v1.0用具体类型）
❌ IDE集成（只有基础LSP）

1.4 项目里程碑
M0: 项目启动（Month 0）
├── 完成设计文档
├── 确定语法规范
└── 搭建开发环境

M1: 编译器前端（Month 1-3）
├── Lexer实现
├── Parser实现
├── 语义分析
└── 类型检查

M2: 编译器后端（Month 4-6）
├── IR设计
├── LLVM集成
├── 代码生成
└── 优化Pass

M3: 标准库（Month 7-9）
├── 核心类型
├── 内存管理
├── IO操作
└── 字符串处理

M4: 自举（Month 10-12）
├── 用AetherLang重写编译器
├── 验证自举
├── 性能优化
└── Bug修复

M5: OS集成（Month 13-15）
├── 重写内存管理模块
├── 重写调度器
├── 重写VFS
└── 验证OS功能

M6: 发布准备（Month 16-18）
├── 文档完善
├── 工具链
├── 示例项目
└── v1.0发布

2. 设计哲学
2.1 核心原则
1. 简单 > 完美
   └── 宁可功能少，也要易于理解

2. 明确 > 隐式
   └── 显式的所有权标注，没有隐藏的行为

3. 程序员时间 > 机器时间
   └── 编译快速，运行性能次之（v1.0）

4. 实用 > 理论
   └── 能解决实际问题优先

5. 渐进 > 完整
   └── 先做MVP，再迭代完善


   2.3 设计取舍
选择的权衡：
安全性 vs 灵活性:
├── 编译时检查：基础的所有权检查
├── 运行时检查：边界检查（可关闭）
└── unsafe块：明确标记，易于审计

性能 vs 开发效率:
├── v1.0: 开发效率优先
├── v2.0: 增加优化pass
└── v3.0: 接近Rust性能

完整性 vs 简洁性:
├── 先做核心特性（80%的需求）
├── 复杂特性延后（20%的需求）
└── 避免特性膨胀

3. 语言规范
3.1 语法概览
3.1.1 基本类型
aeth// 整数类型
i8, i16, i32, i64, isize   // 有符号
u8, u16, u32, u64, usize   // 无符号

// 浮点类型
f32, f64

// 布尔和字符
bool                        // true, false
char                        // Unicode字符

// 指针类型
*T                         // 裸指针
3.1.2 变量声明
aeth// 不可变绑定
let x = 42
let name = "Aether"

// 可变绑定
let mut y = 10
y = 20  // OK

// 类型标注
let count: i32 = 100

// 常量（编译时计算）
const PAGE_SIZE = 4096
const KERNEL_BASE: u64 = 0xFFFF_8000_0000_0000
3.1.3 函数定义
aeth// 基本函数
fn add(a: i32, b: i32) -> i32 {
    return a + b
}

// 隐式返回（最后一个表达式）
fn multiply(a: i32, b: i32) -> i32 {
    a * b  // 无分号 = 返回值
}

// 无返回值
fn print_hello() {
    println("Hello")
}

// 多返回值
fn divide(a: i32, b: i32) -> (i32, i32) {
    return (a / b, a % b)
}
3.1.4 所有权系统
aeth// own: 拥有所有权（默认）
fn consume(data: own String) {
    // 函数获得所有权
    // 函数结束时自动释放
}

// ref: 不可变借用
fn read(data: ref String) {
    // 只读访问
    println(data)
}

// mut: 可变借用
fn modify(data: mut String) {
    // 可以修改
    data.push('!')
}

// 使用示例
let s = String.new("hello")
read(ref s)      // 借用
modify(mut s)    // 可变借用
consume(own s)   // 转移所有权
// s不再可用
3.1.5 结构体
aeth// 定义
struct Point {
    x: i32
    y: i32
}

// 方法
impl Point {
    // 构造函数
    fn new(x: i32, y: i32) -> Point {
        return Point { x: x, y: y }
    }
    
    // 不可变方法
    fn distance(self: ref) -> f64 {
        return sqrt(self.x * self.x + self.y * self.y)
    }
    
    // 可变方法
    fn move(self: mut, dx: i32, dy: i32) {
        self.x += dx
        self.y += dy
    }
    
    // 消耗self
    fn destroy(self: own) {
        // 释放资源
    }
}

// 使用
let p = Point.new(10, 20)
let d = p.distance()
p.move(5, 5)
3.1.6 枚举和模式匹配
aeth// 枚举定义
enum Result<T, E> {
    Ok(T)
    Err(E)
}

// 模式匹配
fn handle_result(r: Result<i32, String>) {
    match r {
        Ok(value) => {
            println("Success: {}", value)
        }
        Err(error) => {
            println("Error: {}", error)
        }
    }
}

// 简化的错误处理
fn open_file(path: String) -> Result<File, Error> {
    if !exists(path) {
        return Err(Error.NotFound)
    }
    return Ok(File.new(path))
}

// 使用 or 语法糖
let file = open_file("/etc/config") or {
    println("File not found")
    return
}
3.1.7 控制流
aeth// if表达式
let max = if a > b { a } else { b }

// 循环
loop {
    // 无限循环
    if condition { break }
}

// while
while condition {
    // ...
}

// for (遍历)
for item in collection {
    println(item)
}

// 范围
for i in 0..10 {  // 0到9
    println(i)
}
3.1.8 泛型（v1.0简化版）
aeth// 泛型函数
fn swap<T>(a: mut T, b: mut T) {
    let temp = a
    a = b
    b = temp
}

// 泛型结构体
struct Vec<T> {
    data: *T
    len: usize
    cap: usize
}

// 约束（简化版）
fn print_debug<T: Debug>(value: T) {
    println("{:?}", value)
}
3.1.9 接口（Trait简化版）
aeth// 接口定义
interface Allocator {
    fn alloc(size: usize) -> *void
    fn free(ptr: *void)
}

// 实现接口
struct HeapAllocator {
    // 字段
}

impl Allocator for HeapAllocator {
    fn alloc(size: usize) -> *void {
        // 实现
    }
    
    fn free(ptr: *void) {
        // 实现
    }
}
3.1.10 Unsafe块
aeth// 需要显式标记
fn read_port(port: u16) -> u8 {
    unsafe {
        let value: u8
        asm {
            "in al, dx"
            in: port
            out: value
        }
        return value
    }
}

// 裸指针操作
fn write_memory(addr: u64, value: u32) {
    unsafe {
        let ptr = addr as *u32
        *ptr = value
    }
}
3.2 完整语法规范（BNF）
bnf<program> ::= <item>*

<item> ::= <function>
         | <struct>
         | <enum>
         | <impl>
         | <const>
         | <interface>

<function> ::= "fn" <identifier> "(" <params>? ")" ("->" <type>)? <block>

<params> ::= <param> ("," <param>)*
<param> ::= <identifier> ":" <ownership>? <type>

<ownership> ::= "own" | "ref" | "mut"

<type> ::= <identifier>
         | "*" <type>
         | "[" <type> ";" <expr> "]"
         | "(" <type> ("," <type>)* ")"

<block> ::= "{" <statement>* "}"

<statement> ::= <let-stmt>
              | <expr-stmt>
              | <return-stmt>
              | <if-stmt>
              | <loop-stmt>
              | <match-stmt>

<let-stmt> ::= "let" "mut"? <identifier> (":" <type>)? "=" <expr>

<expr> ::= <literal>
         | <identifier>
         | <binary-op>
         | <unary-op>
         | <call>
         | <field-access>
         | <block-expr>

// ... 完整定义见附录A
```

### 3.3 标准库规范

#### 3.3.1 核心模块
```
core::
├── primitives (i32, u64, bool, etc.)
├── ptr (指针操作)
├── mem (内存操作: copy, move, size_of)
├── ops (运算符重载)
└── option (Option<T>)
```

#### 3.3.2 集合模块
```
collections::
├── vec (动态数组)
├── string (字符串)
├── map (哈希表)
└── list (链表)
```

#### 3.3.3 IO模块
```
io::
├── print (println, print)
├── file (File, 读写操作)
├── stdio (stdin, stdout, stderr)
└── error (IO错误类型)
```

#### 3.3.4 系统模块
```
sys::
├── alloc (内存分配器接口)
├── thread (线程操作 - v2.0)
└── process (进程操作)
```

---

## 4. 编译器架构

### 4.1 整体架构
```
Source Code (.aeth)
    ↓
┌─────────────────────┐
│   Frontend          │
│  ┌──────────────┐   │
│  │ Lexer        │   │  Token流
│  └──────────────┘   │
│         ↓           │
│  ┌──────────────┐   │
│  │ Parser       │   │  AST
│  └──────────────┘   │
│         ↓           │
│  ┌──────────────┐   │
│  │ Semantic     │   │  类型化AST
│  │ Analysis     │   │
│  └──────────────┘   │
└─────────────────────┘
         ↓
┌─────────────────────┐
│   Middle-end        │
│  ┌──────────────┐   │
│  │ IR Gen       │   │  Aether IR
│  └──────────────┘   │
│         ↓           │
│  ┌──────────────┐   │
│  │ Optimization │   │  优化后IR
│  └──────────────┘   │
└─────────────────────┘
         ↓
┌─────────────────────┐
│   Backend           │
│  ┌──────────────┐   │
│  │ LLVM IR Gen  │   │  LLVM IR
│  └──────────────┘   │
│         ↓           │
│  ┌──────────────┐   │
│  │ LLVM         │   │  机器码
│  │ (外部工具)    │   │
│  └──────────────┘   │
└─────────────────────┘
         ↓
    Binary (.exe/.elf)
```

### 4.2 模块划分
```
aether-compiler/
├── src/
│   ├── main.rs              # 编译器入口
│   ├── frontend/
│   │   ├── mod.rs
│   │   ├── lexer.rs         # 词法分析（~500行）
│   │   ├── parser.rs        # 语法分析（~1500行）
│   │   ├── ast.rs           # AST定义（~800行）
│   │   └── semantic.rs      # 语义分析（~1000行）
│   ├── middle/
│   │   ├── mod.rs
│   │   ├── ir.rs            # IR定义（~600行）
│   │   ├── ir_gen.rs        # AST→IR（~1200行）
│   │   └── optimize.rs      # 优化pass（~800行）
│   ├── backend/
│   │   ├── mod.rs
│   │   └── llvm.rs          # LLVM集成（~1000行）
│   ├── types/
│   │   ├── mod.rs
│   │   └── type_system.rs   # 类型系统（~1200行）
│   └── utils/
│       ├── mod.rs
│       ├── error.rs         # 错误处理（~400行）
│       └── span.rs          # 位置信息（~200行）
├── tests/                   # 测试用例
└── examples/                # 示例代码

预计总代码量: ~10,000行Rust
4.3 数据结构设计
4.3.1 Token定义
rust#[derive(Debug, Clone, PartialEq)]
pub enum TokenKind {
    // 关键字
    Fn, Let, Mut, If, Else, Loop, While, For,
    Return, Match, Struct, Impl, Enum, Interface,
    Own, Ref, Const, Unsafe, Break, Continue,
    
    // 标识符和字面量
    Ident(String),
    IntLit(i64),
    FloatLit(f64),
    StringLit(String),
    CharLit(char),
    BoolLit(bool),
    
    // 运算符
    Plus, Minus, Star, Slash, Percent,
    Eq, EqEq, Ne, Lt, Le, Gt, Ge,
    And, Or, Not,
    Arrow, FatArrow,
    
    // 分隔符
    LParen, RParen, LBrace, RBrace,
    LBracket, RBracket,
    Comma, Dot, Colon, Semicolon,
    
    // 特殊
    Eof,
}

pub struct Token {
    pub kind: TokenKind,
    pub span: Span,
}

pub struct Span {
    pub start: usize,
    pub end: usize,
    pub file: FileId,
}
4.3.2 AST定义
rustpub enum Expr {
    Literal(Literal),
    Ident(Ident),
    Binary {
        left: Box<Expr>,
        op: BinOp,
        right: Box<Expr>,
    },
    Unary {
        op: UnOp,
        expr: Box<Expr>,
    },
    Call {
        func: Box<Expr>,
        args: Vec<Expr>,
    },
    Field {
        expr: Box<Expr>,
        field: Ident,
    },
    Block(Block),
    If {
        cond: Box<Expr>,
        then_block: Block,
        else_block: Option<Block>,
    },
    Match {
        expr: Box<Expr>,
        arms: Vec<MatchArm>,
    },
    // ... 其他表达式
}

pub struct Function {
    pub name: Ident,
    pub params: Vec<Param>,
    pub ret_type: Option<Type>,
    pub body: Block,
}

pub struct Struct {
    pub name: Ident,
    pub fields: Vec<Field>,
}

// ... 其他AST节点
4.3.3 IR定义（Aether IR）
rust// 三地址码风格的IR
pub enum Instruction {
    // 赋值
    Assign {
        dest: Register,
        value: Value,
    },
    
    // 二元运算
    BinOp {
        dest: Register,
        op: BinOp,
        left: Value,
        right: Value,
    },
    
    // 函数调用
    Call {
        dest: Option<Register>,
        func: FunctionId,
        args: Vec<Value>,
    },
    
    // 跳转
    Jump { target: BlockId },
    JumpIf {
        cond: Value,
        then_target: BlockId,
        else_target: BlockId,
    },
    
    // 返回
    Return { value: Option<Value> },
    
    // 内存操作
    Load {
        dest: Register,
        ptr: Value,
    },
    Store {
        ptr: Value,
        value: Value,
    },
    
    // ... 其他指令
}

pub struct BasicBlock {
    pub id: BlockId,
    pub instructions: Vec<Instruction>,
    pub terminator: Terminator,
}

pub struct Function {
    pub name: String,
    pub params: Vec<Register>,
    pub blocks: Vec<BasicBlock>,
    pub registers: RegisterAllocator,
}


4.4 编译流程详解
4.4.1 词法分析（Lexer）
输入：源代码字符串
输出：Token流
rustpub struct Lexer {
    input: String,
    pos: usize,
    current_char: Option<char>,
}

impl Lexer {
    pub fn new(input: String) -> Self {
        let mut lexer = Lexer {
            input,
            pos: 0,
            current_char: None,
        };
        lexer.advance();
        lexer
    }
    
    fn advance(&mut self) {
        self.current_char = self.input.chars().nth(self.pos);
        self.pos += 1;
    }
    
    fn skip_whitespace(&mut self) {
        while let Some(c) = self.current_char {
            if c.is_whitespace() {
                self.advance();
            } else {
                break;
            }
        }
    }
    
    fn read_number(&mut self) -> Token {
        let start = self.pos - 1;
        
        while let Some(c) = self.current_char {
            if c.is_numeric() {
                self.advance();
            } else {
                break;
            }
        }
        
        let num_str = &self.input[start..self.pos-1];
        let value = num_str.parse().unwrap();
        
        Token {
            kind: TokenKind::IntLit(value),
            span: Span::new(start, self.pos - 1),
        }
    }
    
    fn read_identifier(&mut self) -> Token {
        let start = self.pos - 1;
        
        while let Some(c) = self.current_char {
            if c.is_alphanumeric() || c == '_' {
                self.advance();
            } else {
                break;
            }
        }
        
        let ident = &self.input[start..self.pos-1];
        
        // 检查是否是关键字
        let kind = match ident {
            "fn" => TokenKind::Fn,
            "let" => TokenKind::Let,
            "if" => TokenKind::If,
            // ... 其他关键字
            _ => TokenKind::Ident(ident.to_string()),
        };
        
        Token {
            kind,
            span: Span::new(start, self.pos - 1),
        }
    }
    
    pub fn next_token(&mut self) -> Token {
        self.skip_whitespace();
        
        match self.current_char {
            None => Token::eof(),
            Some(c) if c.is_numeric() => self.read_number(),
            Some(c) if c.is_alphabetic() => self.read_identifier(),
            Some('+') => {
                self.advance();
                Token::new(TokenKind::Plus)
            }
            // ... 其他字符
            Some(c) => panic!("Unexpected character: {}", c),
        }
    }
}
关键点：

状态机模式
关键字识别
错误恢复
位置跟踪

4.4.2 语法分析（Parser）
输入：Token流
输出：AST
rustpub struct Parser {
    lexer: Lexer,
    current_token: Token,
}

impl Parser {
    pub fn new(mut lexer: Lexer) -> Self {
        let current_token = lexer.next_token();
        Parser {
            lexer,
            current_token,
        }
    }
    
    fn advance(&mut self) {
        self.current_token = self.lexer.next_token();
    }
    
    fn expect(&mut self, expected: TokenKind) -> Result<(), Error> {
        if self.current_token.kind == expected {
            self.advance();
            Ok(())
        } else {
            Err(Error::UnexpectedToken {
                expected,
                got: self.current_token.kind.clone(),
            })
        }
    }
    
    // 解析函数定义
    pub fn parse_function(&mut self) -> Result<Function, Error> {
        self.expect(TokenKind::Fn)?;
        
        let name = self.parse_ident()?;
        
        self.expect(TokenKind::LParen)?;
        let params = self.parse_params()?;
        self.expect(TokenKind::RParen)?;
        
        let ret_type = if self.current_token.kind == TokenKind::Arrow {
            self.advance();
            Some(self.parse_type()?)
        } else {
            None
        };
        
        let body = self.parse_block()?;
        
        Ok(Function {
            name,
            params,
            ret_type,
            body,
        })
    }
    
    // 解析表达式（优先级处理）
    pub fn parse_expr(&mut self) -> Result<Expr, Error> {
        self.parse_expr_with_precedence(0)
    }
    
    fn parse_expr_with_precedence(&mut self, min_prec: u8) -> Result<Expr, Error> {
        let mut left = self.parse_primary()?;
        
        while let Some(op) = self.current_token.kind.as_binary_op() {
            let prec = op.precedence();
            if prec < min_prec {
                break;
            }
            
            self.advance();
            let right = self.parse_expr_with_precedence(prec + 1)?;
            
            left = Expr::Binary {
                left: Box::new(left),
                op,
                right: Box::new(right),
            };
        }
        
        Ok(left)
    }
    
    fn parse_primary(&mut self) -> Result<Expr, Error> {
        match &self.current_token.kind {
            TokenKind::IntLit(n) => {
                let expr = Expr::Literal(Literal::Int(*n));
                self.advance();
                Ok(expr)
            }
            TokenKind::Ident(name) => {
                let ident = name.clone();
                self.advance();
                Ok(Expr::Ident(ident))
            }
            TokenKind::LParen => {
                self.advance();
                let expr = self.parse_expr()?;
                self.expect(TokenKind::RParen)?;
                Ok(expr)
            }
            _ => Err(Error::UnexpectedToken {
                expected: "expression".to_string(),
                got: self.current_token.kind.clone(),
            }),
        }
    }
}
关键点：

递归下降
运算符优先级（Pratt Parsing）
错误恢复
左递归处理


4.4.3 语义分析
输入：AST
输出：类型化AST + 符号表
rustpub struct SemanticAnalyzer {
    symbol_table: SymbolTable,
    errors: Vec<Error>,
    current_scope: ScopeId,
}

impl SemanticAnalyzer {
    pub fn analyze(&mut self, ast: &mut Program) -> Result<(), Vec<Error>> {
        // 第一遍：收集所有定义
        self.collect_definitions(ast)?;
        
        // 第二遍：类型检查
        self.type_check(ast)?;
        
        // 第三遍：所有权检查
        self.ownership_check(ast)?;
        
        if self.errors.is_empty() {
            Ok(())
        } else {
            Err(self.errors.clone())
        }
    }
    
    fn collect_definitions(&mut self, program: &Program) -> Result<(), Error> {
        for item in &program.items {
            match item {
                Item::Function(func) => {
                    self.register_function(func)?;
                }
                Item::Struct(struct_def) => {
                    self.register_struct(struct_def)?;
                }
                // ... 其他项
            }
        }
        Ok(())
    }
    
    fn type_check_function(&mut self, func: &mut Function) -> Result<(), Error> {
        // 进入函数作用域
        self.enter_scope();
        
        // 注册参数
        for param in &func.params {
            self.symbol_table.insert(
                param.name.clone(),
                Symbol::Variable {
                    ty: param.ty.clone(),
                    mutable: param.ownership == Ownership::Mut,
                }
            );
        }
        
        // 检查函数体
        let body_type = self.type_check_block(&mut func.body)?;
        
        // 验证返回类型
        if let Some(ret_ty) = &func.ret_type {
            if !self.types_compatible(&body_type, ret_ty) {
                return Err(Error::TypeMismatch {
                    expected: ret_ty.clone(),
                    got: body_type,
                    span: func.body.span,
                });
            }
        }
        
        // 离开作用域
        self.exit_scope();
        
        Ok(())
    }
    
    fn type_check_expr(&mut self, expr: &mut Expr) -> Result<Type, Error> {
        match expr {
            Expr::Literal(lit) => {
                Ok(self.literal_type(lit))
            }
            
            Expr::Ident(name) => {
                match self.symbol_table.lookup(name) {
                    Some(Symbol::Variable { ty, .. }) => Ok(ty.clone()),
                    Some(Symbol::Function { .. }) => {
                        Err(Error::NotAValue { name: name.clone() })
                    }
                    None => Err(Error::UndefinedVariable {
                        name: name.clone(),
                    }),
                }
            }
            
            Expr::Binary { left, op, right } => {
                let left_ty = self.type_check_expr(left)?;
                let right_ty = self.type_check_expr(right)?;
                
                // 检查运算符是否适用于这些类型
                self.check_binary_op(*op, &left_ty, &right_ty)
            }
            
            Expr::Call { func, args } => {
                let func_ty = self.type_check_expr(func)?;
                
                match func_ty {
                    Type::Function { params, ret } => {
                        // 检查参数数量
                        if args.len() != params.len() {
                            return Err(Error::WrongArgumentCount {
                                expected: params.len(),
                                got: args.len(),
                            });
                        }
                        
                        // 检查每个参数的类型
                        for (arg, param_ty) in args.iter_mut().zip(params.iter()) {
                            let arg_ty = self.type_check_expr(arg)?;
                            if !self.types_compatible(&arg_ty, param_ty) {
                                return Err(Error::TypeMismatch {
                                    expected: param_ty.clone(),
                                    got: arg_ty,
                                    span: arg.span(),
                                });
                            }
                        }
                        
                        Ok(*ret)
                    }
                    _ => Err(Error::NotCallable {
                        ty: func_ty,
                    }),
                }
            }
            
            // ... 其他表达式
        }
    }
    
    fn ownership_check(&mut self, program: &Program) -> Result<(), Error> {
        for item in &program.items {
            if let Item::Function(func) = item {
                self.check_function_ownership(func)?;
            }
        }
        Ok(())
    }
    
    fn check_function_ownership(&mut self, func: &Function) -> Result<(), Error> {
        let mut ownership_state = OwnershipState::new();
        
        // 初始化参数的所有权状态
        for param in &func.params {
            match param.ownership {
                Ownership::Own => {
                    ownership_state.add_owned(param.name.clone());
                }
                Ownership::Ref => {
                    ownership_state.add_borrowed(param.name.clone());
                }
                Ownership::Mut => {
                    ownership_state.add_mut_borrowed(param.name.clone());
                }
            }
        }
        
        // 检查函数体
        self.check_block_ownership(&func.body, &mut ownership_state)?;
        
        Ok(())
    }
    
    fn check_expr_ownership(
        &mut self,
        expr: &Expr,
        state: &mut OwnershipState
    ) -> Result<(), Error> {
        match expr {
            Expr::Call { func, args } => {
                // 获取函数签名
                let func_sig = self.get_function_signature(func)?;
                
                // 检查每个参数
                for (arg, param_ownership) in args.iter().zip(func_sig.params.iter()) {
                    match param_ownership {
                        Ownership::Own => {
                            // 必须转移所有权
                            if let Expr::Ident(name) = arg {
                                if !state.is_owned(name) {
                                    return Err(Error::CannotMoveOutOfBorrow {
                                        var: name.clone(),
                                    });
                                }
                                state.consume(name.clone());
                            }
                        }
                        Ownership::Ref => {
                            // 不可变借用
                            if let Expr::Ident(name) = arg {
                                state.add_borrow(name.clone());
                            }
                        }
                        Ownership::Mut => {
                            // 可变借用
                            if let Expr::Ident(name) = arg {
                                if state.has_any_borrow(name) {
                                    return Err(Error::CannotBorrowMutably {
                                        var: name.clone(),
                                    });
                                }
                                state.add_mut_borrow(name.clone());
                            }
                        }
                    }
                }
                
                Ok(())
            }
            
            // ... 其他表达式
        }
    }
}

// 所有权状态跟踪
struct OwnershipState {
    owned: HashSet<String>,
    borrowed: HashMap<String, usize>,      // 不可变借用计数
    mut_borrowed: HashSet<String>,
}

impl OwnershipState {
    fn new() -> Self {
        Self {
            owned: HashSet::new(),
            borrowed: HashMap::new(),
            mut_borrowed: HashSet::new(),
        }
    }
    
    fn is_owned(&self, var: &str) -> bool {
        self.owned.contains(var)
    }
    
    fn consume(&mut self, var: String) {
        self.owned.remove(&var);
    }
    
    fn has_any_borrow(&self, var: &str) -> bool {
        self.borrowed.contains_key(var) || self.mut_borrowed.contains(var)
    }
    
    // ... 其他方法
}
关键点：

符号表管理（作用域）
类型推导和检查
所有权分析（简化版）
错误收集和报告

4.4.4 IR生成
输入：类型化AST
输出：Aether IR（三地址码）
rustpub struct IRGenerator {
    functions: Vec<IRFunction>,
    current_function: Option<IRFunction>,
    register_counter: usize,
    block_counter: usize,
}

impl IRGenerator {
    pub fn generate(&mut self, program: &Program) -> Result<IRModule, Error> {
        for item in &program.items {
            match item {
                Item::Function(func) => {
                    self.generate_function(func)?;
                }
                // ... 其他项
            }
        }
        
        Ok(IRModule {
            functions: self.functions.clone(),
        })
    }
    
    fn generate_function(&mut self, func: &Function) -> Result<(), Error> {
        // 创建新函数
        let mut ir_func = IRFunction::new(func.name.clone());
        
        // 为参数分配寄存器
        for param in &func.params {
            let reg = self.allocate_register();
            ir_func.add_param(reg, param.ty.clone());
        }
        
        // 创建入口基本块
        let entry_block = self.create_block();
        self.current_block = Some(entry_block);
        
        // 生成函数体的IR
        let result = self.generate_block(&func.body)?;
        
        // 添加返回指令
        if let Some(result_value) = result {
            self.emit(Instruction::Return {
                value: Some(result_value),
            });
        } else {
            self.emit(Instruction::Return { value: None });
        }
        
        // 保存函数
        self.functions.push(ir_func);
        
        Ok(())
    }
    
    fn generate_expr(&mut self, expr: &Expr) -> Result<Value, Error> {
        match expr {
            Expr::Literal(lit) => {
                Ok(Value::Constant(self.literal_to_constant(lit)))
            }
            
            Expr::Ident(name) => {
                // 查找变量对应的寄存器
                let reg = self.lookup_variable(name)?;
                Ok(Value::Register(reg))
            }
            
            Expr::Binary { left, op, right } => {
                let left_val = self.generate_expr(left)?;
                let right_val = self.generate_expr(right)?;
                
                let dest = self.allocate_register();
                
                self.emit(Instruction::BinOp {
                    dest,
                    op: *op,
                    left: left_val,
                    right: right_val,
                });
                
                Ok(Value::Register(dest))
            }
            
            Expr::Call { func, args } => {
                // 生成参数的IR
                let arg_values: Vec<Value> = args.iter()
                    .map(|arg| self.generate_expr(arg))
                    .collect::<Result<_, _>>()?;
                
                // 获取函数ID
                let func_id = self.get_function_id(func)?;
                
                // 生成调用指令
                let dest = self.allocate_register();
                
                self.emit(Instruction::Call {
                    dest: Some(dest),
                    func: func_id,
                    args: arg_values,
                });
                
                Ok(Value::Register(dest))
            }
            
            Expr::If { cond, then_block, else_block } => {
                let cond_val = self.generate_expr(cond)?;
                
                let then_block_id = self.create_block();
                let else_block_id = self.create_block();
                let merge_block_id = self.create_block();
                
                // 生成条件跳转
                self.emit(Instruction::JumpIf {
                    cond: cond_val,
                    then_target: then_block_id,
                    else_target: else_block_id,
                });
                
                // 生成then分支
                self.current_block = Some(then_block_id);
                let then_val = self.generate_block(then_block)?;
                self.emit(Instruction::Jump { target: merge_block_id });
                
                // 生成else分支
                self.current_block = Some(else_block_id);
                let else_val = if let Some(else_blk) = else_block {
                    self.generate_block(else_blk)?
                } else {
                    None
                };
                self.emit(Instruction::Jump { target: merge_block_id });
                
                // 合并点
                self.current_block = Some(merge_block_id);
                
                // 如果两个分支都有值，使用phi节点
                if let (Some(then_v), Some(else_v)) = (then_val, else_val) {
                    let phi_reg = self.allocate_register();
                    self.emit(Instruction::Phi {
                        dest: phi_reg,
                        incoming: vec![
                            (then_v, then_block_id),
                            (else_v, else_block_id),
                        ],
                    });
                    Ok(Value::Register(phi_reg))
                } else {
                    Ok(Value::Unit)
                }
            }
            
            // ... 其他表达式
        }
    }
    
    fn allocate_register(&mut self) -> Register {
        let reg = Register(self.register_counter);
        self.register_counter += 1;
        reg
    }
    
    fn create_block(&mut self) -> BlockId {
        let block = BlockId(self.block_counter);
        self.block_counter += 1;
        block
    }
    
    fn emit(&mut self, inst: Instruction) {
        if let Some(ref mut func) = self.current_function {
            if let Some(block_id) = self.current_block {
                func.add_instruction(block_id, inst);
            }
        }
    }
}

// IR表示
pub struct IRModule {
    pub functions: Vec<IRFunction>,
}

pub struct IRFunction {
    pub name: String,
    pub params: Vec<(Register, Type)>,
    pub blocks: Vec<BasicBlock>,
}

pub struct BasicBlock {
    pub id: BlockId,
    pub instructions: Vec<Instruction>,
}

#[derive(Debug, Clone, Copy)]
pub struct Register(usize);

#[derive(Debug, Clone, Copy)]
pub struct BlockId(usize);

pub enum Instruction {
    Assign { dest: Register, value: Value },
    BinOp { dest: Register, op: BinOp, left: Value, right: Value },
    Call { dest: Option<Register>, func: FunctionId, args: Vec<Value> },
    Jump { target: BlockId },
    JumpIf { cond: Value, then_target: BlockId, else_target: BlockId },
    Return { value: Option<Value> },
    Load { dest: Register, ptr: Value },
    Store { ptr: Value, value: Value },
    Phi { dest: Register, incoming: Vec<(Value, BlockId)> },
}

pub enum Value {
    Register(Register),
    Constant(Constant),
    Unit,
}

pub enum Constant {
    Int(i64),
    Float(f64),
    Bool(bool),
    Null,
}
关键点：

SSA形式（Single Static Assignment）
基本块和控制流图
寄存器分配（虚拟寄存器）
Phi节点处理

4.4.5 优化Pass
输入：Aether IR
输出：优化后的IR
rustpub struct Optimizer {
    passes: Vec<Box<dyn OptimizationPass>>,
}

impl Optimizer {
    pub fn new() -> Self {
        Self {
            passes: vec![
                Box::new(DeadCodeElimination),
                Box::new(ConstantFolding),
                Box::new(CommonSubexpressionElimination),
                Box::new(InlineSmallFunctions),
            ],
        }
    }
    
    pub fn optimize(&self, module: &mut IRModule) {
        for pass in &self.passes {
            for func in &mut module.functions {
                pass.run(func);
            }
        }
    }
}

trait OptimizationPass {
    fn run(&self, func: &mut IRFunction);
}

// 死代码消除
struct DeadCodeElimination;

impl OptimizationPass for DeadCodeElimination {
    fn run(&self, func: &mut IRFunction) {
        let mut used_registers = HashSet::new();
        
        // 第一遍：标记使用的寄存器
        for block in &func.blocks {
            for inst in &block.instructions {
                self.mark_used(inst, &mut used_registers);
            }
        }
        
        // 第二遍：删除死代码
        for block in &mut func.blocks {
            block.instructions.retain(|inst| {
                self.is_used(inst, &used_registers)
            });
        }
    }
}

// 常量折叠
struct ConstantFolding;

impl OptimizationPass for ConstantFolding {
    fn run(&self, func: &mut IRFunction) {
        for block in &mut func.blocks {
            for inst in &mut block.instructions {
                if let Instruction::BinOp { dest, op, left, right } = inst {
                    // 如果两个操作数都是常量，计算结果
                    if let (Value::Constant(l), Value::Constant(r)) = (left, right) {
                        if let Some(result) = self.eval_const_binop(*op, l, r) {
                            *inst = Instruction::Assign {
                                dest: *dest,
                                value: Value::Constant(result),
                            };
                        }
                    }
                }
            }
        }
    }
    
    fn eval_const_binop(&self, op: BinOp, left: &Constant, right: &Constant) -> Option<Constant> {
        match (op, left, right) {
            (BinOp::Add, Constant::Int(l), Constant::Int(r)) => {
                Some(Constant::Int(l + r))
            }
            (BinOp::Mul, Constant::Int(l), Constant::Int(r)) => {
                Some(Constant::Int(l * r))
            }
            // ... 其他运算
            _ => None,
        }
    }
}

// 公共子表达式消除
struct CommonSubexpressionElimination;

impl OptimizationPass for CommonSubexpressionElimination {
    fn run(&self, func: &mut IRFunction) {
        let mut available_exprs: HashMap<Expression, Register> = HashMap::new();
        
        for block in &mut func.blocks {
            for inst in &mut block.instructions {
                if let Instruction::BinOp { dest, op, left, right } = inst {
                    let expr = Expression::BinOp {
                        op: *op,
                        left: left.clone(),
                        right: right.clone(),
                    };
                    
                    // 如果表达式已经计算过，重用结果
                    if let Some(&prev_reg) = available_exprs.get(&expr) {
                        *inst = Instruction::Assign {
                            dest: *dest,
                            value: Value::Register(prev_reg),
                        };
                    } else {
                        available_exprs.insert(expr, *dest);
                    }
                }
            }
        }
    }
}

// 内联小函数
struct InlineSmallFunctions;

impl OptimizationPass for InlineSmallFunctions {
    fn run(&self, func: &mut IRFunction) {
        // 查找小于阈值的函数调用
        const INLINE_THRESHOLD: usize = 10; // 指令数
        
        for block in &mut func.blocks {
            let mut i = 0;
            while i < block.instructions.len() {
                if let Instruction::Call { func: callee, .. } = &block.instructions[i] {
                    let callee_func = self.get_function(*callee);
                    
                    // 如果函数足够小，内联
                    if callee_func.instruction_count() < INLINE_THRESHOLD {
                        let inlined = self.inline_function(callee_func, &block.instructions[i]);
                        block.instructions.splice(i..i+1, inlined);
                        continue;
                    }
                }
                i += 1;
            }
        }
    }
}
关键点：

Pass管道架构
数据流分析
优化效果vs编译时间权衡
保持IR正确性

4.4.6 LLVM代码生成
输入：优化后的IR
输出：LLVM IR（文本或bitcode）
rustuse llvm_sys::prelude::*;
use llvm_sys::core::*;

pub struct LLVMCodeGen {
    context: LLVMContextRef,
    module: LLVMModuleRef,
    builder: LLVMBuilderRef,
}

impl LLVMCodeGen {
    pub fn new(module_name: &str) -> Self {
        unsafe {
            let context = LLVMContextCreate();
            let module = LLVMModuleCreateWithNameInContext(
                module_name.as_ptr() as *const _,
                context
            );
            let builder = LLVMCreateBuilderInContext(context);
            
            Self { context, module, builder }
        }
    }
    
    pub fn generate(&mut self, ir_module: &IRModule) -> Result<(), Error> {
        // 第一遍：声明所有函数
        for func in &ir_module.functions {
            self.declare_function(func)?;
        }
        
        // 第二遍：生成函数体
        for func in &ir_module.functions {
            self.generate_function(func)?;
        }
        
        Ok(())
    }
    
    fn declare_function(&mut self, func: &IRFunction) -> Result<LLVMValueRef, Error> {
        unsafe {
            // 构建函数类型
            let param_types: Vec<LLVMTypeRef> = func.params.iter()
                .map(|(_, ty)| self.type_to_llvm(ty))
                .collect();
            
            let return_type = self.type_to_llvm(&func.return_type);
            
            let func_type = LLVMFunctionType(
                return_type,
                param_types.as_ptr() as *mut _,
                param_types.len() as u32,
                0, // not variadic
            );
            
            // 添加函数到模块
            let func_name = CString::new(func.name.clone()).unwrap();
            let llvm_func = LLVMAddFunction(
                self.module,
                func_name.as_ptr(),
                func_type
            );
            
            Ok(llvm_func)
        }
    }
    
    fn generate_function(&mut self, func: &IRFunction) -> Result<(), Error> {
        unsafe {
            let llvm_func = self.get_function(&func.name)?;
            
            // 创建基本块
            let mut block_map: HashMap<BlockId, LLVMBasicBlockRef> = HashMap::new();
            
            for block in &func.blocks {
                let block_name = CString::new(format!("bb{}", block.id.0)).unwrap();
                let llvm_block = LLVMAppendBasicBlockInContext(
                    self.context,
                    llvm_func,
                    block_name.as_ptr()
                );
                block_map.insert(block.id, llvm_block);
            }
            
            // 生成每个基本块的指令
            for block in &func.blocks {
                let llvm_block = block_map[&block.id];
                LLVMPositionBuilderAtEnd(self.builder, llvm_block);
                
                for inst in &block.instructions {
                    self.generate_instruction(inst, &block_map)?;
                }
            }
            
            Ok(())
        }
    }
    
    fn generate_instruction(
        &mut self,
        inst: &Instruction,
        blocks: &HashMap<BlockId, LLVMBasicBlockRef>
    ) -> Result<(), Error> {
        unsafe {
            match inst {
                Instruction::BinOp { dest, op, left, right } => {
                    let left_val = self.value_to_llvm(left);
                    let right_val = self.value_to_llvm(right);
                    
                    let result = match op {
                        BinOp::Add => LLVMBuildAdd(
                            self.builder,
                            left_val,
                            right_val,
                            c_str("add")
                        ),
                        BinOp::Sub => LLVMBuildSub(
                            self.builder,
                            left_val,
                            right_val,
                            c_str("sub")
                        ),
                        BinOp::Mul => LLVMBuildMul(
                            self.builder,
                            left_val,
                            right_val,
                            c_str("mul")
                        ),
                        // ... 其他运算符
                    };
                    
                    self.register_map.insert(*dest, result);
                }
                
                Instruction::Call { dest, func, args } => {
                    let llvm_func = self.get_function(func)?;
                    
                    let arg_values: Vec<LLVMValueRef> = args.iter()
                        .map(|arg| self.value_to_llvm(arg))
                        .collect();
                    
                    let result = LLVMBuildCall2(
                        self.builder,
                        LLVMGetElementType(LLVMTypeOf(llvm_func)),
                        llvm_func,
                        arg_values.as_ptr() as *mut _,
                        arg_values.len() as u32,
                        c_str("call")
                    );
                    
                    if let Some(dest_reg) = dest {
                        self.register_map.insert(*dest_reg, result);
                    }
                }
                
                Instruction::Jump { target } => {
                    let target_block = blocks[target];
                    LLVMBuildBr(self.builder, target_block);
                }
                
                Instruction::JumpIf { cond, then_target, else_target } => {
                    let cond_val = self.value_to_llvm(cond);
                    let then_block = blocks[then_target];
                    let else_block = blocks[else_target];
                    
                    LLVMBuildCondBr(
                        self.builder,
                        cond_val,
                        then_block,
                        else_block
                    );
                }
                
                Instruction::Return { value } => {
                    if let Some(val) = value {
                        let llvm_val = self.value_to_llvm(val);
                        LLVMBuildRet(self.builder, llvm_val);
                    } else {
                        LLVMBuildRetVoid(self.builder);
                    }
                }
                
                // ... 其他指令
            }
            
            Ok(())
        }
    }
    
    fn type_to_llvm(&self, ty: &Type) -> LLVMTypeRef {
        unsafe {
            match ty {
                Type::I32 => LLVMInt32TypeInContext(self.context),
                Type::I64 => LLVMInt64TypeInContext(self.context),
                Type::F64 => LLVMDoubleTypeInContext(self.context),
                Type::Bool => LLVMInt1TypeInContext(self.context),
                Type::Pointer(inner) => {
                    let inner_ty = self.type_to_llvm(inner);
                    LLVMPointerType(inner_ty, 0)
                }
                // ... 其他类型
            }
        }
    }
    
    pub fn emit_to_file(&self, path: &str) -> Result<(), Error> {
        unsafe {
            let path_cstr = CString::new(path).unwrap();
            let mut error_msg: *mut i8 = std::ptr::null_mut();
            
            let result = LLVMPrintModuleToFile(
                self.module,
                path_cstr.as_ptr(),
                &mut error_msg
            );
            
            if result != 0 {
                let error = CStr::from_ptr(error_msg).to_str().unwrap();
                return Err(Error::LLVMError(error.to_string()));
            }
            
            Ok(())
        }
    }
}
关键点：

LLVM C API绑定
类型映射
指令翻译
基本块和控制流