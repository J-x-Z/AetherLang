// JXZ Build Command Implementation
// Compiles AetherLang project using aethc

extern "C" {
    fn puts(s: *u8) -> i32;
    fn system(cmd: *u8) -> i32;
    fn access(path: *u8, mode: i32) -> i32;
    fn fopen(path: *u8, mode: *u8) -> *void;
    fn fclose(fp: *void) -> i32;
    fn fgets(buf: *u8, size: i32, fp: *void) -> *u8;
    fn mkdir(path: *u8, mode: u32) -> i32;
    fn strlen(s: *u8) -> u64;
    fn strcpy(dest: *u8, src: *u8) -> *u8;
    fn strcat(dest: *u8, src: *u8) -> *u8;
    fn malloc(size: u64) -> *void;
    fn free(ptr: *void);
}

// Import config module
use config::{Config, config_load}

const F_OK: i32 = 0

// Check if Jxz.toml exists
fn check_project() -> bool {
    if access("Jxz.toml\0" as *u8, F_OK) != 0 {
        puts("Error: No Jxz.toml found in current directory\0" as *u8)
        puts("Run 'jxz init' to create a new project\0" as *u8)
        return false
    }
    return true
}

// Compile main.aeth to executable
pub fn build_project(release: bool) -> i32 {
    if !check_project() {
        return 1
    }

    // Load configuration from Jxz.toml
    let cfg: Config = config_load()

    puts("   Compiling project...\0" as *u8)
    puts("   Package: \0" as *u8)
    puts(cfg.name)
    puts(" v\0" as *u8)
    puts(cfg.version)
    puts("\n\0" as *u8)

    // Ensure target directory exists
    mkdir(cfg.target_dir, 493)

    // Build command dynamically: aethc --emit-c <main_file>
    let cmd: *u8 = malloc(512) as *u8
    let result: i32 = 0

    // Step 1: Compile to C
    puts("     Compiling \0" as *u8)
    puts(cfg.main_file)
    puts(" -> C\n\0" as *u8)

    strcpy(cmd, "aethc --emit-c \0" as *u8)
    strcat(cmd, cfg.main_file)
    strcat(cmd, "\0" as *u8)
    result = system(cmd)

    if result != 0 {
        puts("Error: Compilation failed\0" as *u8)
        free(cmd as *void)
        return 1
    }

    // Step 2: Compile C to executable
    // Build output path: <target_dir>/<name>
    puts("     Compiling C -> executable\n\0" as *u8)

    if release {
        strcpy(cmd, "cc -O2 -o \0" as *u8)
    } else {
        strcpy(cmd, "cc -g -o \0" as *u8)
    }
    strcat(cmd, cfg.target_dir)
    strcat(cmd, "/\0" as *u8)
    strcat(cmd, cfg.name)
    strcat(cmd, " \0" as *u8)
    strcat(cmd, cfg.src_dir)
    strcat(cmd, "/main.c 2>/dev/null || gcc \0" as *u8)
    if release {
        strcat(cmd, "-O2 -o \0" as *u8)
    } else {
        strcat(cmd, "-g -o \0" as *u8)
    }
    strcat(cmd, cfg.target_dir)
    strcat(cmd, "/\0" as *u8)
    strcat(cmd, cfg.name)
    strcat(cmd, " \0" as *u8)
    strcat(cmd, cfg.src_dir)
    strcat(cmd, "/main.c\0" as *u8)

    result = system(cmd)
    free(cmd as *void)

    if result != 0 {
        puts("Error: C compilation failed\0" as *u8)
        return 1
    }

    puts("    Finished build\0" as *u8)
    return 0
}

// Build and run
pub fn run_project(args: *u8) -> i32 {
    let result: i32 = build_project(false)
    if result != 0 {
        return result
    }

    // Load config to get executable path
    let cfg: Config = config_load()

    puts("     Running \0" as *u8)
    puts(cfg.target_dir)
    puts("/\0" as *u8)
    puts(cfg.name)
    puts("\n\n\0" as *u8)

    // Build run command: ./<target_dir>/<name>
    let cmd: *u8 = malloc(256) as *u8
    strcpy(cmd, "./\0" as *u8)
    strcat(cmd, cfg.target_dir)
    strcat(cmd, "/\0" as *u8)
    strcat(cmd, cfg.name)
    strcat(cmd, "\0" as *u8)

    result = system(cmd)
    free(cmd as *void)
    return result
}

// Clean build artifacts
pub fn clean_project() -> i32 {
    // Load config to get directories
    let cfg: Config = config_load()

    puts("Cleaning build artifacts...\0" as *u8)

    // Build clean commands using config paths
    let cmd: *u8 = malloc(256) as *u8

    // Remove target directory
    strcpy(cmd, "rm -rf \0" as *u8)
    strcat(cmd, cfg.target_dir)
    strcat(cmd, "\0" as *u8)
    system(cmd)

    // Remove generated C files
    strcpy(cmd, "rm -f \0" as *u8)
    strcat(cmd, cfg.src_dir)
    strcat(cmd, "/*.c\0" as *u8)
    system(cmd)

    free(cmd as *void)
    puts("  Cleaned\0" as *u8)
    return 0
}
