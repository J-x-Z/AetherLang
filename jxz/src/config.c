/* Generated by AetherLang C Backend */
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <immintrin.h>  /* SSE/AVX */

/* AetherLang Runtime */
static void aether_print(const char* s) { printf("%s", s); }
static void aether_println(const char* s) { printf("%s\n", s); }
static void aether_print_i64(int64_t n) { printf("%lld", (long long)n); }
static void aether_println_i64(int64_t n) { printf("%lld\n", (long long)n); }
static void aether_assert(bool c) { if(!c) { fprintf(stderr, "Assertion failed\n"); exit(1); } }

/* Struct Definitions */
struct Config {
    uint8_t* name;
    uint8_t* version;
    uint8_t* edition;
    uint8_t* description;
    uint8_t* authors;
    uint8_t* license;
    uint8_t* repository;
    uint8_t* src_dir;
    uint8_t* target_dir;
    uint8_t* main_file;
    bool release;
    bool verbose;
};

struct Config* config_default(void);
struct Config* config_load(void);
bool config_validate(struct Config**);
void config_print(struct Config**);

struct Config* config_default(void) {
    bool* _t21;
    bool* _t22;
    struct Config* _t0;
    uint8_t* _t11;
    uint8_t* _t13;
    uint8_t* _t15;
    uint8_t* _t17;
    uint8_t* _t19;
    uint8_t* _t1;
    uint8_t* _t3;
    uint8_t* _t5;
    uint8_t* _t7;
    uint8_t* _t9;
    uint8_t** _t10;
    uint8_t** _t12;
    uint8_t** _t14;
    uint8_t** _t16;
    uint8_t** _t18;
    uint8_t** _t20;
    uint8_t** _t2;
    uint8_t** _t4;
    uint8_t** _t6;
    uint8_t** _t8;
    
    struct Config _alloca__t0;
    _t0 = &_alloca__t0;
    _t1 = (uint8_t*)"project\u{0}";
    _t2 = &_t0->name;
    *_t2 = _t1;
    _t3 = (uint8_t*)"0.1.0\u{0}";
    _t4 = &_t0->version;
    *_t4 = _t3;
    _t5 = (uint8_t*)"2026\u{0}";
    _t6 = &_t0->edition;
    *_t6 = _t5;
    _t7 = (uint8_t*)0LL;
    _t8 = &_t0->description;
    *_t8 = _t7;
    _t9 = (uint8_t*)0LL;
    _t10 = &_t0->authors;
    *_t10 = _t9;
    _t11 = (uint8_t*)0LL;
    _t12 = &_t0->license;
    *_t12 = _t11;
    _t13 = (uint8_t*)0LL;
    _t14 = &_t0->repository;
    *_t14 = _t13;
    _t15 = (uint8_t*)"src\u{0}";
    _t16 = &_t0->src_dir;
    *_t16 = _t15;
    _t17 = (uint8_t*)"target\u{0}";
    _t18 = &_t0->target_dir;
    *_t18 = _t17;
    _t19 = (uint8_t*)"src/main.aeth\u{0}";
    _t20 = &_t0->main_file;
    *_t20 = _t19;
    _t21 = &_t0->release;
    *_t21 = 0;
    _t22 = &_t0->verbose;
    *_t22 = 0;
    return _t0;
}

struct Config* config_load(void) {
    int32_t _t27;
    int32_t _t28;
    int32_t _t4;
    int64_t _t11;
    int64_t _t12;
    int64_t _t13;
    int64_t _t14;
    int64_t _t15;
    int64_t _t18;
    int64_t _t19;
    int64_t _t20;
    int64_t _t26;
    int64_t _t32;
    int64_t _t3;
    int64_t _t5;
    int64_t _t8;
    int64_t _t9;
    struct Config* _t0;
    struct Config* _t1;
    uint64_t _t16;
    uint64_t _t17;
    uint64_t _t24;
    uint64_t _t25;
    uint8_t _t30;
    uint8_t* _t21;
    uint8_t* _t22;
    uint8_t* _t29;
    uint8_t* _t2;
    uint8_t* _t31;
    uint8_t* _t6;
    uint8_t* _t7;
    void* _t10;
    void* _t23;
    void* _t33;
    
    struct Config _alloca__t0;
    _t0 = &_alloca__t0;
    config_default(_t0);
    _t1 = _t0;
    _t2 = (uint8_t*)"Jxz.toml\u{0}";
    access(_t2, F_OK);
    _t4 = (int32_t)0LL;
    _t5 = _t3 != _t4;
    if (_t5) goto L_then; else goto L_else;
L_then:
    return _t1;
L_else:
    goto L_merge;
L_merge:
    _t6 = (uint8_t*)"Jxz.toml\u{0}";
    _t7 = (uint8_t*)"r\u{0}";
    fopen(_t6, _t7);
    _t9 = _t8;
    _t10 = (void*)0LL;
    _t11 = _t9 == _t10;
    if (_t11) goto L_then; else goto L_else;
L_then:
    return _t1;
L_else:
    goto L_merge;
L_merge:
    fseek(_t9, 0LL, SEEK_END);
    ftell(_t9);
    _t14 = _t13;
    fseek(_t9, 0LL, SEEK_SET);
    _t16 = (uint64_t)_t14;
    _t17 = (uint64_t)1LL;
    _t18 = _t16 + _t17;
    _t19 = (int64_t)_t18;
    malloc(_t19);
    _t21 = (uint8_t*)_t20;
    _t22 = _t21;
    _t23 = (void*)_t22;
    _t24 = (uint64_t)1LL;
    _t25 = (uint64_t)_t14;
    fread(_t23, _t24, _t25, _t9);
    _t27 = (int32_t)_t14;
    _t28 = _t27;
    _t29 = &_t22[_t28];
    _t30 = *_t29;
    _t31 = &_t22[_t28];
    *_t31 = 0LL;
    fclose(_t9);
    _t33 = (void*)_t22;
    free(_t33);
    return _t1;
}

bool config_validate(struct Config** _arg0) {
    int64_t _t12;
    int64_t _t14;
    int64_t _t5;
    int64_t _t7;
    struct Config* _t1;
    struct Config* _t8;
    struct Config** _t0;
    uint8_t* _t10;
    uint8_t* _t11;
    uint8_t* _t13;
    uint8_t* _t3;
    uint8_t* _t4;
    uint8_t* _t6;
    uint8_t** _t2;
    uint8_t** _t9;
    
    _t0 = _arg0;
    _t1 = *_t0;
    _t2 = &_t1->name;
    _t3 = *_t2;
    _t4 = (uint8_t*)0LL;
    _t5 = _t3 == _t4;
    if (_t5) goto L_then; else goto L_else;
L_then:
    _t6 = (uint8_t*)"Error: package.name is required\u{0}";
    puts(_t6);
    return 0;
L_else:
    goto L_merge;
L_merge:
    _t8 = *_t0;
    _t9 = &_t8->version;
    _t10 = *_t9;
    _t11 = (uint8_t*)0LL;
    _t12 = _t10 == _t11;
    if (_t12) goto L_then; else goto L_else;
L_then:
    _t13 = (uint8_t*)"Error: package.version is required\u{0}";
    puts(_t13);
    return 0;
L_else:
    goto L_merge;
L_merge:
    return 1;
}

void config_print(struct Config** _arg0) {
    int64_t _t10;
    int64_t _t14;
    int64_t _t16;
    int64_t _t20;
    int64_t _t2;
    int64_t _t4;
    int64_t _t8;
    struct Config* _t11;
    struct Config* _t17;
    struct Config* _t5;
    struct Config** _t0;
    uint8_t* _t13;
    uint8_t* _t15;
    uint8_t* _t19;
    uint8_t* _t1;
    uint8_t* _t3;
    uint8_t* _t7;
    uint8_t* _t9;
    uint8_t** _t12;
    uint8_t** _t18;
    uint8_t** _t6;
    
    _t0 = _arg0;
    _t1 = (uint8_t*)"Project Configuration:\u{0}";
    puts(_t1);
    _t3 = (uint8_t*)"  name: \u{0}";
    puts(_t3);
    _t5 = *_t0;
    _t6 = &_t5->name;
    _t7 = *_t6;
    puts(_t7);
    _t9 = (uint8_t*)"  version: \u{0}";
    puts(_t9);
    _t11 = *_t0;
    _t12 = &_t11->version;
    _t13 = *_t12;
    puts(_t13);
    _t15 = (uint8_t*)"  edition: \u{0}";
    puts(_t15);
    _t17 = *_t0;
    _t18 = &_t17->edition;
    _t19 = *_t18;
    puts(_t19);
    return;
}

