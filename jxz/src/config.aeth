// JXZ Configuration Module
// Parses Jxz.toml project configuration

extern "C" {
    fn puts(s: *u8) -> i32;
    fn fopen(path: *u8, mode: *u8) -> *void;
    fn fclose(fp: *void) -> i32;
    fn fread(buf: *void, size: u64, count: u64, fp: *void) -> u64;
    fn fseek(fp: *void, offset: i64, whence: i32) -> i32;
    fn ftell(fp: *void) -> i64;
    fn malloc(size: u64) -> *void;
    fn free(ptr: *void);
    fn strcmp(s1: *u8, s2: *u8) -> i32;
    fn strncmp(s1: *u8, s2: *u8, n: u64) -> i32;
    fn strstr(haystack: *u8, needle: *u8) -> *u8;
    fn strcpy(dest: *u8, src: *u8) -> *u8;
    fn strncpy(dest: *u8, src: *u8, n: u64) -> *u8;
    fn strlen(s: *u8) -> u64;
    fn access(path: *u8, mode: i32) -> i32;
}

const SEEK_SET: i32 = 0
const SEEK_END: i32 = 2
const F_OK: i32 = 0

// ==================== Config Structure ====================

pub struct Config {
    // Package info
    name: *u8,
    version: *u8,
    edition: *u8,
    description: *u8,
    authors: *u8,
    license: *u8,
    repository: *u8,

    // Build settings
    src_dir: *u8,
    target_dir: *u8,
    main_file: *u8,

    // Flags
    release: bool,
    verbose: bool,
}

// ==================== Simple TOML Parser ====================

// Skip whitespace and return pointer to first non-whitespace char
fn skip_whitespace(s: *u8) -> *u8 {
    let mut p: *u8 = s;
    while *p == 32 || *p == 9 {  // space or tab
        p = p + 1;
    }
    return p;
}

// Extract value after '=' sign, removing quotes
fn extract_value(line: *u8, key: *u8) -> *u8 {
    let key_len: u64 = strlen(key);

    // Check if line starts with key
    if strncmp(line, key, key_len) != 0 {
        return 0 as *u8;
    }

    // Find '=' sign
    let mut p: *u8 = line + key_len as i32;
    p = skip_whitespace(p);

    if *p != 61 {  // '='
        return 0 as *u8;
    }
    p = p + 1;
    p = skip_whitespace(p);

    // Skip opening quote
    if *p == 34 {  // '"'
        p = p + 1;
    }

    // Find end of value (closing quote or newline)
    let start: *u8 = p;
    while *p != 0 && *p != 34 && *p != 10 && *p != 13 {
        p = p + 1;
    }

    // Copy value
    let len: u64 = (p as u64) - (start as u64);
    let value: *u8 = malloc(len + 1) as *u8;
    strncpy(value, start, len);
    value[len as i32] = 0;

    return value;
}

// Parse a section like [package] or [dependencies]
fn find_section(content: *u8, section: *u8) -> *u8 {
    let mut p: *u8 = content;
    let section_len: u64 = strlen(section);

    while *p != 0 {
        // Skip whitespace at start of line
        p = skip_whitespace(p);

        // Check for section header
        if *p == 91 {  // '['
            p = p + 1;
            if strncmp(p, section, section_len) == 0 {
                // Found section, skip to next line
                while *p != 0 && *p != 10 {
                    p = p + 1;
                }
                if *p == 10 {
                    p = p + 1;
                }
                return p;
            }
        }

        // Skip to next line
        while *p != 0 && *p != 10 {
            p = p + 1;
        }
        if *p == 10 {
            p = p + 1;
        }
    }

    return 0 as *u8;
}

// Parse key-value pairs in a section until next section or EOF
fn parse_section_value(section_start: *u8, key: *u8) -> *u8 {
    let mut p: *u8 = section_start;

    while *p != 0 {
        // Skip whitespace
        let line_start: *u8 = skip_whitespace(p);

        // Check for new section (stop parsing)
        if *line_start == 91 {  // '['
            return 0 as *u8;
        }

        // Skip comments and empty lines
        if *line_start == 35 || *line_start == 10 || *line_start == 0 {  // '#' or newline
            // Skip to next line
            while *p != 0 && *p != 10 {
                p = p + 1;
            }
            if *p == 10 {
                p = p + 1;
            }
            continue;
        }

        // Try to extract value for this key
        let value: *u8 = extract_value(line_start, key);
        if value != (0 as *u8) {
            return value;
        }

        // Skip to next line
        while *p != 0 && *p != 10 {
            p = p + 1;
        }
        if *p == 10 {
            p = p + 1;
        }
    }

    return 0 as *u8;
}

// ==================== Config Loading ====================

pub fn config_default() -> Config {
    return Config {
        name: "project\0" as *u8,
        version: "0.1.0\0" as *u8,
        edition: "2026\0" as *u8,
        description: 0 as *u8,
        authors: 0 as *u8,
        license: 0 as *u8,
        repository: 0 as *u8,
        src_dir: "src\0" as *u8,
        target_dir: "target\0" as *u8,
        main_file: "src/main.aeth\0" as *u8,
        release: false,
        verbose: false,
    }
}

pub fn config_load() -> Config {
    let mut cfg: Config = config_default();

    // Check if Jxz.toml exists
    if access("Jxz.toml\0" as *u8, F_OK) != 0 {
        return cfg;
    }

    // Read file
    let fp: *void = fopen("Jxz.toml\0" as *u8, "r\0" as *u8);
    if fp == (0 as *void) {
        return cfg;
    }

    // Get file size
    fseek(fp, 0, SEEK_END);
    let size: i64 = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    // Read content
    let buf: *u8 = malloc(size as u64 + 1) as *u8;
    fread(buf as *void, 1, size as u64, fp);
    buf[size as i32] = 0;
    fclose(fp);

    // Parse [package] section
    let pkg_section: *u8 = find_section(buf, "package\0" as *u8);
    if pkg_section != (0 as *u8) {
        let name: *u8 = parse_section_value(pkg_section, "name\0" as *u8);
        if name != (0 as *u8) {
            cfg.name = name;
        }

        let version: *u8 = parse_section_value(pkg_section, "version\0" as *u8);
        if version != (0 as *u8) {
            cfg.version = version;
        }

        let edition: *u8 = parse_section_value(pkg_section, "edition\0" as *u8);
        if edition != (0 as *u8) {
            cfg.edition = edition;
        }

        let description: *u8 = parse_section_value(pkg_section, "description\0" as *u8);
        if description != (0 as *u8) {
            cfg.description = description;
        }

        let license: *u8 = parse_section_value(pkg_section, "license\0" as *u8);
        if license != (0 as *u8) {
            cfg.license = license;
        }
    }

    // Parse [build] section
    let build_section: *u8 = find_section(buf, "build\0" as *u8);
    if build_section != (0 as *u8) {
        let src_dir: *u8 = parse_section_value(build_section, "src\0" as *u8);
        if src_dir != (0 as *u8) {
            cfg.src_dir = src_dir;
        }

        let target_dir: *u8 = parse_section_value(build_section, "target\0" as *u8);
        if target_dir != (0 as *u8) {
            cfg.target_dir = target_dir;
        }

        let main_file: *u8 = parse_section_value(build_section, "main\0" as *u8);
        if main_file != (0 as *u8) {
            cfg.main_file = main_file;
        }
    }

    free(buf as *void);
    return cfg;
}

// ==================== Config Validation ====================

pub fn config_validate(cfg: *Config) -> bool {
    if cfg.name == (0 as *u8) {
        puts("Error: package.name is required\0" as *u8);
        return false;
    }

    if cfg.version == (0 as *u8) {
        puts("Error: package.version is required\0" as *u8);
        return false;
    }

    return true;
}

// ==================== Config Display ====================

pub fn config_print(cfg: *Config) {
    puts("Project Configuration:\0" as *u8);
    puts("  name: \0" as *u8);
    puts(cfg.name);
    puts("\n  version: \0" as *u8);
    puts(cfg.version);
    puts("\n  edition: \0" as *u8);
    puts(cfg.edition);
    if cfg.description != (0 as *u8) {
        puts("\n  description: \0" as *u8);
        puts(cfg.description);
    }
    if cfg.license != (0 as *u8) {
        puts("\n  license: \0" as *u8);
        puts(cfg.license);
    }
    puts("\n\0" as *u8);
}
