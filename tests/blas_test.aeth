// BLAS FFI Test
// Tests BLAS bindings for linear algebra operations
// Link with: -lopenblas or -lblas

extern "C" {
    fn printf(fmt: *u8, ...) -> i32;
    fn malloc(size: u64) -> *u8;
    fn free(ptr: *u8);
}

// Import BLAS bindings
use stdlib::blas::*;

fn test_dot_product() {
    // Test vectors: x = [1, 2, 3, 4], y = [1, 1, 1, 1]
    // Expected: 1*1 + 2*1 + 3*1 + 4*1 = 10
    let x: [f32; 4] = [1.0, 2.0, 3.0, 4.0];
    let y: [f32; 4] = [1.0, 1.0, 1.0, 1.0];

    let result: f32 = blas_dot(4, &x[0], &y[0]);
    printf("dot product: %f (expected: 10.0)\n\0" as *u8, result as f64);
}

fn test_axpy() {
    // y = 2.0 * x + y
    // x = [1, 2, 3], y = [1, 1, 1]
    // Expected: y = [3, 5, 7]
    let x: [f32; 3] = [1.0, 2.0, 3.0];
    let mut y: [f32; 3] = [1.0, 1.0, 1.0];

    blas_axpy(3, 2.0, &x[0], &y[0]);
    printf("axpy result: [%f, %f, %f] (expected: [3, 5, 7])\n\0" as *u8,
           y[0] as f64, y[1] as f64, y[2] as f64);
}

fn test_norm() {
    // ||[3, 4]|| = 5
    let x: [f32; 2] = [3.0, 4.0];
    let result: f32 = blas_norm(2, &x[0]);
    printf("L2 norm: %f (expected: 5.0)\n\0" as *u8, result as f64);
}

fn test_matmul() {
    // A = [[1, 2], [3, 4]] (2x2)
    // B = [[1, 0], [0, 1]] (2x2, identity)
    // C = A * B = A
    let a: [f32; 4] = [1.0, 2.0, 3.0, 4.0];
    let b: [f32; 4] = [1.0, 0.0, 0.0, 1.0];
    let mut c: [f32; 4] = [0.0, 0.0, 0.0, 0.0];

    blas_matmul(2, 2, 2, &a[0], &b[0], &c[0]);
    printf("matmul result:\n\0" as *u8);
    printf("  [%f, %f]\n\0" as *u8, c[0] as f64, c[1] as f64);
    printf("  [%f, %f]\n\0" as *u8, c[2] as f64, c[3] as f64);
    printf("expected: [[1, 2], [3, 4]]\n\0" as *u8);
}

fn main() {
    printf("=== BLAS FFI Tests ===\n\n\0" as *u8);

    test_dot_product();
    test_axpy();
    test_norm();
    test_matmul();

    printf("\n=== Tests Complete ===\n\0" as *u8);
}
