/* Generated by AetherLang C Backend */
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

/* AetherLang Runtime */
static void aether_print(const char* s) { printf("%s", s); }
static void aether_println(const char* s) { printf("%s\n", s); }
static void aether_print_i64(int64_t n) { printf("%lld", (long long)n); }
static void aether_println_i64(int64_t n) { printf("%lld\n", (long long)n); }
static void aether_assert(bool c) { if(!c) { fprintf(stderr, "Assertion failed\n"); exit(1); } }

/* Struct Definitions */
struct Slice {
    struct T* ptr;
    struct usize len;
};

struct Option_i64 safe_div(int64_t, int64_t);
struct Result_i64_i64 parse_positive(int64_t);
void main(void);

struct Option_i64 safe_div(int64_t _arg0, int64_t _arg1) {
    int64_t _t0;
    int64_t _t1;
    int64_t _t2;
    int64_t _t3;
    int64_t _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _t1 == 0LL;
    if (_t2) goto L_then; else goto L_else;
L_then:
    return Option_None;
L_else:
    goto L_merge;
L_merge:
    _t3 = _t0 / _t1;
    _t4 = Option_Some(_t3);
    return _t4;
}

struct Result_i64_i64 parse_positive(int64_t _arg0) {
    int64_t _t0;
    int64_t _t1;
    int64_t _t2;
    int64_t _t3;
    int64_t _t4;
    
    _t0 = _arg0;
    _t1 = _t0 < 0LL;
    if (_t1) goto L_then; else goto L_else;
L_then:
    _t2 = -1LL;
    _t3 = Result_Err(_t2);
    return _t3;
L_else:
    goto L_merge;
L_merge:
    _t4 = Result_Ok(_t0);
    return _t4;
}

void main(void) {
    int64_t _t4;
    struct Option_i64 _t0;
    struct Option_i64 _t1;
    struct Result_i64_i64 _t2;
    struct Result_i64_i64 _t3;
    
    _t0 = safe_div(10LL, 2LL);
    _t1 = _t0;
    _t2 = parse_positive(42LL);
    _t3 = _t2;
    aether_println_i64(42LL);
    return;
}

