# AetherLang 类型系统

> 本文档定义 AetherLang 的类型系统，包括类型规则和所有权语义。

## 1. 所有权系统

AetherLang 使用简化的所有权系统，无需生命周期标注。

### 1.1 三种所有权模式

| 模式 | 关键字 | 语义 |
|------|--------|------|
| **所有权** | `own` (默认) | 值的所有权转移给接收者 |
| **不可变借用** | `ref` | 只读访问，不转移所有权 |
| **可变借用** | `mut` | 读写访问，不转移所有权 |

### 1.2 所有权规则

1. **每个值有且只有一个所有者**
2. **当所有者离开作用域，值被释放**
3. **不可变借用可以有多个**
4. **可变借用同时只能有一个**
5. **不可变和可变借用不能同时存在**

### 1.3 示例

```aether
fn main() {
    let s = String.new("hello")
    
    // 不可变借用 - OK
    read(ref s)
    read(ref s)  // 可以多次不可变借用
    
    // 可变借用
    modify(mut s)
    
    // 转移所有权
    consume(own s)
    // s 不再可用
}

fn read(data: ref String) {
    println(data)
}

fn modify(data: mut String) {
    data.push('!')
}

fn consume(data: own String) {
    // data 在函数结束时释放
}
```

## 2. 类型推导

AetherLang 支持局部类型推导：

```aether
let x = 42        // 推导为 i32
let y = 3.14      // 推导为 f64
let s = "hello"   // 推导为 &str
let v = [1, 2, 3] // 推导为 [i32; 3]
```

显式类型标注：

```aether
let x: i64 = 42
let count: usize = 100
```

## 3. 类型兼容性

### 3.1 数值类型

- 整数类型之间**不**隐式转换
- 需要显式 `as` 转换

```aether
let x: i32 = 42
let y: i64 = x as i64  // 显式转换
```

### 3.2 指针和引用

| 转换 | 是否允许 |
|------|----------|
| `&T` → `*T` | ✅ |
| `*T` → `&T` | ❌ (需要 unsafe) |
| `&mut T` → `&T` | ✅ |
| `&T` → `&mut T` | ❌ |

## 4. 泛型 (v1.0 简化版)

v1.0 支持简化的泛型：

```aether
// 泛型函数
fn swap<T>(a: mut T, b: mut T) {
    let temp = a
    a = b
    b = temp
}

// 泛型结构体
struct Vec<T> {
    data: *T
    len: usize
    cap: usize
}
```

> ⚠️ v1.0 不支持 trait bounds，完整泛型系统在 v2.0。

## 5. 复合类型

### 5.1 数组

```aether
let arr: [i32; 5] = [1, 2, 3, 4, 5]
let first = arr[0]
```

### 5.2 切片

```aether
let slice: [i32] = arr[1..4]  // 元素 1, 2, 3
```

### 5.3 元组

```aether
let tuple: (i32, f64, bool) = (42, 3.14, true)
let (x, y, z) = tuple  // 解构
```

### 5.4 Option 类型

```aether
enum Option<T> {
    Some(T)
    None
}

let maybe: Option<i32> = Some(42)
match maybe {
    Some(value) => println("Got: {}", value)
    None => println("Nothing")
}
```

### 5.5 Result 类型

```aether
enum Result<T, E> {
    Ok(T)
    Err(E)
}

fn divide(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        return Err("Division by zero")
    }
    return Ok(a / b)
}
```

## 6. 类型别名

```aether
type Size = usize
type Callback = fn(i32) -> bool
```

## 7. 类型检查规则

### 7.1 二元运算

| 运算 | 左操作数 | 右操作数 | 结果 |
|------|----------|----------|------|
| `+` `-` `*` `/` `%` | 数值 T | 数值 T | T |
| `==` `!=` `<` `<=` `>` `>=` | 任意 T | T | bool |
| `&&` `||` | bool | bool | bool |
| `&` `|` `^` `<<` `>>` | 整数 T | 整数 T | T |

### 7.2 函数调用

- 参数数量必须匹配
- 参数类型必须兼容
- 返回类型必须匹配

## 8. 实现参考

- 类型定义: [`src/types/type_system.rs`](file:///c:/Users/Z1529/.gemini/antigravity/scratch/AetherLang/src/types/type_system.rs)
- 语义分析: [`src/frontend/semantic.rs`](file:///c:/Users/Z1529/.gemini/antigravity/scratch/AetherLang/src/frontend/semantic.rs)
