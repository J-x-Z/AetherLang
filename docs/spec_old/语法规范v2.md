# AetherLang v2.0 语法规范 (AI-Native)

> **版本**: 2.0-draft
> **状态**: 设计冻结阶段
> **核心创新**: 借鉴中文 SVO 语法结构，让 AI 更早获取核心语义

---

## 设计哲学

### 从中文语法借鉴的核心理念

中文是 SVO (主-谓-宾) 结构，动词（核心操作）出现在句子中间位置。
这使得读者/AI 可以更早获取"正在做什么"的核心信息。

**传统语法问题** (以 Rust 为例):
```rust
fn foo(x: i32, y: i32) -> Result<i32, Error> { ... }
//                        ^^^^^^^^^^^^^^^^^^ 返回类型在最后
//                                            AI 需要很长注意力窗口
```

**AetherLang SVO 改进**:
```aether
// 核心信息前置：名称 + 返回类型紧邻
fn foo -> Result[i32, Error] (x: i32, y: i32) { ... }
//        ^^^^^^^^^^^^^^^^^^^ 返回类型紧跟名称，AI 立即知道输出

// 或更激进的 SVO 式：
foo: fn(i32, i32) -> Result[i32, Error] { ... }
//   ^^ 动词(函数声明)在主语(名称)后，宾语(签名)跟随
```

### 语法设计原则

1. **核心信息前置**: 名称、返回类型、效果标注在前
2. **参数细节后置**: 详细参数列表在后
3. **契约就近原则**: 前置条件紧跟参数，后置条件紧跟返回类型
4. **限制灵活性**: 每种构造只有一种写法

---

## 关键字 (English Only)

```
// 定义类
fn, type, let, mut, const, struct, enum, trait, impl, pub

// 控制流
if, else, match, for, in, while, loop, break, continue, return

// 契约 (新增)
requires, ensures, invariant, where

// 效果 (新增)
pure, effect, unsafe

// 所有权 (新增，语法显式化)
own, ref, mut, shared

// 布尔
true, false
```

---

## 核心语法结构

### 函数定义 (SVO 改造)

**结构**: `名称: fn -> 返回类型 (参数列表) [契约] { 函数体 }`

```bnf
function_def  ::= identifier ':' 'fn' 
                  return_clause?
                  '(' param_list? ')'
                  effect_clause?
                  contract_block?
                  block

return_clause ::= '->' type_expr

effect_clause ::= 'pure' 
                | 'effect' '[' effect_list ']'

effect_list   ::= effect_kind (',' effect_kind)*

effect_kind   ::= 'read' | 'write' | 'io' | 'alloc' | 'panic'

contract_block ::= '[' contract_clause (',' contract_clause)* ']'

contract_clause ::= 'requires' expr
                  | 'ensures' expr
```

**示例**:
```aether
// 核心信息：divide 是函数，返回 i64，需要除数非零
divide: fn -> i64 (numerator: i64, divisor: i64) 
    [requires divisor != 0, ensures result * divisor <= numerator]
{
    numerator / divisor
}

// 纯函数标注
add: fn -> i64 (a: i64, b: i64) pure {
    a + b
}

// 有副作用的函数
read_file: fn -> Result[String, IoError] (path: ref str) effect[io, alloc] {
    // ...
}
```

**对比传统语法**:
```rust
// Rust: 返回类型在最后，AI 需要扫描整行
fn divide(numerator: i64, divisor: i64) -> i64 { ... }

// AetherLang: 返回类型紧跟函数名，AI 立即知道输出
divide: fn -> i64 (numerator: i64, divisor: i64) { ... }
```

---

### 类型定义 (SVO 改造)

**结构**: `名称: type = 类型体 [不变量]`

```bnf
type_def      ::= identifier ':' 'type' type_params? '=' type_body invariant_block?

type_params   ::= '[' identifier (',' identifier)* ']'

type_body     ::= struct_body | enum_body | type_alias

struct_body   ::= 'struct' '{' field_list? '}'

enum_body     ::= 'enum' '{' variant_list '}'

variant_list  ::= variant (',' variant)*

variant       ::= identifier ('(' type_expr (',' type_expr)* ')')?

invariant_block ::= '[' 'invariant' expr (',' expr)* ']'
```

**示例**:
```aether
// 带不变量的类型
Point: type = struct {
    x: i64,
    y: i64,
} [invariant x >= 0, y >= 0]

// 枚举
Option: type[T] = enum {
    Some(T),
    None,
}

// 精化类型 (Refinement Type)
NonZero: type = i64 [invariant self != 0]

// 非空列表
NonEmptyList: type[T] = struct {
    head: T,
    tail: List[T],
} [invariant self.len() > 0]
```

---

### 变量绑定

**结构**: `名称: 类型 = 值` 或 `名称 := 值` (类型推导)

```bnf
let_stmt      ::= identifier ':' type_expr '=' expr
                | identifier ':=' expr
                | identifier ':' 'mut' type_expr '=' expr
                | identifier ':=' 'mut' expr
```

**示例**:
```aether
// 显式类型
x: i64 = 42

// 类型推导
y := 42

// 可变变量
count: mut i64 = 0
counter := mut 0
```

---

### 所有权标注 (语法显式化)

**核心创新**: 所有权不再是隐式规则，而是类型的一部分。

```bnf
ownership_mod ::= 'own' | 'ref' | 'mut' | 'shared'

type_with_ownership ::= ownership_mod? type_expr
```

**示例**:
```aether
// 拥有所有权 (移动语义)
process: fn -> own Vec[u8] (data: own Vec[u8]) {
    transform(data)  // data 被移动
}

// 不可变借用
view: fn -> () (data: ref Vec[u8]) {
    println(data.len())  // 只读访问
}

// 可变借用
modify: fn -> () (data: mut Vec[u8]) {
    data.push(42)  // 可修改
}

// 共享所有权 (引用计数)
share: fn -> shared Handle (h: shared Handle) {
    clone(h)
}
```

---

### 控制流 (保持简洁)

```bnf
if_expr       ::= 'if' expr block ('else' block)?

match_expr    ::= 'match' expr '{' match_arm+ '}'

match_arm     ::= pattern '=>' expr ','?

for_stmt      ::= 'for' identifier 'in' expr block

while_stmt    ::= 'while' expr block

loop_stmt     ::= 'loop' block
```

**示例**:
```aether
// 条件
if x > 0 {
    positive()
} else {
    non_positive()
}

// 模式匹配
match result {
    Ok(value) => process(value),
    Err(e) => handle_error(e),
}

// 循环
for item in collection {
    process(item)
}

while condition {
    iterate()
}
```

---

### 契约系统详解

**前置条件 (requires)**: 调用者必须满足
**后置条件 (ensures)**: 函数必须保证
**不变量 (invariant)**: 类型实例永远满足

```aether
// 完整的契约示例
binary_search: fn -> Option[usize] (arr: ref [i64], target: i64)
    [
        requires arr.is_sorted(),           // 前置：数组必须有序
        requires arr.len() > 0,             // 前置：数组非空
        ensures match result {              // 后置：如果找到，索引有效
            Some(i) => arr[i] == target,
            None => true,
        }
    ]
{
    // 实现...
}
```

**验证策略**:
- `@static`: 编译期静态验证
- `@runtime`: 运行时断言
- 默认：编译器自动选择

```aether
// 强制静态验证
@static
sqrt: fn -> f64 (x: f64) [requires x >= 0.0] { ... }

// 强制运行时检查
@runtime
parse: fn -> Result[i64, Error] (s: ref str) [ensures result.is_ok() => result.unwrap() >= 0] { ... }
```

---

### 效果系统详解

**效果类型**:
- `pure`: 无副作用，引用透明
- `read`: 读取外部状态
- `write`: 修改外部状态
- `io`: 输入输出
- `alloc`: 内存分配
- `panic`: 可能 panic

```aether
// 纯函数：可以自由优化、并行、缓存
add: fn -> i64 (a: i64, b: i64) pure {
    a + b
}

// 带效果的函数
write_log: fn -> () (msg: ref str) effect[io, write] {
    println(msg)
}

// 效果传播规则：调用有效果的函数，调用者也必须标注
process: fn -> () () effect[io] {
    write_log("starting")  // 调用了 io 效果的函数
}
```

---

## 与传统语法的对比总结

| 特性 | 传统 (Rust/C++) | AetherLang (AI-Native) |
|------|----------------|------------------------|
| 返回类型位置 | 最后 | 紧跟函数名 |
| 所有权 | 隐式规则 | 显式类型修饰 |
| 契约 | 注释/文档 | 语法内置 |
| 副作用 | 隐式 | 效果类型标注 |
| 生命周期 | 复杂标注 | 简化的所有权模型 |
| 语法灵活性 | 高 | 限制（可预测性优先） |

---

## AI-IR 设计概要

### 位置在编译流程中

```
Source Code
    ↓
[Lexer] → Tokens
    ↓
[Parser] → AST
    ↓
[Semantic] → Typed AST + Contracts + Effects
    ↓
[AI-IR Gen] → AI-IR  ◀━━ AI 可读写此层
    ↓
[Lowering] → Traditional IR
    ↓
[Backend] → C / LLVM / Native
```

### AI-IR 包含的信息

1. **语义图**: 调用关系、数据流、依赖
2. **意图标注**: 高层算法意图 (e.g., "排序", "过滤")
3. **契约约束**: 所有前置/后置/不变量
4. **效果信息**: 副作用类型
5. **优化提示**: 热点、瓶颈、优化机会

---

## 版本历史

| 版本 | 日期 | 变更 |
|------|------|------|
| 2.0-draft-r2 | 2026-01-13 | 修正：英文关键字 + SVO 结构借鉴 |
| 2.0-draft | 2026-01-13 | 初始 AI-Native 设计 (已废弃) |
