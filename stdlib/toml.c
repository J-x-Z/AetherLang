/* Generated by AetherLang C Backend */
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <immintrin.h>  /* SSE/AVX */

/* AetherLang Runtime */
static void aether_print(const char* s) { printf("%s", s); }
static void aether_println(const char* s) { printf("%s\n", s); }
static void aether_print_i64(int64_t n) { printf("%lld", (long long)n); }
static void aether_println_i64(int64_t n) { printf("%lld\n", (long long)n); }
static void aether_assert(bool c) { if(!c) { fprintf(stderr, "Assertion failed\n"); exit(1); } }

/* Struct Definitions */
struct TomlEntry {
    uint8_t* key;
    int32_t kind;
    uint8_t* str_val;
    int64_t int_val;
    bool bool_val;
};

struct TomlDoc {
    struct TomlEntry** entries;
    int32_t count;
};

struct TomlDoc* toml_new(void);
void toml_free(struct TomlDoc**);
bool is_whitespace(uint8_t);
bool is_newline(uint8_t);
bool is_alpha(uint8_t);
bool is_alnum(uint8_t);
bool toml_parse(struct TomlDoc**, uint8_t*);
uint8_t* toml_get_string(struct TomlDoc**, uint8_t*);
int64_t toml_get_int(struct TomlDoc**, uint8_t*);
bool toml_get_bool(struct TomlDoc**, uint8_t*, bool);
bool toml_has_key(struct TomlDoc**, uint8_t*);

struct TomlDoc* toml_new(void) {
    int32_t* _t9;
    int64_t _t2;
    int64_t _t3;
    int64_t _t4;
    struct TomlDoc* _t7;
    struct TomlEntry** _t5;
    struct TomlEntry** _t6;
    struct TomlEntry*** _t8;
    uint64_t _t0;
    uint64_t _t1;
    
    _t0 = (uint64_t)MAX_ENTRIES;
    _t1 = (uint64_t)48LL;
    _t2 = _t0 * _t1;
    _t3 = (int64_t)_t2;
    malloc(_t3);
    _t5 = (struct TomlEntry**)_t4;
    _t6 = _t5;
    struct TomlDoc _alloca__t7;
    _t7 = &_alloca__t7;
    _t8 = &_t7->entries;
    *_t8 = _t6;
    _t9 = &_t7->count;
    *_t9 = 0LL;
    return _t7;
}

void toml_free(struct TomlDoc** _arg0) {
    int64_t _t5;
    struct TomlDoc* _t1;
    struct TomlDoc* _t6;
    struct TomlDoc** _t0;
    struct TomlEntry** _t3;
    struct TomlEntry** _t4;
    struct TomlEntry** _t8;
    struct TomlEntry*** _t2;
    struct TomlEntry*** _t7;
    void* _t9;
    
    _t0 = _arg0;
    _t1 = *_t0;
    _t2 = &_t1->entries;
    _t3 = *_t2;
    _t4 = (struct TomlEntry**)0LL;
    _t5 = _t3 != _t4;
    if (_t5) goto L_then; else goto L_else;
L_then:
    _t6 = *_t0;
    _t7 = &_t6->entries;
    _t8 = *_t7;
    _t9 = (void*)_t8;
    free(_t9);
    goto L_merge;
L_else:
    goto L_merge;
L_merge:
    return;
}

bool is_whitespace(uint8_t _arg0) {
    int64_t _t2;
    int64_t _t4;
    int64_t _t5;
    uint8_t _t0;
    uint8_t _t1;
    uint8_t _t3;
    
    _t0 = _arg0;
    _t1 = (uint8_t)32LL;
    _t2 = _t0 == _t1;
    _t3 = (uint8_t)9LL;
    _t4 = _t0 == _t3;
    _t5 = _t2 || _t4;
    return _t5;
}

bool is_newline(uint8_t _arg0) {
    int64_t _t2;
    int64_t _t4;
    int64_t _t5;
    uint8_t _t0;
    uint8_t _t1;
    uint8_t _t3;
    
    _t0 = _arg0;
    _t1 = (uint8_t)10LL;
    _t2 = _t0 == _t1;
    _t3 = (uint8_t)13LL;
    _t4 = _t0 == _t3;
    _t5 = _t2 || _t4;
    return _t5;
}

bool is_alpha(uint8_t _arg0) {
    int64_t _t10;
    int64_t _t11;
    int64_t _t2;
    int64_t _t4;
    int64_t _t5;
    int64_t _t7;
    int64_t _t9;
    uint8_t _t0;
    uint8_t _t1;
    uint8_t _t3;
    uint8_t _t6;
    uint8_t _t8;
    
    _t0 = _arg0;
    _t1 = (uint8_t)65LL;
    _t2 = _t0 >= _t1;
    _t3 = (uint8_t)90LL;
    _t4 = _t0 <= _t3;
    _t5 = _t2 && _t4;
    _t6 = (uint8_t)97LL;
    _t7 = _t0 >= _t6;
    _t8 = (uint8_t)122LL;
    _t9 = _t0 <= _t8;
    _t10 = _t7 && _t9;
    _t11 = _t5 || _t10;
    return _t11;
}

bool is_alnum(uint8_t _arg0) {
    bool _t1;
    int64_t _t10;
    int64_t _t12;
    int64_t _t13;
    int64_t _t3;
    int64_t _t5;
    int64_t _t6;
    int64_t _t7;
    int64_t _t9;
    uint8_t _t0;
    uint8_t _t11;
    uint8_t _t2;
    uint8_t _t4;
    uint8_t _t8;
    
    _t0 = _arg0;
    _t1 = is_alpha(_t0);
    _t2 = (uint8_t)48LL;
    _t3 = _t0 >= _t2;
    _t4 = (uint8_t)57LL;
    _t5 = _t0 <= _t4;
    _t6 = _t3 && _t5;
    _t7 = _t1 || _t6;
    _t8 = (uint8_t)95LL;
    _t9 = _t0 == _t8;
    _t10 = _t7 || _t9;
    _t11 = (uint8_t)45LL;
    _t12 = _t0 == _t11;
    _t13 = _t10 || _t12;
    return _t13;
}

bool toml_parse(struct TomlDoc** _arg0, uint8_t* _arg1) {
    int32_t _t6;
    int32_t _t7;
    int64_t _t2;
    int64_t _t5;
    struct TomlDoc** _t0;
    uint8_t* _t1;
    uint8_t* _t3;
    uint8_t* _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = 0LL;
    _t3 = (uint8_t*)0LL;
    _t4 = _t3;
    strlen(_t1);
    _t6 = (int32_t)_t5;
    _t7 = _t6;
    return 1;
}

uint8_t* toml_get_string(struct TomlDoc** _arg0, uint8_t* _arg1) {
    int64_t _t2;
    struct TomlDoc** _t0;
    uint8_t* _t1;
    uint8_t* _t3;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = 0LL;
    _t3 = (uint8_t*)0LL;
    return _t3;
}

int64_t toml_get_int(struct TomlDoc** _arg0, uint8_t* _arg1) {
    int64_t _t2;
    struct TomlDoc** _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = 0LL;
    return 0LL;
}

bool toml_get_bool(struct TomlDoc** _arg0, uint8_t* _arg1, bool _arg2) {
    bool _t2;
    int64_t _t3;
    struct TomlDoc** _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = 0LL;
    return _t2;
}

bool toml_has_key(struct TomlDoc** _arg0, uint8_t* _arg1) {
    int64_t _t2;
    struct TomlDoc** _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = 0LL;
    return 0;
}

