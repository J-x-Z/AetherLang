// AetherLang Computation Graph Library (Simplified)
// Lazy evaluation DAG for building and executing computation graphs

// ==================== Node Types ====================

// Operation types for computation graph
const OP_CONST: i32 = 0
const OP_VAR: i32 = 1
const OP_ADD: i32 = 2
const OP_SUB: i32 = 3
const OP_MUL: i32 = 4
const OP_DIV: i32 = 5
const OP_NEG: i32 = 6
const OP_EXP: i32 = 7
const OP_LOG: i32 = 8
const OP_RELU: i32 = 9
const OP_SIGMOID: i32 = 10

extern "C" {
    fn malloc(size: u64) -> *void;
    fn realloc(ptr: *void, size: u64) -> *void;
    fn expf(x: f32) -> f32;
    fn logf(x: f32) -> f32;
}

// Node data stored in parallel arrays for simpler access
pub struct Graph {
    ops: *i32,           // Operation type per node
    values: *f32,        // Value per node
    input1s: *i32,       // Input 1 per node
    input2s: *i32,       // Input 2 per node
    evaluated: *bool,    // Evaluated flag per node
    count: i32,
    capacity: i32,
}

// ==================== Graph Creation ====================

pub fn graph_new() -> Graph {
    let cap = 64
    let ops: *i32 = malloc(cap * 4) as *i32
    let values: *f32 = malloc(cap * 4) as *f32
    let input1s: *i32 = malloc(cap * 4) as *i32
    let input2s: *i32 = malloc(cap * 4) as *i32
    let evaluated: *bool = malloc(cap) as *bool
    return Graph {
        ops: ops,
        values: values,
        input1s: input1s,
        input2s: input2s,
        evaluated: evaluated,
        count: 0,
        capacity: cap,
    }
}

fn add_node(g: *Graph, op: i32, value: f32, in1: i32, in2: i32) -> i32 {
    let id = g.count
    g.ops[id] = op
    g.values[id] = value
    g.input1s[id] = in1
    g.input2s[id] = in2
    g.evaluated[id] = false
    g.count = g.count + 1
    return id
}

// ==================== Node Creation ====================

pub fn const_node(g: *Graph, value: f32) -> i32 {
    let id = add_node(g, OP_CONST, value, -1, -1)
    g.evaluated[id] = true
    return id
}

pub fn var_node(g: *Graph) -> i32 {
    return add_node(g, OP_VAR, 0.0, -1, -1)
}

pub fn set_var(g: *Graph, id: i32, value: f32) {
    g.values[id] = value
    g.evaluated[id] = true
}

// ==================== Binary Operations ====================

pub fn add_op(g: *Graph, a: i32, b: i32) -> i32 {
    return add_node(g, OP_ADD, 0.0, a, b)
}

pub fn sub_op(g: *Graph, a: i32, b: i32) -> i32 {
    return add_node(g, OP_SUB, 0.0, a, b)
}

pub fn mul_op(g: *Graph, a: i32, b: i32) -> i32 {
    return add_node(g, OP_MUL, 0.0, a, b)
}

pub fn div_op(g: *Graph, a: i32, b: i32) -> i32 {
    return add_node(g, OP_DIV, 0.0, a, b)
}

// ==================== Unary Operations ====================

pub fn neg_op(g: *Graph, a: i32) -> i32 {
    return add_node(g, OP_NEG, 0.0, a, -1)
}

pub fn exp_op(g: *Graph, a: i32) -> i32 {
    return add_node(g, OP_EXP, 0.0, a, -1)
}

pub fn relu_op(g: *Graph, a: i32) -> i32 {
    return add_node(g, OP_RELU, 0.0, a, -1)
}

pub fn sigmoid_op(g: *Graph, a: i32) -> i32 {
    return add_node(g, OP_SIGMOID, 0.0, a, -1)
}

// ==================== Evaluation ====================

fn eval_node(g: *Graph, id: i32) -> f32 {
    // Already evaluated?
    if g.evaluated[id] {
        return g.values[id]
    }
    
    // Get input values
    let v1: f32 = 0.0
    let v2: f32 = 0.0
    let in1 = g.input1s[id]
    let in2 = g.input2s[id]
    if in1 >= 0 {
        v1 = eval_node(g, in1)
    }
    if in2 >= 0 {
        v2 = eval_node(g, in2)
    }
    
    // Compute based on operation
    let op = g.ops[id]
    let result: f32 = 0.0
    if op == OP_ADD {
        result = v1 + v2
    } else if op == OP_SUB {
        result = v1 - v2
    } else if op == OP_MUL {
        result = v1 * v2
    } else if op == OP_DIV {
        result = v1 / v2
    } else if op == OP_NEG {
        result = -v1
    } else if op == OP_EXP {
        result = expf(v1)
    } else if op == OP_LOG {
        result = logf(v1)
    } else if op == OP_RELU {
        if v1 > 0.0 {
            result = v1
        } else {
            result = 0.0
        }
    } else if op == OP_SIGMOID {
        result = 1.0 / (1.0 + expf(-v1))
    }
    
    // Cache result
    g.values[id] = result
    g.evaluated[id] = true
    
    return result
}

pub fn eval(g: *Graph, output_id: i32) -> f32 {
    return eval_node(g, output_id)
}

pub fn graph_reset(g: *Graph) {
    let i: i32 = 0
    while i < g.count {
        let op = g.ops[i]
        if op != OP_CONST && op != OP_VAR {
            g.evaluated[i] = false
        }
        i = i + 1
    }
}
