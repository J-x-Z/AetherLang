/* Generated by AetherLang C Backend */
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <immintrin.h>  /* SSE/AVX */

/* AetherLang Runtime */
static void aether_print(const char* s) { printf("%s", s); }
static void aether_println(const char* s) { printf("%s\n", s); }
static void aether_print_i64(int64_t n) { printf("%lld", (long long)n); }
static void aether_println_i64(int64_t n) { printf("%lld\n", (long long)n); }
static void aether_assert(bool c) { if(!c) { fprintf(stderr, "Assertion failed\n"); exit(1); } }

/* Struct Definitions */
struct Args {
    int32_t argc;
    uint8_t** argv;
};

struct Args* args_init(int32_t, uint8_t**);
int32_t args_count(struct Args**);
uint8_t* args_get(struct Args**, int32_t);
uint8_t* args_program(struct Args**);
bool args_has(struct Args**, uint8_t*);
bool args_has_flag(struct Args**, uint8_t*, uint8_t*);
uint8_t* args_get_value(struct Args**, uint8_t*, uint8_t*);
uint8_t* args_positional(struct Args**, int32_t);
uint8_t* args_subcommand(struct Args**);
bool args_is_subcommand(struct Args**, uint8_t*);
bool args_help(struct Args**);
bool args_version(struct Args**);
bool args_verbose(struct Args**);
bool args_quiet(struct Args**);

struct Args* args_init(int32_t _arg0, uint8_t** _arg1) {
    int32_t _t0;
    int32_t* _t3;
    struct Args* _t2;
    uint8_t** _t1;
    uint8_t*** _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    struct Args _alloca__t2;
    _t2 = &_alloca__t2;
    _t3 = &_t2->argc;
    *_t3 = _t0;
    _t4 = &_t2->argv;
    *_t4 = _t1;
    return _t2;
}

int32_t args_count(struct Args** _arg0) {
    int32_t _t3;
    int32_t* _t2;
    struct Args* _t1;
    struct Args** _t0;
    
    _t0 = _arg0;
    _t1 = *_t0;
    _t2 = &_t1->argc;
    _t3 = *_t2;
    return _t3;
}

uint8_t* args_get(struct Args** _arg0, int32_t _arg1) {
    int32_t _t1;
    int32_t _t2;
    int32_t _t6;
    int32_t* _t5;
    int64_t _t3;
    int64_t _t7;
    int64_t _t8;
    struct Args* _t10;
    struct Args* _t4;
    struct Args** _t0;
    uint8_t* _t14;
    uint8_t* _t9;
    uint8_t** _t12;
    uint8_t** _t13;
    uint8_t*** _t11;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = (int32_t)0LL;
    _t3 = _t1 < _t2;
    _t4 = *_t0;
    _t5 = &_t4->argc;
    _t6 = *_t5;
    _t7 = _t1 >= _t6;
    _t8 = _t3 || _t7;
    if (_t8) goto L_then; else goto L_else;
L_then:
    _t9 = (uint8_t*)0LL;
    return _t9;
L_else:
    goto L_merge;
L_merge:
    _t10 = *_t0;
    _t11 = &_t10->argv;
    _t12 = *_t11;
    _t13 = &_t12[_t1];
    _t14 = *_t13;
    return _t14;
}

uint8_t* args_program(struct Args** _arg0) {
    int32_t _t1;
    struct Args** _t0;
    uint8_t* _t2;
    
    _t0 = _arg0;
    _t1 = (int32_t)0LL;
    _t2 = args_get(_t0, _t1);
    return _t2;
}

bool args_has(struct Args** _arg0, uint8_t* _arg1) {
    int64_t _t2;
    struct Args** _t0;
    uint8_t* _t1;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = 1LL;
    return 0;
}

bool args_has_flag(struct Args** _arg0, uint8_t* _arg1, uint8_t* _arg2) {
    int64_t _t3;
    struct Args** _t0;
    uint8_t* _t1;
    uint8_t* _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = 1LL;
    return 0;
}

uint8_t* args_get_value(struct Args** _arg0, uint8_t* _arg1, uint8_t* _arg2) {
    int64_t _t3;
    struct Args** _t0;
    uint8_t* _t1;
    uint8_t* _t2;
    uint8_t* _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = 1LL;
    _t4 = (uint8_t*)0LL;
    return _t4;
}

uint8_t* args_positional(struct Args** _arg0, int32_t _arg1) {
    int32_t _t1;
    int64_t _t2;
    int64_t _t3;
    struct Args** _t0;
    uint8_t* _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = 0LL;
    _t3 = 1LL;
    _t4 = (uint8_t*)0LL;
    return _t4;
}

uint8_t* args_subcommand(struct Args** _arg0) {
    int32_t _t1;
    struct Args** _t0;
    uint8_t* _t2;
    
    _t0 = _arg0;
    _t1 = (int32_t)0LL;
    _t2 = args_positional(_t0, _t1);
    return _t2;
}

bool args_is_subcommand(struct Args** _arg0, uint8_t* _arg1) {
    int32_t _t7;
    int64_t _t5;
    int64_t _t6;
    int64_t _t8;
    struct Args** _t0;
    uint8_t* _t1;
    uint8_t* _t2;
    uint8_t* _t3;
    uint8_t* _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = args_subcommand(_t0);
    _t3 = _t2;
    _t4 = (uint8_t*)0LL;
    _t5 = _t3 == _t4;
    if (_t5) goto L_then; else goto L_else;
L_then:
    return 0;
L_else:
    goto L_merge;
L_merge:
    strcmp(_t3, _t1);
    _t7 = (int32_t)0LL;
    _t8 = _t6 == _t7;
    return _t8;
}

bool args_help(struct Args** _arg0) {
    bool _t3;
    struct Args** _t0;
    uint8_t* _t1;
    uint8_t* _t2;
    
    _t0 = _arg0;
    _t1 = (uint8_t*)"-h\u{0}";
    _t2 = (uint8_t*)"--help\u{0}";
    _t3 = args_has_flag(_t0, _t1, _t2);
    return _t3;
}

bool args_version(struct Args** _arg0) {
    bool _t3;
    struct Args** _t0;
    uint8_t* _t1;
    uint8_t* _t2;
    
    _t0 = _arg0;
    _t1 = (uint8_t*)"-V\u{0}";
    _t2 = (uint8_t*)"--version\u{0}";
    _t3 = args_has_flag(_t0, _t1, _t2);
    return _t3;
}

bool args_verbose(struct Args** _arg0) {
    bool _t3;
    struct Args** _t0;
    uint8_t* _t1;
    uint8_t* _t2;
    
    _t0 = _arg0;
    _t1 = (uint8_t*)"-v\u{0}";
    _t2 = (uint8_t*)"--verbose\u{0}";
    _t3 = args_has_flag(_t0, _t1, _t2);
    return _t3;
}

bool args_quiet(struct Args** _arg0) {
    bool _t3;
    struct Args** _t0;
    uint8_t* _t1;
    uint8_t* _t2;
    
    _t0 = _arg0;
    _t1 = (uint8_t*)"-q\u{0}";
    _t2 = (uint8_t*)"--quiet\u{0}";
    _t3 = args_has_flag(_t0, _t1, _t2);
    return _t3;
}

