// BLAS FFI Bindings for AetherLang
// Foreign Function Interface to CBLAS for high-performance linear algebra

// ==================== BLAS Level 1 (Vector Operations) ====================

// SAXPY: y = alpha * x + y (single precision)
extern "C" fn cblas_saxpy(n: i32, alpha: f32, x: *f32, incx: i32, y: *f32, incy: i32)

// DAXPY: y = alpha * x + y (double precision)
extern "C" fn cblas_daxpy(n: i32, alpha: f64, x: *f64, incx: i32, y: *f64, incy: i32)

// SDOT: dot product (single precision)
extern "C" fn cblas_sdot(n: i32, x: *f32, incx: i32, y: *f32, incy: i32) -> f32

// DDOT: dot product (double precision)
extern "C" fn cblas_ddot(n: i32, x: *f64, incx: i32, y: *f64, incy: i32) -> f64

// SNRM2: Euclidean norm (single precision)
extern "C" fn cblas_snrm2(n: i32, x: *f32, incx: i32) -> f32

// SSCAL: x = alpha * x (scale vector)
extern "C" fn cblas_sscal(n: i32, alpha: f32, x: *f32, incx: i32)

// ==================== BLAS Level 2 (Matrix-Vector Operations) ====================

// SGEMV: y = alpha * A * x + beta * y (single precision)
extern "C" fn cblas_sgemv(
    order: i32, trans: i32,
    m: i32, n: i32,
    alpha: f32, a: *f32, lda: i32,
    x: *f32, incx: i32,
    beta: f32, y: *f32, incy: i32
)

// ==================== BLAS Level 3 (Matrix-Matrix Operations) ====================

// SGEMM: C = alpha * A * B + beta * C (single precision)
extern "C" fn cblas_sgemm(
    order: i32, transA: i32, transB: i32,
    m: i32, n: i32, k: i32,
    alpha: f32, a: *f32, lda: i32,
    b: *f32, ldb: i32,
    beta: f32, c: *f32, ldc: i32
)

// DGEMM: C = alpha * A * B + beta * C (double precision)
extern "C" fn cblas_dgemm(
    order: i32, transA: i32, transB: i32,
    m: i32, n: i32, k: i32,
    alpha: f64, a: *f64, lda: i32,
    b: *f64, ldb: i32,
    beta: f64, c: *f64, ldc: i32
)

// ==================== Constants ====================

const CBLAS_ROW_MAJOR: i32 = 101
const CBLAS_COL_MAJOR: i32 = 102
const CBLAS_NO_TRANS: i32 = 111
const CBLAS_TRANS: i32 = 112

// ==================== High-Level Wrappers ====================

// Matrix multiplication using BLAS (single precision)
pub fn blas_matmul(
    m: i32, n: i32, k: i32,
    a: *f32, b: *f32, c: *f32
) {
    cblas_sgemm(
        CBLAS_ROW_MAJOR, CBLAS_NO_TRANS, CBLAS_NO_TRANS,
        m, n, k,
        1.0, a, k,
        b, n,
        0.0, c, n
    )
}

// Vector dot product wrapper
pub fn blas_dot(n: i32, x: *f32, y: *f32) -> f32 {
    return cblas_sdot(n, x, 1, y, 1)
}

// Vector scaling: x = alpha * x
pub fn blas_scale(n: i32, alpha: f32, x: *f32) {
    cblas_sscal(n, alpha, x, 1)
}

// Vector addition: y = alpha * x + y
pub fn blas_axpy(n: i32, alpha: f32, x: *f32, y: *f32) {
    cblas_saxpy(n, alpha, x, 1, y, 1)
}
