/* Generated by AetherLang C Backend */
#include <stdint.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <immintrin.h>  /* SSE/AVX */

/* AetherLang Runtime */
static void aether_print(const char* s) { printf("%s", s); }
static void aether_println(const char* s) { printf("%s\n", s); }
static void aether_print_i64(int64_t n) { printf("%lld", (long long)n); }
static void aether_println_i64(int64_t n) { printf("%lld\n", (long long)n); }
static void aether_assert(bool c) { if(!c) { fprintf(stderr, "Assertion failed\n"); exit(1); } }

/* Struct Definitions */
__m128 f32x4_new(float, float, float, float);
__m128 f32x4_splat(float);
__m128 f32x4_add(__m128, __m128);
__m128 f32x4_sub(__m128, __m128);
__m128 f32x4_mul(__m128, __m128);
__m128 f32x4_div(__m128, __m128);
float f32x4_dot(__m128, __m128);
float f32x4_sum(__m128);
__m128 f32x4_load(float*);
void f32x4_store(float*, __m128);
__m128d f64x2_new(double, double);
__m128d f64x2_splat(double);
__m128d f64x2_add(__m128d, __m128d);
__m128d f64x2_mul(__m128d, __m128d);
__m128i i32x4_new(int32_t, int32_t, int32_t, int32_t);
__m128i i32x4_splat(int32_t);
__m128i i32x4_add(__m128i, __m128i);
__m128i i32x4_mul(__m128i, __m128i);

__m128 f32x4_new(float _arg0, float _arg1, float _arg2, float _arg3) {
    float _t0;
    float _t1;
    float _t2;
    float _t3;
    int64_t _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _mm_set_ps(_t0, _t1, _t2, _t3);
    return _t4;
}

__m128 f32x4_splat(float _arg0) {
    float _t0;
    int64_t _t1;
    
    _t0 = _arg0;
    _mm_set1_ps(_t0);
    return _t1;
}

__m128 f32x4_add(__m128 _arg0, __m128 _arg1) {
    __m128 _t0;
    __m128 _t1;
    int64_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _mm_add_ps(_t0, _t1);
    return _t2;
}

__m128 f32x4_sub(__m128 _arg0, __m128 _arg1) {
    __m128 _t0;
    __m128 _t1;
    int64_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _mm_sub_ps(_t0, _t1);
    return _t2;
}

__m128 f32x4_mul(__m128 _arg0, __m128 _arg1) {
    __m128 _t0;
    __m128 _t1;
    int64_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _mm_mul_ps(_t0, _t1);
    return _t2;
}

__m128 f32x4_div(__m128 _arg0, __m128 _arg1) {
    __m128 _t0;
    __m128 _t1;
    int64_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _mm_div_ps(_t0, _t1);
    return _t2;
}

float f32x4_dot(__m128 _arg0, __m128 _arg1) {
    __m128 _t0;
    __m128 _t1;
    __m128 _t2;
    __m128 _t3;
    int64_t _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _mm_mul_ps(_t0, _t1);
    _t3 = _t2;
    __simd_f32x4_sum(_t3);
    return _t4;
}

float f32x4_sum(__m128 _arg0) {
    __m128 _t0;
    int64_t _t1;
    
    _t0 = _arg0;
    __simd_f32x4_sum(_t0);
    return _t1;
}

__m128 f32x4_load(float* _arg0) {
    float* _t0;
    int64_t _t1;
    
    _t0 = _arg0;
    _mm_loadu_ps(_t0);
    return _t1;
}

void f32x4_store(float* _arg0, __m128 _arg1) {
    __m128 _t1;
    float* _t0;
    int64_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _mm_storeu_ps(_t0, _t1);
    return;
}

__m128d f64x2_new(double _arg0, double _arg1) {
    double _t0;
    double _t1;
    int64_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _mm_set_pd(_t0, _t1);
    return _t2;
}

__m128d f64x2_splat(double _arg0) {
    double _t0;
    int64_t _t1;
    
    _t0 = _arg0;
    _mm_set1_pd(_t0);
    return _t1;
}

__m128d f64x2_add(__m128d _arg0, __m128d _arg1) {
    __m128d _t0;
    __m128d _t1;
    int64_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _mm_add_pd(_t0, _t1);
    return _t2;
}

__m128d f64x2_mul(__m128d _arg0, __m128d _arg1) {
    __m128d _t0;
    __m128d _t1;
    int64_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _mm_mul_pd(_t0, _t1);
    return _t2;
}

__m128i i32x4_new(int32_t _arg0, int32_t _arg1, int32_t _arg2, int32_t _arg3) {
    int32_t _t0;
    int32_t _t1;
    int32_t _t2;
    int32_t _t3;
    int64_t _t4;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _t2 = _arg2;
    _t3 = _arg3;
    _mm_set_epi32(_t0, _t1, _t2, _t3);
    return _t4;
}

__m128i i32x4_splat(int32_t _arg0) {
    int32_t _t0;
    int64_t _t1;
    
    _t0 = _arg0;
    _mm_set1_epi32(_t0);
    return _t1;
}

__m128i i32x4_add(__m128i _arg0, __m128i _arg1) {
    __m128i _t0;
    __m128i _t1;
    int64_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _mm_add_epi32(_t0, _t1);
    return _t2;
}

__m128i i32x4_mul(__m128i _arg0, __m128i _arg1) {
    __m128i _t0;
    __m128i _t1;
    int64_t _t2;
    
    _t0 = _arg0;
    _t1 = _arg1;
    _mm_mullo_epi32(_t0, _t1);
    return _t2;
}

